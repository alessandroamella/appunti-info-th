\documentclass[a4paper]{article}
\usepackage{amsmath, amssymb, amsfonts}
\usepackage[italian]{babel}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage[a4paper, total={6in, 8in}]{geometry}
\usepackage{minted}
\usepackage{mathpazo} % For a nicer font
\usepackage{fancyhdr}
\usepackage{amsthm}
\usepackage{tikz}
\usetikzlibrary{automata,positioning, arrows.meta} % Added arrows.meta for better arrow styles

% Definizione degli ambienti
\newtheorem{theorem}{Teorema}[section] % Number theorems by section
\newtheorem{definition}{Definizione}[section] % Number definitions by section
\newtheorem{example}{Esempio}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem{proposition}{Proposizione}[section]

% Custom proof environment (optional, amsthm provides one)
\makeatletter
\renewenvironment{proof}[1][\proofname]{\par
  \pushQED{\qed}%
  \normalfont \topsep6\p@\@plus6\p@\relax
  \trivlist
  \item[\hskip\labelsep
        \bfseries
    #1\@addpunct{.}]\ignorespaces
}{%
  \popQED\endtrivlist\@endpefalse
}
\makeatother

\hypersetup{
    pdftitle={Lezione di Informatica Teorica},
    pdfauthor={Appunti da Trascrizione AI},
    colorlinks=true,
    linkcolor=blue,
    urlcolor=blue,
    citecolor=blue
}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\textit{Lezione di Informatica Teorica}}
\fancyfoot[C]{\thepage}

\title{Lezione di Informatica Teorica: Decidibilità e Indecidibilità}
\author{Appunti da Trascrizione Automatica}
\date{\today}

\begin{document}
\maketitle
\tableofcontents
\newpage

\section{Introduzione e Ripasso}
Ripassiamo i concetti fondamentali della scorsa lezione, chiarendo alcuni punti sulla Macchina Universale (MU) e introducendo nuovi linguaggi e problemi legati alla decidibilità.

\subsection{Macchina Universale (MU)}
La Macchina Universale è una Macchina di Turing programmabile, capace di simulare il comportamento di qualsiasi altra Macchina di Turing. Sebbene la sua funzione di transizione sia complessa, la sua progettazione è fattibile e si può realizzare con un numero limitato di stati.

\subsection{Linguaggio Diagonale (LD)}
La scorsa lezione abbiamo introdotto il linguaggio diagonale $LD$:
\begin{definition}[Linguaggio Diagonale (LD)]
Il linguaggio diagonale $LD$ è l'insieme delle codifiche di Macchine di Turing $M_i$ tali che $M_i$ non accetta la propria codifica $\langle M_i \rangle$.
\[ LD = \{ \langle M_i \rangle \mid M_i \text{ non accetta } \langle M_i \rangle \} \]
\end{definition}

Abbiamo dimostrato che $LD$ non appartiene alla classe dei linguaggi ricorsivamente enumerabili ($R_e$).
\begin{theorem}
$LD \notin R_e$.
\end{theorem}
\begin{proof}
La dimostrazione si basa sulla tecnica di diagonalizzazione di Cantor, già vista in precedenza. Assumendo per assurdo l'esistenza di una Macchina di Turing $M_D$ che accetta $LD$, si può costruire una contraddizione nel comportamento di $M_D$ sulla propria codifica.
\end{proof}

Una conseguenza diretta di questo teorema è che $LD$ non può appartenere nemmeno alla classe dei linguaggi ricorsivi ($R$).
\begin{proposition}
Se $L \in R$, allora $L \in R_e$.
Poiché $LD \notin R_e$, allora $LD \notin R$.
\end{proposition}

\section{Linguaggio Universale (LU)}

Introduciamo il Linguaggio Universale.
\begin{definition}[Linguaggio Universale (LU)]
Il linguaggio universale $LU$ è l'insieme delle coppie $\langle M, w \rangle$, dove $M$ è una Macchina di Turing e $w$ è una stringa, tali che $M$ accetta $w$. L'operatore "accetta" (indicato anche con $\models$) implica che $M$ si arresta in uno stato accettante su $w$.
\[ LU = \{ \langle M, w \rangle \mid M \text{ accetta } w \} \]
\end{definition}

\begin{theorem}
$LU \in R_e$.
\end{theorem}
\begin{proof}
Per dimostrare che $LU \in R_e$, dobbiamo mostrare l'esistenza di una Macchina di Turing che lo accetti. Tale macchina è la Macchina Universale (MU).
\begin{enumerate}
    \item La MU prende in input la codifica $\langle M, w \rangle$.
    \item La MU simula passo-passo il comportamento di $M$ su $w$.
    \item Se $M$ si arresta in uno stato accettante su $w$, la MU si arresta e accetta (risponde "sì").
    \item Se $M$ si arresta in uno stato non accettante su $w$, la MU si arresta e rifiuta (risponde "no").
    \item Se $M$ non si arresta su $w$ (entra in un loop infinito), la MU simulerà all'infinito e non si arresterà (non darà risposta "sì").
\end{enumerate}
Poiché la MU accetta tutte le istanze di $LU$ e non accetta quelle che non vi appartengono, $LU$ è ricorsivamente enumerabile.
\end{proof}

Ora, la domanda cruciale: $LU \in R$? Intuitivamente, se $M$ va in loop su $w$, la MU non si arresterà per dare una risposta "no". Questo suggerisce che $LU$ non sia decidibile.

\begin{theorem}
$LU \notin R$.
\end{theorem}
\begin{proof}
La dimostrazione procede per assurdo, utilizzando una riduzione da $LD$ (di cui sappiamo la non appartenenza a $R_e$, e quindi a $R$).

\textbf{Assunzione per assurdo:} Supponiamo che $LU \in R$.
\begin{enumerate}
    \item Se $LU \in R$, allora per le proprietà delle classi di linguaggi, anche il suo complemento $\overline{LU} \in R$.
    \item Se $\overline{LU} \in R$, allora esiste una Macchina di Turing $M_{\overline{LU}}$ che \textbf{decide} $\overline{LU}$. Ciò significa che $M_{\overline{LU}}$ si arresta sempre (su ogni input) e dà una risposta corretta (sì/no).
    \item Costruiamo una nuova Macchina di Turing $M'$ che prende in input una codifica di macchina $\langle M_i \rangle$. Il comportamento di $M'$ è il seguente:
    \begin{enumerate}
        \item Riceve $\langle M_i \rangle$ come input.
        \item Crea una copia di $\langle M_i \rangle$ e la usa come stringa $w$. Forma la coppia $\langle M_i, \langle M_i \rangle \rangle$. (Quindi l'input per la fase successiva è $\langle M_i, w \rangle$ dove $w = \langle M_i \rangle$).
        \item Dà in input la coppia $\langle M_i, \langle M_i \rangle \rangle$ alla macchina $M_{\overline{LU}}$ (la cui esistenza è garantita dalla nostra assunzione).
        \item $M'$ adotta la risposta di $M_{\overline{LU}}$:
        \begin{itemize}
            \item Se $M_{\overline{LU}}$ risponde "sì", allora $M'$ risponde "sì".
            \item Se $M_{\overline{LU}}$ risponde "no", allora $M'$ risponde "no".
        \end{itemize}
    \end{enumerate}
\end{enumerate}
Ora analizziamo il linguaggio deciso da $M'$, $L(M')$:
\begin{itemize}
    \item \textbf{Se $M'$ risponde "sì":}
    Ciò significa che $M_{\overline{LU}}$ ha risposto "sì" sull'input $\langle M_i, \langle M_i \rangle \rangle$.
    Poiché $M_{\overline{LU}}$ decide $\overline{LU}$, la risposta "sì" implica che $\langle M_i, \langle M_i \rangle \rangle \in \overline{LU}$.
    Per definizione di $\overline{LU}$, ciò significa che $M_i$ \textbf{non accetta} $\langle M_i \rangle$.
    \item \textbf{Se $M'$ risponde "no":}
    Ciò significa che $M_{\overline{LU}}$ ha risposto "no" sull'input $\langle M_i, \langle M_i \rangle \rangle$.
    Poiché $M_{\overline{LU}}$ decide $\overline{LU}$, la risposta "no" implica che $\langle M_i, \langle M_i \rangle \rangle \notin \overline{LU}$, ovvero $\langle M_i, \langle M_i \rangle \rangle \in LU$.
    Per definizione di $LU$, ciò significa che $M_i$ \textbf{accetta} $\langle M_i \rangle$.
\end{itemize}
Il comportamento di $M'$ è esattamente quello di una macchina che decide $LD$. Infatti, $M'$ risponde "sì" se $M_i$ non accetta $\langle M_i \rangle$, e "no" se $M_i$ accetta $\langle M_i \rangle$. Dunque, $L(M') = LD$.

Poiché $M'$ è costruita usando $M_{\overline{LU}}$ (che è un decider e si arresta sempre), $M'$ è anch'essa una Macchina di Turing che si arresta sempre, ovvero un decider.
Questo implicherebbe che $LD \in R$.

\textbf{Contraddizione:} Sappiamo che $LD \notin R_e$, e quindi $LD \notin R$.
L'assunzione iniziale ($LU \in R$) deve essere falsa.

\textbf{Conclusione:} $LU \notin R$.
\end{proof}

\subsection{Il Complemento del Linguaggio Diagonale ($\overline{LD}$)}
Consideriamo ora il complemento di $LD$:
\begin{definition}[Complemento del Linguaggio Diagonale ($\overline{LD}$)]
Il complemento del linguaggio diagonale $\overline{LD}$ è l'insieme delle codifiche di Macchine di Turing $M_i$ tali che $M_i$ accetta la propria codifica $\langle M_i \rangle$.
\[ \overline{LD} = \{ \langle M_i \rangle \mid M_i \text{ accetta } \langle M_i \rangle \} \]
\end{definition}

\begin{theorem}
$\overline{LD} \in R_e$.
\end{theorem}
\begin{proof}
Per dimostrare che $\overline{LD} \in R_e$, dobbiamo costruire una Macchina di Turing $M_{\overline{LD}}$ che accetti $\overline{LD}$.

\textbf{Costruzione di $M_{\overline{LD}}$:}
\begin{enumerate}
    \item $M_{\overline{LD}}$ prende in input la codifica di una Macchina di Turing $\langle M_i \rangle$.
    \item $M_{\overline{LD}}$ crea una copia di $\langle M_i \rangle$ per usarla come stringa $w$. Forma quindi la coppia $\langle M_i, \langle M_i \rangle \rangle$.
    \item $M_{\overline{LD}}$ simula $M_i$ su $\langle M_i \rangle$ usando una Macchina Universale (MU).
    \item Se la simulazione di $M_i$ su $\langle M_i \rangle$ si arresta e accetta, allora $M_{\overline{LD}}$ accetta (risponde "sì").
    \item Se la simulazione di $M_i$ su $\langle M_i \rangle$ si arresta e rifiuta, o entra in loop, allora $M_{\overline{LD}}$ non accetta (risponde "no" o va in loop).
\end{enumerate}
\textbf{Analisi del comportamento di $M_{\overline{LD}}$:}
\begin{itemize}
    \item \textbf{Se $\langle M_i \rangle \in \overline{LD}$:}
    Per definizione, $M_i$ accetta $\langle M_i \rangle$. La simulazione della MU si arresterà e accetterà. Di conseguenza, $M_{\overline{LD}}$ accetterà.
    \item \textbf{Se $\langle M_i \rangle \notin \overline{LD}$:}
    Per definizione, $M_i$ non accetta $\langle M_i \rangle$. Ciò significa che $M_i$ o rifiuta o va in loop su $\langle M_i \rangle$.
    \begin{itemize}
        \item Se $M_i$ rifiuta $\langle M_i \rangle$, la simulazione della MU si arresterà e rifiuterà. $M_{\overline{LD}}$ non accetterà.
        \item Se $M_i$ va in loop su $\langle M_i \rangle$, la simulazione della MU andrà in loop. $M_{\overline{LD}}$ non accetterà.
    \end{itemize}
\end{itemize}
Poiché $M_{\overline{LD}}$ accetta esattamente le stringhe che appartengono a $\overline{LD}$, si conclude che $\overline{LD} \in R_e$.
\end{proof}

\begin{proposition}
$\overline{LD} \notin R$.
\end{proposition}
\begin{proof}
Se $\overline{LD}$ fosse in $R$, allora per la proprietà che $R$ è chiusa rispetto al complemento, anche $LD$ sarebbe in $R$. Ma sappiamo che $LD \notin R_e$, e quindi $LD \notin R$. Questo è una contraddizione.
\end{proof}

\begin{figure}[h!]
    \centering
    \begin{tikzpicture}[node distance=1.8cm, >=Stealth]
        \draw (0,0) circle (3cm) node[below] {$R_e$};
        \draw (0,0) circle (1.5cm) node[above] {$R$};
        \node at (2.5, 2.5) {$\overline{LU}$};
        \node at (2.5, -2.5) {$\overline{HALT}$};
        \node at (1.0, 1.0) {$LU$};
        \node at (1.0, -1.0) {$HALT$};
        \node at (-1.0, 1.0) {$\overline{LD}$};
        \node at (-1.0, -1.0) {$LD$}; % Errore di posizionamento nella figura del professore, LD è fuori Re. Correggo qui.
        
        % Aggiustamenti per chiarezza e correttezza (LD fuori Re)
        \node at (4.0, 0) {$LD$}; % LD è fuori Re
        \node at (-4.0, 0) {?}; % Altri linguaggi non in Re
    \end{tikzpicture}
    \caption{Relazioni tra classi di linguaggi R e $R_e$ e posizione di alcuni linguaggi}
    \label{fig:r_re_map}
\end{figure}

\section{Problema dell'Arresto (HALT)}
Introduciamo il famoso Problema dell'Arresto.
\begin{definition}[Problema dell'Arresto (HALT)]
Il linguaggio $HALT$ è l'insieme delle coppie $\langle M, w \rangle$, dove $M$ è una Macchina di Turing e $w$ è una stringa, tali che $M$ si arresta su $w$ (indipendentemente dal fatto che accetti o rifiuti).
\[ HALT = \{ \langle M, w \rangle \mid M \text{ si arresta su } w \} \]
\end{definition}
La differenza con $LU$ è sottile ma cruciale: $LU$ richiede l'accettazione, $HALT$ richiede solo l'arresto.

\begin{theorem}
$HALT \in R_e$.
\end{theorem}
\begin{proof}
Per dimostrare che $HALT \in R_e$, dobbiamo costruire una Macchina di Turing $M_{HALT}$ che accetti $HALT$.

\textbf{Costruzione di $M_{HALT}$:}
\begin{enumerate}
    \item $M_{HALT}$ prende in input la coppia $\langle M, w \rangle$.
    \item $M_{HALT}$ simula $M$ su $w$ usando una Macchina Universale (MU).
    \item Se la simulazione di $M$ su $w$ si arresta (sia in uno stato accettante che non accettante), allora $M_{HALT}$ accetta (risponde "sì").
    \item Se la simulazione di $M$ su $w$ entra in loop infinito, allora $M_{HALT}$ entra in loop (non risponde "sì").
\end{enumerate}
\textbf{Analisi del comportamento di $M_{HALT}$:}
\begin{itemize}
    \item \textbf{Se $\langle M, w \rangle \in HALT$:}
    Per definizione, $M$ si arresta su $w$. La simulazione della MU si arresterà. Di conseguenza, $M_{HALT}$ accetterà.
    \item \textbf{Se $\langle M, w \rangle \notin HALT$:}
    Per definizione, $M$ non si arresta su $w$ (va in loop). La simulazione della MU andrà in loop. Di conseguenza, $M_{HALT}$ non accetterà.
\end{itemize}
Poiché $M_{HALT}$ accetta esattamente le istanze di $HALT$, si conclude che $HALT \in R_e$.
\end{proof}

\begin{theorem}
$HALT \notin R$.
\end{theorem}
\begin{proof}
La dimostrazione procede per assurdo, utilizzando una riduzione da $LU$ (di cui sappiamo la non appartenenza a $R$).

\textbf{Assunzione per assurdo:} Supponiamo che $HALT \in R$.
\begin{enumerate}
    \item Se $HALT \in R$, allora esiste una Macchina di Turing $M_{HALT}^*$ che \textbf{decide} $HALT$. Ciò significa che $M_{HALT}^*$ si arresta sempre e dà una risposta corretta (sì/no).
    \item Costruiamo una nuova Macchina di Turing $M'$ che prende in input una coppia $\langle M, w \rangle$. Il comportamento di $M'$ è il seguente:
    \begin{enumerate}
        \item Riceve $\langle M, w \rangle$ come input.
        \item Dà in input $\langle M, w \rangle$ alla macchina $M_{HALT}^*$ (la cui esistenza è garantita dalla nostra assunzione).
        \item $M'$ verifica la risposta di $M_{HALT}^*$:
        \begin{itemize}
            \item \textbf{Se $M_{HALT}^*$ risponde "no"}: (Significa che $M$ non si arresta su $w$). Allora $M'$ risponde "no". (In questo caso, $M$ non può accettare $w$, quindi $\langle M, w \rangle \notin LU$).
            \item \textbf{Se $M_{HALT}^*$ risponde "sì"}: (Significa che $M$ si arresta su $w$). Allora $M'$ simula $M$ su $w$ usando una Macchina Universale (MU).
            \begin{itemize}
                \item Se la simulazione di $M$ su $w$ si arresta e accetta, allora $M'$ risponde "sì".
                \item Se la simulazione di $M$ su $w$ si arresta e rifiuta, allora $M'$ risponde "no".
            \end{itemize}
        \end{itemize}
    \end{enumerate}
\end{enumerate}
Ora analizziamo il linguaggio deciso da $M'$, $L(M')$:
\begin{itemize}
    \item \textbf{Se $M'$ risponde "sì":}
    Ciò accade solo se $M_{HALT}^*$ ha risposto "sì" (cioè $M$ si arresta su $w$) \textbf{e} la simulazione di $M$ su $w$ ha accettato.
    Questo significa che $M$ accetta $w$. Quindi, $\langle M, w \rangle \in LU$.
    \item \textbf{Se $M'$ risponde "no":}
    Ciò può accadere in due scenari:
    \begin{itemize}
        \item Scenario 1: $M_{HALT}^*$ ha risposto "no". Questo significa che $M$ non si arresta su $w$. Se $M$ non si arresta, non può accettare $w$. Quindi, $\langle M, w \rangle \notin LU$.
        \item Scenario 2: $M_{HALT}^*$ ha risposto "sì", ma la simulazione di $M$ su $w$ ha rifiutato. Questo significa che $M$ si è arrestata su $w$ ma non ha accettato $w$. Quindi, $\langle M, w \rangle \notin LU$.
    \end{itemize}
    In entrambi gli scenari, $M'$ risponde "no" se $\langle M, w \rangle \notin LU$.
\end{itemize}
Il comportamento di $M'$ è esattamente quello di una macchina che decide $LU$. Dunque, $L(M') = LU$.

Poiché $M'$ è costruita usando $M_{HALT}^*$ (che è un decider e si arresta sempre), e la parte di simulazione dopo la risposta "sì" di $M_{HALT}^*$ è garantita arrestarsi, $M'$ è anch'essa una Macchina di Turing che si arresta sempre, ovvero un decider.
Questo implicherebbe che $LU \in R$.

\textbf{Contraddizione:} Sappiamo che $LU \notin R$.
L'assunzione iniziale ($HALT \in R$) deve essere falsa.

\textbf{Conclusione:} $HALT \notin R$.
\end{proof}

\begin{proposition}
Il complemento di $HALT$, $\overline{HALT}$, non appartiene a $R$.
\end{proposition}
\begin{proof}
Se $\overline{HALT}$ fosse in $R$, allora per la proprietà che $R$ è chiusa rispetto al complemento, anche $HALT$ sarebbe in $R$. Ma abbiamo appena dimostrato che $HALT \notin R$. Questo è una contraddizione.
\end{proof}

\section{Problema dell'Arresto su Stringa Vuota (HALT$_\epsilon$)}
Questa è una variante specifica del problema dell'arresto.
\begin{definition}[Problema dell'Arresto su Stringa Vuota (HALT$_\epsilon$)]
Il linguaggio $HALT_\epsilon$ è l'insieme delle codifiche di Macchine di Turing $M$ tali che $M$ si arresta quando le viene data in input la stringa vuota $\epsilon$.
\[ HALT_\epsilon = \{ \langle M \rangle \mid M \text{ si arresta su } \epsilon \} \]
\end{definition}

\begin{theorem}
$HALT_\epsilon \in R_e$.
\end{theorem}
\begin{proof}
Per dimostrare che $HALT_\epsilon \in R_e$, dobbiamo costruire una Macchina di Turing $M_{HALT_\epsilon}$ che accetti $HALT_\epsilon$.

\textbf{Costruzione di $M_{HALT_\epsilon}$:}
\begin{enumerate}
    \item $M_{HALT_\epsilon}$ prende in input la codifica $\langle M \rangle$.
    \item $M_{HALT_\epsilon}$ simula $M$ sulla stringa vuota $\epsilon$ usando una Macchina Universale (MU).
    \item Se la simulazione di $M$ su $\epsilon$ si arresta (sia accettando che rifiutando), allora $M_{HALT_\epsilon}$ accetta (risponde "sì").
    \item Se la simulazione di $M$ su $\epsilon$ entra in loop infinito, allora $M_{HALT_\epsilon}$ entra in loop (non risponde "sì").
\end{enumerate}
\textbf{Analisi del comportamento di $M_{HALT_\epsilon}$:}
\begin{itemize}
    \item \textbf{Se $\langle M \rangle \in HALT_\epsilon$:}
    Per definizione, $M$ si arresta su $\epsilon$. La simulazione della MU si arresterà. Di conseguenza, $M_{HALT_\epsilon}$ accetterà.
    \item \textbf{Se $\langle M \rangle \notin HALT_\epsilon$:}
    Per definizione, $M$ non si arresta su $\epsilon$ (va in loop). La simulazione della MU andrà in loop. Di conseguenza, $M_{HALT_\epsilon}$ non accetterà.
\end{itemize}
Poiché $M_{HALT_\epsilon}$ accetta esattamente le istanze di $HALT_\epsilon$, si conclude che $HALT_\epsilon \in R_e$.
\end{proof}

\begin{theorem}
$HALT_\epsilon \notin R$.
\end{theorem}
\begin{proof}
La dimostrazione procede per assurdo, utilizzando una riduzione da $HALT$ (di cui sappiamo la non appartenenza a $R$).

\textbf{Assunzione per assurdo:} Supponiamo che $HALT_\epsilon \in R$.
\begin{enumerate}
    \item Se $HALT_\epsilon \in R$, allora esiste una Macchina di Turing $M_{HALT_\epsilon}^*$ che \textbf{decide} $HALT_\epsilon$. Ciò significa che $M_{HALT_\epsilon}^*$ si arresta sempre e dà una risposta corretta (sì/no).
    \item Costruiamo una nuova Macchina di Turing $M'$ che prende in input una coppia $\langle M, w \rangle$. Il comportamento di $M'$ è il seguente:
    \begin{enumerate}
        \item Riceve $\langle M, w \rangle$ come input.
        \item $M'$ costruisce (mediante un "modulo di reshaping") una nuova Macchina di Turing, che chiamiamo $M_{M,w}$ (o $M_w^{\text{tilde}}$), la cui codifica $\langle M_{M,w} \rangle$ viene passata al passo successivo.
        \item La Macchina $M_{M,w}$ è definita come segue:
        \begin{itemize}
            \item Quando $M_{M,w}$ viene avviata su un qualsiasi input (ad esempio, la stringa vuota $\epsilon$), ignora l'input.
            \item Cancella il suo nastro di input.
            \item Scrive la stringa $w$ (ottenuta dalla coppia $\langle M, w \rangle$ iniziale) sul proprio nastro.
            \item Simula la Macchina di Turing $M$ (ottenuta dalla coppia $\langle M, w \rangle$ iniziale) sul contenuto attuale del nastro, ovvero su $w$.
            \item $M_{M,w}$ accetta se $M$ accetta $w$, rifiuta se $M$ rifiuta $w$, va in loop se $M$ va in loop su $w$. In sintesi, $M_{M,w}$ si arresta su $\epsilon$ se e solo se $M$ si arresta su $w$.
        \end{itemize}
        \item $M'$ dà in input la codifica $\langle M_{M,w} \rangle$ alla macchina $M_{HALT_\epsilon}^*$.
        \item $M'$ adotta la risposta di $M_{HALT_\epsilon}^*$:
        \begin{itemize}
            \item Se $M_{HALT_\epsilon}^*$ risponde "sì", allora $M'$ risponde "sì".
            \item Se $M_{HALT_\epsilon}^*$ risponde "no", allora $M'$ risponde "no".
        \end{itemize}
    \end{enumerate}
\end{enumerate}
Ora analizziamo il linguaggio deciso da $M'$, $L(M')$:
\begin{itemize}
    \item \textbf{Se $M'$ risponde "sì":}
    Ciò significa che $M_{HALT_\epsilon}^*$ ha risposto "sì" sull'input $\langle M_{M,w} \rangle$.
    Poiché $M_{HALT_\epsilon}^*$ decide $HALT_\epsilon$, la risposta "sì" implica che $M_{M,w}$ si arresta su $\epsilon$.
    Per come abbiamo costruito $M_{M,w}$, questa si arresta su $\epsilon$ se e solo se $M$ si arresta su $w$.
    Quindi, $M$ si arresta su $w$. Ciò significa che $\langle M, w \rangle \in HALT$.
    \item \textbf{Se $M'$ risponde "no":}
    Ciò significa che $M_{HALT_\epsilon}^*$ ha risposto "no" sull'input $\langle M_{M,w} \rangle$.
    Poiché $M_{HALT_\epsilon}^*$ decide $HALT_\epsilon$, la risposta "no" implica che $M_{M,w}$ non si arresta su $\epsilon$.
    Per come abbiamo costruito $M_{M,w}$, questa non si arresta su $\epsilon$ se e solo se $M$ non si arresta su $w$.
    Quindi, $M$ non si arresta su $w$. Ciò significa che $\langle M, w \rangle \notin HALT$.
\end{itemize}
Il comportamento di $M'$ è esattamente quello di una macchina che decide $HALT$. Dunque, $L(M') = HALT$.

Poiché $M'$ è costruita usando $M_{HALT_\epsilon}^*$ (che è un decider e si arresta sempre), $M'$ è anch'essa una Macchina di Turing che si arresta sempre, ovvero un decider.
Questo implicherebbe che $HALT \in R$.

\textbf{Contraddizione:} Sappiamo che $HALT \notin R$.
L'assunzione iniziale ($HALT_\epsilon \in R$) deve essere falsa.

\textbf{Conclusione:} $HALT_\epsilon \notin R$.
\end{proof}

\begin{proposition}
Il complemento di $HALT_\epsilon$, $\overline{HALT_\epsilon}$, non appartiene a $R$.
\end{proposition}
\begin{proof}
Se $\overline{HALT_\epsilon}$ fosse in $R$, allora per la proprietà che $R$ è chiusa rispetto al complemento, anche $HALT_\epsilon$ sarebbe in $R$. Ma abbiamo appena dimostrato che $HALT_\epsilon \notin R$. Questo è una contraddizione.
\end{proof}

\section{Riepilogo e Conclusioni}
Abbiamo esplorato la decidibilità di diversi linguaggi fondamentali per la teoria della computazione:
\begin{itemize}
    \item $LD$: Non ricorsivamente enumerabile ($LD \notin R_e \implies LD \notin R$).
    \item $\overline{LD}$: Ricorsivamente enumerabile ($\overline{LD} \in R_e$), ma non ricorsivo ($\overline{LD} \notin R$).
    \item $LU$: Ricorsivamente enumerabile ($LU \in R_e$), ma non ricorsivo ($LU \notin R$).
    \item $HALT$: Ricorsivamente enumerabile ($HALT \in R_e$), ma non ricorsivo ($HALT \notin R$).
    \item $HALT_\epsilon$: Ricorsivamente enumerabile ($HALT_\epsilon \in R_e$), ma non ricorsivo ($HALT_\epsilon \notin R$).
\end{itemize}
Tutti i problemi di non appartenenza a $R$ sono stati dimostrati mediante riduzione ad altri problemi di cui era già nota la non decidibilità. Questo è un metodo standard in teoria della computazione per dimostrare l'indecidibilità.

\begin{figure}[h!]
    \centering
    \begin{tikzpicture}[node distance=1.8cm, >=Stealth]
        % R_e boundary
        \draw[thick, blue] (0,0) circle (3.5cm) node[below right, blue] {$R_e$};
        
        % R boundary
        \draw[thick, green] (0,0) circle (1.8cm) node[above right, green] {$R$};
        
        % Languages inside R_e but outside R (Recursively Enumerable but not Recursive)
        \node[red] at (2.5, 2.5) {$LU$};
        \node[red] at (2.5, -2.5) {$HALT$};
        \node[red] at (-2.5, 2.5) {$\overline{LD}$};
        \node[red] at (-2.5, -2.5) {$HALT_\epsilon$};
        
        % Languages outside R_e (and therefore outside R)
        \node[purple] at (4.5, 0) {$LD$};
        \node[purple] at (-4.5, 0) {$\overline{HALT}$};
        \node[purple] at (0, 4.5) {$\overline{LU}$}; % Also outside R_e, by implication from LU
        \node[purple] at (0, -4.5) {$\overline{HALT_\epsilon}$}; % Also outside R_e, by implication from HALT_epsilon
    \end{tikzpicture}
    \caption{Mappa aggiornata delle classi di linguaggi $R$ e $R_e$ con i linguaggi discussi.}
    \label{fig:r_re_map_updated}
\end{figure}

\end{document}