1
00:00:00,000 --> 00:00:03,000
Ok,

2
00:00:28,000 --> 00:00:30,000
ok, ok. Iniziamo un nuovo argomento.

3
00:00:30,000 --> 00:00:33,840
Oggi e

4
00:00:34,559 --> 00:00:36,680
vedremo altre classi di complessità.

5
00:00:36,680 --> 00:00:39,040
Vedremo altre classi di complessità fino

6
00:00:39,040 --> 00:00:42,160
a chiusura

7
00:00:43,000 --> 00:00:47,280
e poi facciamo Mokizzam.

8
00:00:49,559 --> 00:00:51,160
Ok. quello di cui ci siamo occupati

9
00:00:51,160 --> 00:00:54,239
finora nella definizione

10
00:00:54,239 --> 00:00:56,039
nella definizione di di classi

11
00:00:56,039 --> 00:00:57,760
complessità,

12
00:00:57,760 --> 00:00:59,559
quello che abbiamo visto finora sono

13
00:00:59,559 --> 00:01:03,440
classi di complessità temporale,

14
00:01:03,440 --> 00:01:05,560
cioè quanto tempo ci impiega un

15
00:01:05,560 --> 00:01:07,759
algoritmo ad eseguire. Ok? Quello che

16
00:01:07,759 --> 00:01:10,759
non ci siamo chiesti finora,

17
00:01:10,759 --> 00:01:12,720
quanta memoria gli serve all'algoritmo,

18
00:01:12,720 --> 00:01:14,200
ok? Perché sicuramente nel corso di

19
00:01:14,200 --> 00:01:16,159
algoritmi e strutture dati avrete visto

20
00:01:16,159 --> 00:01:18,640
la complessità spaziale, la complessità

21
00:01:18,640 --> 00:01:21,520
temporale, eccetera. Oggi introduciamo,

22
00:01:21,520 --> 00:01:24,880
ci concentreremo oggi e domani su classi

23
00:01:24,880 --> 00:01:28,320
di complessità spaziale

24
00:01:28,320 --> 00:01:31,840
e ok, non non scenderemo troppo nei

25
00:01:31,840 --> 00:01:33,360
dettagli

26
00:01:33,360 --> 00:01:35,720
e le collocheremo insieme insieme al

27
00:01:35,720 --> 00:01:39,399
resto per vedere un po' come come si

28
00:01:39,399 --> 00:01:42,159
si collocano. Ok?

29
00:01:42,159 --> 00:01:45,600
Secondo voi

30
00:01:47,119 --> 00:01:49,399
una macchina

31
00:01:49,399 --> 00:01:52,960
che può usare,

32
00:01:53,280 --> 00:01:55,640
ok? Abbiamo due macchine, una macchina M

33
00:01:55,640 --> 00:01:59,960
e una macchina N. La macchina M

34
00:01:59,960 --> 00:02:03,479
può usare tempo

35
00:02:03,479 --> 00:02:05,880
polinomiale,

36
00:02:05,880 --> 00:02:09,959
mentre l'altra macchina, la macchina N,

37
00:02:09,959 --> 00:02:13,640
può usare spazio

38
00:02:13,640 --> 00:02:16,640
polinomiale.

39
00:02:16,879 --> 00:02:19,360
Intuitivamente ce n'è una più potente

40
00:02:19,360 --> 00:02:21,800
dell'altra.

41
00:02:21,800 --> 00:02:23,599
Sì.

42
00:02:23,599 --> 00:02:27,239
Spazio polinomiale. Perché? La prima eh

43
00:02:27,239 --> 00:02:29,640
per forza comunque come la prima per

44
00:02:29,640 --> 00:02:32,080
forza come bo uno spazio policidiale,

45
00:02:32,080 --> 00:02:33,640
quindi a tempo polinomiale, spazio

46
00:02:33,640 --> 00:02:35,680
polinormi, la seconda ha solo spazio

47
00:02:35,680 --> 00:02:39,280
polinormale, quindi può funzionare anche

48
00:02:39,280 --> 00:02:40,800
esattamente. Ma queste cose le avate già

49
00:02:40,800 --> 00:02:44,840
viste? No. Ok. Alr. Sì, l'ingip è

50
00:02:44,840 --> 00:02:47,239
quello. Siccome noi abbiamo spazio

51
00:02:47,239 --> 00:02:50,000
bounded e lo possiamo riutilizzare,

52
00:02:50,000 --> 00:02:52,360
allora in principio possiamo rannare più

53
00:02:52,360 --> 00:02:56,120
a lungo. Ok? Quindi sì, dato un certo

54
00:02:56,120 --> 00:02:58,800
vincolo, quel vincolo se è dato sul

55
00:02:58,800 --> 00:03:01,480
tempo o è dato sullo spazio fa fa la

56
00:03:01,480 --> 00:03:04,159
differenza. Ok?

57
00:03:04,159 --> 00:03:07,080
In realtà,

58
00:03:07,080 --> 00:03:08,879
come vedremo

59
00:03:08,879 --> 00:03:11,280
dopo,

60
00:03:11,280 --> 00:03:14,000
noi abbiamo che P time intuitivamente,

61
00:03:14,000 --> 00:03:16,760
adesso definiamo tutto più formalmente,

62
00:03:16,760 --> 00:03:19,560
tempo polinomiale, P sta dentro P space,

63
00:03:19,560 --> 00:03:21,840
che è la classe di spazio polinomiale.

64
00:03:21,840 --> 00:03:23,959
Però, come tante di quelle cose

65
00:03:23,959 --> 00:03:26,239
nell'area della complessità,

66
00:03:26,239 --> 00:03:29,120
noi non sappiamo se sono distinte, cioè

67
00:03:29,120 --> 00:03:31,640
noi sappiamo che P sta dentro P space,

68
00:03:31,640 --> 00:03:33,840
ma non sappiamo se P space è

69
00:03:33,840 --> 00:03:36,680
strettamente più grande di P. Ok? Qu è

70
00:03:36,680 --> 00:03:39,000
un altro di quei risultati come P versus

71
00:03:39,000 --> 00:03:43,159
NP. Sappiamo niente. Ok? Abbiamo questa

72
00:03:43,159 --> 00:03:45,680
catena di contenimenti, come abbiamo già

73
00:03:45,680 --> 00:03:47,840
visto l'altra volta, e ne vedremo altre

74
00:03:47,840 --> 00:03:50,040
fra oggi e domani, tale per cui sappiamo

75
00:03:50,040 --> 00:03:54,200
che, per esempio, fra Ptime ed exp time

76
00:03:54,200 --> 00:03:56,239
sono due classi distinte, ma tutto in

77
00:03:56,239 --> 00:03:59,560
mezzo c'è una marea di cose che da

78
00:03:59,560 --> 00:04:02,280
qualche parte devono essere distinte se

79
00:04:02,280 --> 00:04:05,159
tra Ptime ed exp time c'è un salto, però

80
00:04:05,159 --> 00:04:07,239
noi non sappiamo dove e in particolare

81
00:04:07,239 --> 00:04:09,720
crediamo che sia in tutti i passaggi,

82
00:04:09,720 --> 00:04:11,400
che c'è un contenimento stretto, ma

83
00:04:11,400 --> 00:04:13,079
nessun nessuno è mai riuscito a

84
00:04:13,079 --> 00:04:14,799
dimostrare una cosa del genere. Forse

85
00:04:14,799 --> 00:04:16,320
abbiamo tecniche di dimostrazione

86
00:04:16,320 --> 00:04:18,639
sbagliata, forse stiamo guardando in

87
00:04:18,639 --> 00:04:21,720
direzione sbagliata, non si sa. Sono

88
00:04:21,720 --> 00:04:24,720
problemi aperti da 60-70 anni e nessuno

89
00:04:24,720 --> 00:04:27,759
è mai riuscito ancora a chiudere le

90
00:04:27,759 --> 00:04:30,800
questioni. Ok? Definiamo quindi in

91
00:04:30,800 --> 00:04:33,360
maniera ehm

92
00:04:33,360 --> 00:04:37,039
più formale le classi di complessità

93
00:04:37,039 --> 00:04:39,560
spaziali, ok?

94
00:04:39,560 --> 00:04:41,400
e

95
00:04:41,400 --> 00:04:43,520
lo faremo assieme. Spero che vi

96
00:04:43,520 --> 00:04:46,440
ricordiate un po' di definizioni di

97
00:04:46,440 --> 00:04:49,080
classi di complessità temporali perché

98
00:04:49,080 --> 00:04:50,880
ragioneremo assieme. Vi faccio vedere

99
00:04:50,880 --> 00:04:52,800
come si fa a indurre, eh, perché alla

100
00:04:52,800 --> 00:04:55,360
fine i ricercatori quando si inventavano

101
00:04:55,360 --> 00:04:57,160
ste cose inducevano roba,

102
00:04:57,160 --> 00:04:59,360
generalizzavano cose, quindi le vediamo

103
00:04:59,360 --> 00:05:01,759
assieme per ragionare assieme e tireremo

104
00:05:01,759 --> 00:05:03,880
fuori assieme le definizioni in maniera

105
00:05:03,880 --> 00:05:05,320
tale che sia anche più semplice

106
00:05:05,320 --> 00:05:08,400
ricordarcele perché ci siamo arrivati.

107
00:05:08,400 --> 00:05:11,639
Ok? Allora, per prima cosa dobbiamo

108
00:05:11,639 --> 00:05:13,440
introdurre un modello differente di

109
00:05:13,440 --> 00:05:16,560
macchina di tuning,

110
00:05:16,560 --> 00:05:20,160
altrimenti viene un po' complicato

111
00:05:20,160 --> 00:05:22,880
definire la complessità spaziale. Si può

112
00:05:22,880 --> 00:05:25,520
fare, però sulle classi di complessità

113
00:05:25,520 --> 00:05:27,720
spaziali molto piccole che quelle che

114
00:05:27,720 --> 00:05:29,960
vedremo oggi, domani ne vedremo di più

115
00:05:29,960 --> 00:05:33,880
generiche, diviene difficile fare questo

116
00:05:33,880 --> 00:05:35,880
genere di definizioni. Di conseguenza ci

117
00:05:35,880 --> 00:05:38,319
serve un modello di macchine di Touring

118
00:05:38,319 --> 00:05:42,039
leggermente diverso, ok? Che poi

119
00:05:42,039 --> 00:05:44,120
generalmente se guardate la letteratura

120
00:05:44,120 --> 00:05:46,479
moderna le macchine di Touring si

121
00:05:46,479 --> 00:05:49,240
assumono in questo modo

122
00:05:49,240 --> 00:05:50,960
perché poi per vari teoremi sono

123
00:05:50,960 --> 00:05:54,520
equivalenti alle altre. Ok?

124
00:05:54,520 --> 00:05:56,319
Allora, noi abbiamo una macchina di

125
00:05:56,319 --> 00:05:58,240
Touring, si parla sempre di decisori,

126
00:05:58,240 --> 00:05:59,960
quindi macchine di Touring che

127
00:05:59,960 --> 00:06:03,080
rispondono sì, no? Poi più avanti nella

128
00:06:03,080 --> 00:06:05,000
lezione ci servirà un trasduttore, però

129
00:06:05,000 --> 00:06:07,919
è una facile generalizzazione.

130
00:06:07,919 --> 00:06:09,560
Allora,

131
00:06:09,560 --> 00:06:12,160
considereremo ora una macchina di

132
00:06:12,160 --> 00:06:14,479
touring fatta in questo modo. Ha un

133
00:06:14,479 --> 00:06:18,280
nastro di input

134
00:06:19,440 --> 00:06:21,160
che è

135
00:06:21,160 --> 00:06:24,560
un nastro di input

136
00:06:24,560 --> 00:06:27,400
sulla quale la testina può andare avanti

137
00:06:27,400 --> 00:06:29,840
e indietro, però è un nastro di sola

138
00:06:29,840 --> 00:06:31,840
lettura. La macchina sul nostro input

139
00:06:31,840 --> 00:06:33,639
non può fare niente, può solo leggere,

140
00:06:33,639 --> 00:06:35,720
può spostare la testina dove vuole, può

141
00:06:35,720 --> 00:06:38,319
spedirla a Milano se vuole, però non ci

142
00:06:38,319 --> 00:06:40,360
può scrivere. La testina può andare

143
00:06:40,360 --> 00:06:43,039
avanti e indietro, però il nastro di

144
00:06:43,039 --> 00:06:47,440
input è un nastro di sola lettura.

145
00:06:47,440 --> 00:06:50,800
Dopodiché c'è un nastro aggiuntivo

146
00:06:50,800 --> 00:06:52,759
che è il nastro di lavoro. Nella

147
00:06:52,759 --> 00:06:54,759
letteratura in inglese lo trovate

148
00:06:54,759 --> 00:06:58,240
scritto workape.

149
00:06:58,319 --> 00:07:00,720
Il nastro di lavoro è un nastro

150
00:07:00,720 --> 00:07:03,720
infinito,

151
00:07:04,879 --> 00:07:07,800
la testina del quale può andare avanti e

152
00:07:07,800 --> 00:07:10,520
indietro come siamo abituati ed è un

153
00:07:10,520 --> 00:07:13,800
nastro di lettura scrittura. Ok? Quindi

154
00:07:13,800 --> 00:07:17,000
gli scarabocchi, la brutta copia, la

155
00:07:17,000 --> 00:07:19,160
macchina di Touring la fa sul nastro di

156
00:07:19,160 --> 00:07:21,520
lavoro, sul workpape. Ok? Questa è la

157
00:07:21,520 --> 00:07:23,039
differenza rispetto alle macchine che

158
00:07:23,039 --> 00:07:26,080
abbiamo visto finora. L'input non si può

159
00:07:26,080 --> 00:07:29,120
scrivere, abbiamo un nastro, però lo

160
00:07:29,120 --> 00:07:30,879
possiamo leggere, un nastro aggiuntivo

161
00:07:30,879 --> 00:07:34,479
che è il nastro dei calcoli intermedi.

162
00:07:34,479 --> 00:07:36,879
Si può leggere e scrivere e la testina

163
00:07:36,879 --> 00:07:38,960
va avanti e indietro, quindi è standard.

164
00:07:38,960 --> 00:07:40,840
Ok?

165
00:07:40,840 --> 00:07:43,960
Machine,
come si chiama?

166
00:07:43,960 --> 00:07:46,319
Macchine di Touring.
Sì. No, no, non

167
00:07:46,319 --> 00:07:47,800
abbiamo un nome particolare. Le

168
00:07:47,800 --> 00:07:50,360
assumiamo fatte così per vari risultati

169
00:07:50,360 --> 00:07:52,720
che non andiamo a guardare. Siccome è

170
00:07:52,720 --> 00:07:54,639
una macchina multinastro, questa alla

171
00:07:54,639 --> 00:07:56,680
fine si si riduce a una macchina

172
00:07:56,680 --> 00:07:58,840
mononastro. Perché facciamo questa

173
00:07:58,840 --> 00:08:00,720
suddivisione?

174
00:08:00,720 --> 00:08:04,879
Perché il vincolo dello spazio usato lo

175
00:08:04,879 --> 00:08:06,840
metteremo solamente sul nastro di

176
00:08:06,840 --> 00:08:09,479
lavoro. Ok? Ecco perché ci inventiamo

177
00:08:09,479 --> 00:08:12,800
questa questa definizione

178
00:08:12,800 --> 00:08:14,759
in maniera tale che il bound dello

179
00:08:14,759 --> 00:08:19,120
spazio sia solo sul workape. Ok? Perché?

180
00:08:19,120 --> 00:08:22,440
Perché andremo a vedere oggi tra un po'

181
00:08:22,440 --> 00:08:25,759
una classe in cui una classe di

182
00:08:25,759 --> 00:08:27,639
complessità in cui imporremo un

183
00:08:27,639 --> 00:08:30,280
ridottissimo spazio. Gli algoritmi per

184
00:08:30,280 --> 00:08:31,960
esempio che funzionano in spazio

185
00:08:31,960 --> 00:08:34,000
logaritmico.

186
00:08:34,000 --> 00:08:36,240
Però se noi andassimo a contare lo

187
00:08:36,240 --> 00:08:38,399
spazio anche sul nastro di input e

188
00:08:38,399 --> 00:08:40,560
l'input ce lo dobbiamo leggere tutto,

189
00:08:40,560 --> 00:08:42,839
noi occuperemmo sempre spazio lineare

190
00:08:42,839 --> 00:08:44,720
perché lo dobbiamo leggere tutto.

191
00:08:44,720 --> 00:08:47,360
Allora, per poter

192
00:08:47,360 --> 00:08:50,320
categorizzare questa classe piccolissima

193
00:08:50,320 --> 00:08:52,360
che vedremo che è la classe dei problemi

194
00:08:52,360 --> 00:08:54,560
in spazio logaritmico, allora ci serve

195
00:08:54,560 --> 00:08:56,839
il nostro aggiuntivo in maniera tale che

196
00:08:56,839 --> 00:08:59,120
il bound logaritmico viene dato sul

197
00:08:59,120 --> 00:09:01,760
foglio di brutta. Ok? Puoi scrivere il

198
00:09:01,760 --> 00:09:04,000
tema, ma sul foglio di brutta devi usare

199
00:09:04,000 --> 00:09:06,240
poco spazio. Ok? Questa questa è la

200
00:09:06,240 --> 00:09:08,079
cosa.

201
00:09:08,079 --> 00:09:09,720
Allora,

202
00:09:09,720 --> 00:09:14,560
definite queste macchine in questo modo,

203
00:09:15,120 --> 00:09:17,519
introduciamo i concetti di computation

204
00:09:17,519 --> 00:09:21,279
space, running space e via dicendo che

205
00:09:21,279 --> 00:09:24,399
abbiamo fatto l'altra volta, ormai un

206
00:09:24,399 --> 00:09:28,200
po' di settimane fa, per il tempo. Ok.

207
00:09:28,200 --> 00:09:29,839
Definizione

208
00:09:29,839 --> 00:09:31,399
computation

209
00:09:31,399 --> 00:09:35,880
comp. Poi vedete un attimo

210
00:09:35,880 --> 00:09:37,720
così vedo anch'io che vedete qua si è

211
00:09:37,720 --> 00:09:40,560
spento. Vabboh.

212
00:09:40,560 --> 00:09:43,000
computation

213
00:09:43,000 --> 00:09:46,000
space

214
00:09:46,360 --> 00:09:48,160
della

215
00:09:48,160 --> 00:09:51,160
macchina

216
00:09:51,560 --> 00:09:55,279
M su input

217
00:09:55,279 --> 00:09:59,040
input W

218
00:09:59,040 --> 00:10:01,120
è

219
00:10:01,120 --> 00:10:04,680
il numero

220
00:10:04,680 --> 00:10:08,240
di celle

221
00:10:08,240 --> 00:10:11,240
distinte.

222
00:10:13,040 --> 00:10:20,519
viste da M sul work tape,

223
00:10:21,959 --> 00:10:24,440
mentre

224
00:10:24,440 --> 00:10:27,440
processa

225
00:10:28,680 --> 00:10:31,519
W. Ok?

226
00:10:31,519 --> 00:10:34,920
Quindi il computation space

227
00:10:34,920 --> 00:10:37,120
che è una cosa diversa dal running space

228
00:10:37,120 --> 00:10:39,839
come il computation time è diverso dal

229
00:10:39,839 --> 00:10:42,680
running time, quindi computation space,

230
00:10:42,680 --> 00:10:45,360
come mi ricordo questi nomi? Computation

231
00:10:45,360 --> 00:10:47,600
space. Siccome c'è computation fa

232
00:10:47,600 --> 00:10:49,000
riferimento a una computazione

233
00:10:49,000 --> 00:10:52,079
specifica, running space fa riferimento

234
00:10:52,079 --> 00:10:54,959
alla funzione di bound. Ok? Quindi cos'è

235
00:10:54,959 --> 00:10:58,200
il lo spazio di di computazione della

236
00:10:58,200 --> 00:11:02,160
macchina M sulla stringa W?

237
00:11:02,160 --> 00:11:04,600
È definito in maniera molto semplice.

238
00:11:04,600 --> 00:11:07,240
Lanciamo la macchina M su W. Questa

239
00:11:07,240 --> 00:11:11,160
macchina sposterà la testina sul nastro

240
00:11:11,160 --> 00:11:15,160
di eh di lavoro. Il numero di celle

241
00:11:15,160 --> 00:11:17,800
viste, nemmeno scritte, basta che la

242
00:11:17,800 --> 00:11:22,079
testina ci arriva là. eh il numero di

243
00:11:22,079 --> 00:11:25,160
celle viste su workta

244
00:11:25,160 --> 00:11:27,000
dalla

245
00:11:27,000 --> 00:11:31,519
macchina durante il processamento di W e

246
00:11:31,519 --> 00:11:35,880
il suo computation space dm su W. Ok?

247
00:11:35,880 --> 00:11:37,639
Molto semplice la definizione. Questa

248
00:11:37,639 --> 00:11:40,959
definizione però assume che la macchina

249
00:11:40,959 --> 00:11:45,760
M sia deterministica. Lo vedete da come

250
00:11:45,760 --> 00:11:48,040
è stata scritta la definizione. Ok? ci

251
00:11:48,040 --> 00:11:49,959
dobbiamo inventare una cosa per le

252
00:11:49,959 --> 00:11:52,120
macchine non deterministiche. Secondo

253
00:11:52,120 --> 00:11:55,680
voi così buttiamola là. Come potremmo

254
00:11:55,680 --> 00:11:58,079
definire il computation space di una

255
00:11:58,079 --> 00:12:01,720
macchina M non deterministica

256
00:12:01,720 --> 00:12:06,440
su una particolare stringa W?

257
00:12:06,440 --> 00:12:08,079
Dobbiamo generalizzare questa idea.

258
00:12:08,079 --> 00:12:13,880
Prego.
Eh, il massimo computation space.

259
00:12:13,880 --> 00:12:14,959
[Musica]

260
00:12:14,959 --> 00:12:20,680
Esattamente. Se M è non deterministica,

261
00:12:20,680 --> 00:12:23,720
definiamo il computation space come il

262
00:12:23,720 --> 00:12:27,680
massimo numero di celle visitate

263
00:12:27,680 --> 00:12:31,040
dalla macchina su workta in qualsiasi

264
00:12:31,040 --> 00:12:33,160
dei suoi branch di computazione. Ok?

265
00:12:33,160 --> 00:12:35,000
Perché vi ricordo che una macchina non

266
00:12:35,000 --> 00:12:37,480
deterministica ha vari branch di

267
00:12:37,480 --> 00:12:39,440
computazione,

268
00:12:39,440 --> 00:12:42,000
il suo computation space è il peggio che

269
00:12:42,000 --> 00:12:44,399
fa, cioè quant'è lo spazio massimo che

270
00:12:44,399 --> 00:12:47,160
la macchina usa in qualsiasi dei suoi

271
00:12:47,160 --> 00:12:50,680
rami di computazione. Quello è in caso

272
00:12:50,680 --> 00:12:54,160
di macchina M non deterministica, quindi

273
00:12:54,160 --> 00:12:57,160
lo mettiamo fra parentesi, se non

274
00:12:57,160 --> 00:13:00,160
deterministica

275
00:13:02,800 --> 00:13:06,040
si prende

276
00:13:07,000 --> 00:13:12,279
il massimo. Ok.

277
00:13:12,360 --> 00:13:16,360
Alright. Altra definizione.

278
00:13:17,399 --> 00:13:21,040
Una funzione

279
00:13:21,279 --> 00:13:23,760
S che mappa

280
00:13:23,760 --> 00:13:27,000
interi su interi

281
00:13:27,000 --> 00:13:29,680
è una

282
00:13:29,680 --> 00:13:33,160
space function.

283
00:13:36,880 --> 00:13:43,680
Se S è strettamente positiva

284
00:13:49,079 --> 00:13:53,360
è non decreasing.

285
00:13:56,360 --> 00:13:58,839
Ok? Quindi abbiamo definito computation

286
00:13:58,839 --> 00:14:01,519
space per U della computazione di una

287
00:14:01,519 --> 00:14:03,360
macchina su una particolare string. Poi

288
00:14:03,360 --> 00:14:06,600
abbiamo dato questo nome alle funzioni

289
00:14:06,600 --> 00:14:08,759
intero verso interi. Noi diciamo che una

290
00:14:08,759 --> 00:14:11,880
funzione S che mappa interi su interi è

291
00:14:11,880 --> 00:14:15,079
una space function. Se S è strettamente

292
00:14:15,079 --> 00:14:17,880
positiva è

293
00:14:17,880 --> 00:14:20,040
ed è non decreasing è semplicemente un

294
00:14:20,040 --> 00:14:21,759
nome. Vi faccio notare che la stessa

295
00:14:21,759 --> 00:14:23,639
definizione era stata data per time

296
00:14:23,639 --> 00:14:25,480
function, ok? Cioè, stiamo dando due

297
00:14:25,480 --> 00:14:27,480
nomi alla stessa cosa, eh, giusto per

298
00:14:27,480 --> 00:14:30,399
trovarci un po' con le cose. Ok,

299
00:14:30,399 --> 00:14:32,839
definizione di running space, quindi

300
00:14:32,839 --> 00:14:34,759
questa è una space function. Running

301
00:14:34,759 --> 00:14:37,759
space

302
00:14:37,800 --> 00:14:39,440
running

303
00:14:39,440 --> 00:14:42,160
space

304
00:14:42,160 --> 00:14:46,360
della macchina

305
00:14:46,440 --> 00:14:48,079
M.

306
00:14:48,079 --> 00:14:51,399
Ok, questa è una

307
00:14:51,399 --> 00:14:53,720
un adattamento della definizione del

308
00:14:53,720 --> 00:14:58,040
running time di una macchina di Turing.

309
00:14:58,040 --> 00:15:01,800
Come lo possiamo definire?

310
00:15:06,800 --> 00:15:08,680
Sì, prego.

311
00:15:08,680 --> 00:15:12,759
Se è una funzione, è una function, se

312
00:15:12,759 --> 00:15:16,440
per tutte le stringhe W parte qualcuno

313
00:15:16,440 --> 00:15:19,600
il loro computation

314
00:15:19,600 --> 00:15:22,440
space non eccede.

315
00:15:22,440 --> 00:15:24,079
Esattamente. E quella è proprio la

316
00:15:24,079 --> 00:15:26,040
generalizzazione di running space.

317
00:15:26,040 --> 00:15:34,680
Allora, sia sn una space function,

318
00:15:38,560 --> 00:15:44,000
il eh il running

319
00:15:44,000 --> 00:15:46,639
space

320
00:15:46,639 --> 00:15:51,480
di M è SDN

321
00:15:51,480 --> 00:15:54,480
Se

322
00:15:55,959 --> 00:15:59,199
per ogni

323
00:16:00,639 --> 00:16:03,639
stringa

324
00:16:04,000 --> 00:16:05,839
w

325
00:16:05,839 --> 00:16:08,040
a parte

326
00:16:08,040 --> 00:16:11,720
un numero

327
00:16:11,920 --> 00:16:16,399
finito di s

328
00:16:20,240 --> 00:16:25,360
che il computation

329
00:16:26,120 --> 00:16:29,120
space

330
00:16:29,319 --> 00:16:37,279
di M su w è bounded

331
00:16:37,720 --> 00:16:40,720
da S

332
00:16:40,720 --> 00:16:43,240
applicato sulla lunghezza di W. Ok?

333
00:16:43,240 --> 00:16:46,120
Quindi è semplicemente un'estensione

334
00:16:46,120 --> 00:16:49,600
del concetto di computation time, time

335
00:16:49,600 --> 00:16:52,399
function, running time e speculare.

336
00:16:52,399 --> 00:16:54,759
Semplicemente ci spostiamo sulla

337
00:16:54,759 --> 00:16:58,880
definizione di spazio, ok? Quindi avremo

338
00:16:58,880 --> 00:17:02,880
eh computation space, space functions,

339
00:17:02,880 --> 00:17:05,360
running space, ok?

340
00:17:05,360 --> 00:17:07,799
Esattamente come avevamo fatto per il

341
00:17:07,799 --> 00:17:10,839
tempo che avevamo definito le classi

342
00:17:10,839 --> 00:17:14,640
temporali, ok? Possiamo definire le

343
00:17:14,640 --> 00:17:16,880
classi spaziali, le classi di

344
00:17:16,880 --> 00:17:20,160
complessità spaziali. Sì, prego.
Una

345
00:17:20,160 --> 00:17:23,720
domanda. Decidendoation space abbiamo

346
00:17:23,720 --> 00:17:26,199
come numero di celle dist.

347
00:17:26,199 --> 00:17:28,760
Ma viste mi sembiamo le scritte o anche?

348
00:17:28,760 --> 00:17:30,360
No, no, basta che ci ha spostato la

349
00:17:30,360 --> 00:17:32,080
testina, perché la macchina potrebbe

350
00:17:32,080 --> 00:17:34,240
fare questo giochino.

351
00:17:34,240 --> 00:17:37,320
Sposto e torno indietro per contare.

352
00:17:37,320 --> 00:17:39,840
Sposto, magari metto un marcatore su una

353
00:17:39,840 --> 00:17:43,559
cella, sposto la testina per contare,

354
00:17:43,559 --> 00:17:45,360
ok?

355
00:17:45,360 --> 00:17:47,440
Non scrivo niente, quindi non uso

356
00:17:47,440 --> 00:17:49,320
spazio, poi torno indietro fino a

357
00:17:49,320 --> 00:17:51,240
trovare il marcatore. Eh, ok, in quel

358
00:17:51,240 --> 00:17:53,640
modo ho imbrogliato, quindi basta che c

359
00:17:53,640 --> 00:17:57,919
ci abbiamo spostato la testina. Ok.

360
00:17:57,919 --> 00:17:59,960
Alright. Quindi, esattamente come

361
00:17:59,960 --> 00:18:04,400
avevamo definito d time ed n time,

362
00:18:04,400 --> 00:18:06,919
possiamo definire

363
00:18:06,919 --> 00:18:10,600
D space ed n space. Ok, c'abbiamo

364
00:18:10,600 --> 00:18:15,520
spazio. C'abbiamo spazio. Ok.

365
00:18:16,720 --> 00:18:19,480
Secondo voi

366
00:18:19,480 --> 00:18:21,480
Dpace

367
00:18:21,480 --> 00:18:24,120
di SN

368
00:18:24,120 --> 00:18:26,960
sia SN

369
00:18:26,960 --> 00:18:29,679
una space function,

370
00:18:29,679 --> 00:18:34,480
che cosa sarà mai di space?

371
00:18:34,480 --> 00:18:36,840
L'insieme di cosa?

372
00:18:36,840 --> 00:18:40,480
Ve lo ricordate cos'era? D time,

373
00:18:40,480 --> 00:18:43,200
te lo dico io e poi generalizziamo. D

374
00:18:43,200 --> 00:18:46,960
time per una certa funzione tdn

375
00:18:46,960 --> 00:18:50,360
è l'insieme dei linguaggi

376
00:18:50,360 --> 00:18:53,679
riconosciuti da macchine di touring

377
00:18:53,679 --> 00:18:58,559
deterministiche in tempo big o di TDN.

378
00:18:58,559 --> 00:19:02,240
Ok. Cosa potrà mai essere di Space?

379
00:19:02,240 --> 00:19:04,000
insieme dei linguaggi riconosciuti da

380
00:19:04,000 --> 00:19:06,520
una macchina diingerministica

381
00:19:06,520 --> 00:19:09,919
con Running Space. Esattamente l'insieme

382
00:19:09,919 --> 00:19:11,919
dei linguaggi tale per cui esiste una

383
00:19:11,919 --> 00:19:16,280
macchina di Touring deterministica,

384
00:19:19,120 --> 00:19:25,480
tale che il linguaggio di M e L è il

385
00:19:25,480 --> 00:19:28,480
running

386
00:19:28,880 --> 00:19:31,880
space

387
00:19:31,960 --> 00:19:37,320
m e big o ds S di N.

388
00:19:37,320 --> 00:19:41,440
Ok. Definizione abbastanza semplice.

389
00:19:41,440 --> 00:19:44,799
S. Cos'è?
N. N.
Sì, è il mio modo

390
00:19:44,799 --> 00:19:48,799
strambo di scrivere N.

391
00:19:51,280 --> 00:19:53,360
C'ho una M e una N stranissimo. Vi ho

392
00:19:53,360 --> 00:19:57,559
mai fatto vedere come scrivo minimum.

393
00:20:01,200 --> 00:20:06,559
Eh, grandioso, eh. Ok,

394
00:20:07,039 --> 00:20:10,039
ok.

395
00:20:10,280 --> 00:20:14,480
Alri, next one.

396
00:20:15,760 --> 00:20:18,320
Ah,

397
00:20:18,320 --> 00:20:20,960
n space.

398
00:20:20,960 --> 00:20:23,840
N space di s,

399
00:20:23,840 --> 00:20:28,679
ok? Dove s n space function. Cosa mai

400
00:20:28,679 --> 00:20:32,880
conterrà n space?

401
00:20:35,559 --> 00:20:38,240
uguale macchine
non determinisch

402
00:20:38,240 --> 00:20:40,000
attentamente l'insieme dei linguaggi

403
00:20:40,000 --> 00:20:43,120
tale per cui esiste

404
00:20:43,120 --> 00:20:49,000
una macchina n non deterministica

405
00:20:49,840 --> 00:20:55,480
tale che il linguaggio di N e L

406
00:20:55,480 --> 00:20:59,520
è il running

407
00:21:00,240 --> 00:21:02,440
Space

408
00:21:02,440 --> 00:21:08,679
D n e big o di s n.

409
00:21:08,679 --> 00:21:10,360
Ok,

410
00:21:10,360 --> 00:21:13,000
quindi definita la complessità spaziale

411
00:21:13,000 --> 00:21:15,400
delle macchine, abbiamo definito la

412
00:21:15,400 --> 00:21:17,039
complessità

413
00:21:17,039 --> 00:21:19,400
le classi di complessità spaziali.

414
00:21:19,400 --> 00:21:20,840
Classi di complessità spaziale,

415
00:21:20,840 --> 00:21:22,080
esattamente come le classi di

416
00:21:22,080 --> 00:21:24,440
complessità temporale, sono insieme di

417
00:21:24,440 --> 00:21:26,679
linguaggi. Insieme di linguaggi

418
00:21:26,679 --> 00:21:28,799
caratterizzati dal fatto che possono

419
00:21:28,799 --> 00:21:33,200
essere decisi da macchine di touring

420
00:21:33,200 --> 00:21:36,440
all'interno di un certo un certo

421
00:21:36,440 --> 00:21:39,080
quantitativo di risorse computazionali.

422
00:21:39,080 --> 00:21:42,080
Nel caso delle classi temporali, la

423
00:21:42,080 --> 00:21:44,720
risorsa computazionale è il tempo. Nel

424
00:21:44,720 --> 00:21:48,799
caso della classi spaziali, la risorsa

425
00:21:48,799 --> 00:21:52,840
computazionale è la memoria. Ok?

426
00:21:52,840 --> 00:21:55,159
Ci concentreremo in questa lezione su

427
00:21:55,159 --> 00:21:58,400
due classi, due classi spaziali, domani

428
00:21:58,400 --> 00:22:00,279
ne vedremo un altro po', più un

429
00:22:00,279 --> 00:22:02,720
risultato interessante

430
00:22:02,720 --> 00:22:05,919
che le rende particolarmente differenti

431
00:22:05,919 --> 00:22:09,600
dalle classi temporali. Allora, la prima

432
00:22:09,600 --> 00:22:15,960
classe che definiamo è L,

433
00:22:16,159 --> 00:22:21,120
a volte denotata come log space

434
00:22:28,440 --> 00:22:30,919
e poi definiremo

435
00:22:30,919 --> 00:22:33,200
NL

436
00:22:33,200 --> 00:22:36,760
che è deterministic

437
00:22:36,760 --> 00:22:40,120
log space.

438
00:22:43,039 --> 00:22:46,640
Ok. Allora,

439
00:22:46,640 --> 00:22:52,679
secondo voi L come la possiamo definire?

440
00:22:56,120 --> 00:22:58,480
Usando D space ed n space. Quindi,

441
00:22:58,480 --> 00:23:00,720
innanzitutto, L è deterministica o non

442
00:23:00,720 --> 00:23:02,360
deterministica?

443
00:23:02,360 --> 00:23:04,240
Deterministica.
Deterministica. Quindi

444
00:23:04,240 --> 00:23:07,360
facciamo di space. di space di quale

445
00:23:07,360 --> 00:23:10,120
funzione?
Logaritmo in base 2 di n

446
00:23:10,120 --> 00:23:14,520
logaritmo in base 2 di n. Ok?

447
00:23:14,520 --> 00:23:18,039
E invece nl

448
00:23:18,919 --> 00:23:23,320
n space di logaritmo in base 2
n space

449
00:23:23,320 --> 00:23:26,640
di logaritmo in base 2 di n. Ok?

450
00:23:26,640 --> 00:23:28,799
Utilizziamo il logaritmo in base 2, ma

451
00:23:28,799 --> 00:23:32,159
questo non non è una limitazione perché

452
00:23:32,159 --> 00:23:33,919
se dovessimo usare un logaritmo in

453
00:23:33,919 --> 00:23:36,799
un'altra base, fare il cambio di base di

454
00:23:36,799 --> 00:23:38,960
logaritmo è una costante, quindi non ci

455
00:23:38,960 --> 00:23:41,799
cambia niente. A livello asintotico è la

456
00:23:41,799 --> 00:23:44,159
stessa cosa. Quindi da adesso in poi

457
00:23:44,159 --> 00:23:46,279
quando scrivo logaritmo io intendo

458
00:23:46,279 --> 00:23:51,520
logaritmo in base 2. Ok?

459
00:23:51,520 --> 00:23:56,080
Secondo voi, qual è la relazione di

460
00:23:56,080 --> 00:24:00,880
contenimento fra queste due classi?

461
00:24:00,880 --> 00:24:05,679
L contenuto in NL.
L è contenuto in ln

462
00:24:05,679 --> 00:24:09,679
NL. Sì, L è contenuto in NL. Ok. E poi

463
00:24:09,679 --> 00:24:11,760
relazioni con le altre classi le vediamo

464
00:24:11,760 --> 00:24:13,320
domani.

465
00:24:13,320 --> 00:24:17,760
Oggi ci focalizziamo su questo

466
00:24:17,760 --> 00:24:20,120
problema, su queste due classi. Ok?

467
00:24:20,120 --> 00:24:22,279
Allora, quello che noi ci poniamo come

468
00:24:22,279 --> 00:24:25,240
obiettivo ora è andare a guardare un po'

469
00:24:25,240 --> 00:24:28,000
di problemi che stanno in queste classi,

470
00:24:28,000 --> 00:24:30,679
ok? cercare di capire se siano distinti

471
00:24:30,679 --> 00:24:33,039
o meno, cosa la gente si è inventata per

472
00:24:33,039 --> 00:24:35,760
stabilire se fossero distinti o meno. Ve

473
00:24:35,760 --> 00:24:37,960
lo anticipo, tanto per cambiare. Noi

474
00:24:37,960 --> 00:24:40,679
sappiamo che L sta dentro NL, ma non

475
00:24:40,679 --> 00:24:42,880
sappiamo se le due classi sono distinte,

476
00:24:42,880 --> 00:24:45,720
ok? È la solita storia di tante classi

477
00:24:45,720 --> 00:24:47,480
di complessità.

478
00:24:47,480 --> 00:24:51,320
Ok? Secondo voi?

479
00:24:54,360 --> 00:24:56,880
Ok? No, ve lo dico io. All'inizio del

480
00:24:56,880 --> 00:24:59,039
corso, mentre guardavamo macchine di

481
00:24:59,039 --> 00:25:01,559
Touring eccetera,

482
00:25:01,559 --> 00:25:03,440
abbiamo a un certo punto giocato con

483
00:25:03,440 --> 00:25:07,799
questo linguaggio. Ok, qua uso

484
00:25:07,799 --> 00:25:11,559
qua indico linguaggio. Ok. Alrght.

485
00:25:11,559 --> 00:25:14,600
Allora, cercherò di questo linguaggio
L

486
00:25:14,600 --> 00:25:16,279
questo qua abbiamo questo linguaggio

487
00:25:16,279 --> 00:25:21,480
qui. Eh, possiamo scrivere con L.
Eh,

488
00:25:21,480 --> 00:25:23,720
eh sì, alcune persone usano questo,

489
00:25:23,720 --> 00:25:26,960
guarda, log space. Non non voglio scu,

490
00:25:26,960 --> 00:25:32,000
scrivo log, ok?
Log, però generalmente

491
00:25:32,000 --> 00:25:35,480
sui testi troverete l oppure log space.

492
00:25:35,480 --> 00:25:36,919
Ok?

493
00:25:36,919 --> 00:25:41,880
Allora, abbiamo questo linguaggio 0n 1 n

494
00:25:41,880 --> 00:25:44,399
con n strettamente maggiore di 0. Ok?

495
00:25:44,399 --> 00:25:46,279
Avevamo visto questo linguaggio. Vi

496
00:25:46,279 --> 00:25:48,559
ricordate come l'avevamo

497
00:25:48,559 --> 00:25:52,000
come l'avevamo riconosciuto?

498
00:25:52,000 --> 00:25:53,399
Noi vogliamo ci chiediamo se questo

499
00:25:53,399 --> 00:25:55,799
linguaggio sta in lovead space o meno.

500
00:25:55,799 --> 00:25:59,039
Ok? Questo è il nostro quesito di ora.

501
00:25:59,039 --> 00:26:00,919
Vi ricordate la macchina che avevamo

502
00:26:00,919 --> 00:26:02,600
usato?

503
00:26:02,600 --> 00:26:06,460
Come riconosceva questo linguaggio?

504
00:26:06,460 --> 00:26:07,760
[Musica]

505
00:26:07,760 --> 00:26:10,640
Com'è?

506
00:26:10,640 --> 00:26:12,559
No, era molto più semplice di quella.

507
00:26:12,559 --> 00:26:14,039
Era una macchina deterministica.

508
00:26:14,039 --> 00:26:16,360
Facevamo un giochino. La prima la prima

509
00:26:16,360 --> 00:26:18,360
versione semplicemente leggeva il primo

510
00:26:18,360 --> 00:26:21,840
carattere lo cancellava, poi a destra.

511
00:26:21,840 --> 00:26:23,679
Sì, sì, esattamente. Facevamo questo

512
00:26:23,679 --> 00:26:27,120
gioco, prendevamo con la testina,

513
00:26:27,120 --> 00:26:29,720
andavamo sullo zero, lo marcavamo o lo

514
00:26:29,720 --> 00:26:31,840
cancellavamo, andavamo in fondo,

515
00:26:31,840 --> 00:26:34,000
eccetera, tornavamo indietro. Pam pam

516
00:26:34,000 --> 00:26:35,600
pam.

517
00:26:35,600 --> 00:26:38,279
Ok. Assumiamo di fare questo genere di

518
00:26:38,279 --> 00:26:41,399
lavoro sulla macchina che abbiamo

519
00:26:41,399 --> 00:26:43,440
definito oggi, quella con work tape.

520
00:26:43,440 --> 00:26:45,120
Quello che dovremmo fare sostanzialmente

521
00:26:45,120 --> 00:26:50,279
sarebbe prendere l'input, ricopiarlo su

522
00:26:50,279 --> 00:26:52,360
Wordtech e iniziare a fare il gioco. Ok?

523
00:26:52,360 --> 00:26:54,320
Perché noi questo gioco sul nassero di

524
00:26:54,320 --> 00:26:56,679
input non lo possiamo fare. Ok? Quanto

525
00:26:56,679 --> 00:26:58,440
spazio occupiamo a fare questo

526
00:26:58,440 --> 00:27:01,440
lavoretto?

527
00:27:02,440 --> 00:27:06,320
lineare. Ok? Quindi questa macchina usa

528
00:27:06,320 --> 00:27:09,440
tanto spazio, non ci mostra che questo

529
00:27:09,440 --> 00:27:12,200
linguaggio è in log space. Ok? Secondo

530
00:27:12,200 --> 00:27:17,200
voi che ci possiamo inventare per

531
00:27:17,200 --> 00:27:19,760
riconoscere decidere questo linguaggio

532
00:27:19,760 --> 00:27:23,640
in spazio logaritmico?

533
00:27:26,960 --> 00:27:30,039
Un attimo.

534
00:27:34,120 --> 00:27:36,760
Chiaro l'obiettivo? Noi su nastro di

535
00:27:36,760 --> 00:27:39,559
lavoro vogliamo usare solo spazio

536
00:27:39,559 --> 00:27:42,840
logaritmico invece che spazio lineare.

537
00:27:42,840 --> 00:27:46,279
Come si fa?

538
00:27:46,679 --> 00:27:50,399
Pensateci un attimino.

539
00:27:59,039 --> 00:28:03,559
Ok. Qualche voce nuova,

540
00:28:04,600 --> 00:28:06,559
senò c'ho già la coda in testa delle

541
00:28:06,559 --> 00:28:10,320
persone. Prenotate.

542
00:28:12,679 --> 00:28:15,039
Ok, prego.
Ci scriviamo in qualche modo

543
00:28:15,039 --> 00:28:17,200
la quantità che a livello dizione

544
00:28:17,200 --> 00:28:19,360
èamente

545
00:28:19,360 --> 00:28:22,039
Esattamente. Noi su un nastro di lavoro

546
00:28:22,039 --> 00:28:24,640
contiamo, cioè noi ci scriviamo in

547
00:28:24,640 --> 00:28:28,399
binario quant'è questo n e questo n

548
00:28:28,399 --> 00:28:31,159
quanto spazio occupa?

549
00:28:31,159 --> 00:28:34,039
Logaritmico. Ok? Quindi la macchina

550
00:28:34,039 --> 00:28:37,960
funziona così. Partiamo dagli zeri e

551
00:28:37,960 --> 00:28:40,200
iniziamo a scrivere sul nastro questo

552
00:28:40,200 --> 00:28:44,120
conteggio + 1 + 1 + 1 + 1 fin quando

553
00:28:44,120 --> 00:28:46,600
arriviamo all'uno. Sul nastro avremo una

554
00:28:46,600 --> 00:28:49,960
rappresentazione binaria di n

555
00:28:49,960 --> 00:28:53,720
la cui taglia è logaritmica nella

556
00:28:53,720 --> 00:28:55,880
quantità di zeri che apparivano sul

557
00:28:55,880 --> 00:28:58,240
nastro in input.

558
00:28:58,240 --> 00:29:00,480
Sì, prego.
Per aumentare il conto non

559
00:29:00,480 --> 00:29:02,279
bisogna andare a destra a sinistra con

560
00:29:02,279 --> 00:29:06,320
la testina su work tape puoi fare quello

561
00:29:06,320 --> 00:29:09,720
che vuoi, invece, ma puoi andare avanti

562
00:29:09,720 --> 00:29:11,480
e indietro pure pure su input,

563
00:29:11,480 --> 00:29:13,200
l'importante è che non ci scrivi. Ok?

564
00:29:13,200 --> 00:29:14,919
Quindi andiamo avanti e li contiamo e

565
00:29:14,919 --> 00:29:16,760
sommiamo uno e sommiamo uno e sommiamo

566
00:29:16,760 --> 00:29:18,919
uno.

567
00:29:18,919 --> 00:29:20,399
Prende un po' di tempo perché dobbiamo

568
00:29:20,399 --> 00:29:23,200
fare queste somme binarie. Ok? Comunque

569
00:29:23,200 --> 00:29:25,240
mi pare che la complessità ammortizzata

570
00:29:25,240 --> 00:29:27,720
di contare è lineare. Non perdiamo così

571
00:29:27,720 --> 00:29:31,000
tanto tempo. Scriviamo questa cosa su

572
00:29:31,000 --> 00:29:34,559
worktape. Lasciamo uno spazietto.

573
00:29:34,559 --> 00:29:37,360
Rifacciamo la stessa cosa con gli uni,

574
00:29:37,360 --> 00:29:39,880
risommiamo tutto. Quando abbiamo finito

575
00:29:39,880 --> 00:29:42,159
di fare i due conteggi, controlliamo le

576
00:29:42,159 --> 00:29:44,039
due stringhe.

577
00:29:44,039 --> 00:29:46,399
Se sono uguali rispondiamo di sì. Se

578
00:29:46,399 --> 00:29:48,960
sono diverse rispondiamo di no. Quanto

579
00:29:48,960 --> 00:29:52,320
spazio abbiamo occupato? logaritmico.

580
00:29:52,320 --> 00:29:56,279
Ok? Quindi questo problema appartiene a

581
00:29:56,279 --> 00:30:02,080
log space. Appartiene a log space.

582
00:30:02,480 --> 00:30:05,679
Quello che vogliamo vedere adesso invece

583
00:30:05,679 --> 00:30:09,440
è un interessante problema. Questo C

584
00:30:09,440 --> 00:30:12,679
spazio. Ce ne abbiamo a non finire. Un

585
00:30:12,679 --> 00:30:15,120
interessante problema che appartiene al

586
00:30:15,120 --> 00:30:16,919
nondeterministicace.

587
00:30:16,919 --> 00:30:20,360
Ok? È un problema che so per certo che

588
00:30:20,360 --> 00:30:23,279
conosciate,

589
00:30:23,279 --> 00:30:26,399
non sapete che è un problema di NL.

590
00:30:26,399 --> 00:30:28,440
Quello è un problema famosissimo perché

591
00:30:28,440 --> 00:30:30,840
l'avrete visto miliardi di volte in

592
00:30:30,840 --> 00:30:33,679
10.000 Zs

593
00:30:33,679 --> 00:30:35,200
e

594
00:30:35,200 --> 00:30:38,159
però il nostro obiettivo sarà

595
00:30:38,159 --> 00:30:40,039
mh

596
00:30:40,039 --> 00:30:43,000
eh no,

597
00:30:43,000 --> 00:30:45,039
sarà

598
00:30:45,039 --> 00:30:47,360
definire un algoritmo non deterministic

599
00:30:47,360 --> 00:30:49,120
long space perché di sicuro lo

600
00:30:49,120 --> 00:30:52,760
conoscete, però avrete visto

601
00:30:52,760 --> 00:30:55,240
ad altissima probabilità algoritmi

602
00:30:55,240 --> 00:30:57,200
polinomiali deterministici. Invece

603
00:30:57,200 --> 00:30:59,960
quello che noi vorremo vedere oggi è un

604
00:30:59,960 --> 00:31:02,799
non deterministic lo space, cioè che nel

605
00:31:02,799 --> 00:31:04,840
momento in cui abbiamo una macchina di

606
00:31:04,840 --> 00:31:06,880
non deterministica possiamo risparmiare

607
00:31:06,880 --> 00:31:09,559
un sacco di spazio. Ok?

608
00:31:09,559 --> 00:31:13,240
Questo problema è l'astrusissimo

609
00:31:13,240 --> 00:31:15,720
problema della raggiungibilità sul

610
00:31:15,720 --> 00:31:17,960
grafo. Ok?

611
00:31:17,960 --> 00:31:19,919
Quindi

612
00:31:19,919 --> 00:31:23,679
com'è questo linguaggio

613
00:31:23,679 --> 00:31:28,480
è il linguaggio delle triple GST

614
00:31:28,480 --> 00:31:32,200
in cui G

615
00:31:33,039 --> 00:31:37,000
è un grafo

616
00:31:37,000 --> 00:31:38,720
diretto.

617
00:31:38,720 --> 00:31:42,080
Importante che sia diretto, eh?

618
00:31:42,080 --> 00:31:43,880
Sono

619
00:31:43,880 --> 00:31:47,480
nodi di V.

620
00:31:47,480 --> 00:31:50,720
ed esiste

621
00:31:51,799 --> 00:31:55,080
in Gh

622
00:31:56,919 --> 00:31:59,039
s

623
00:31:59,039 --> 00:32:03,200
a t. Ok,

624
00:32:06,279 --> 00:32:07,840
semplice il problema, lo conoscete,

625
00:32:07,840 --> 00:32:11,240
abbiamo un grafo diretto.

626
00:32:11,240 --> 00:32:13,880
Due nodi ci vengono dati in input. Non è

627
00:32:13,880 --> 00:32:15,480
un problema di calcolo, è un problema di

628
00:32:15,480 --> 00:32:16,960
decisione. Ci viene semplicemente

629
00:32:16,960 --> 00:32:19,080
chiesto ma è vero o no che in G esiste

630
00:32:19,080 --> 00:32:22,159
un percorso da S a T? Ok? Noi dobbiamo

631
00:32:22,159 --> 00:32:25,960
rispondere sì o no.

632
00:32:25,960 --> 00:32:27,559
Come

633
00:32:27,559 --> 00:32:32,159
lo risolvete in genere questo problema?

634
00:32:32,880 --> 00:32:35,799
BFS o BFS.
Esattamente. Cioè, facciamo

635
00:32:35,799 --> 00:32:38,480
un'esplorazione del grafo. Cosa possiamo

636
00:32:38,480 --> 00:32:41,240
fare? Prendiamo S,

637
00:32:41,240 --> 00:32:42,519
che è il nodo di partenza, è la

638
00:32:42,519 --> 00:32:45,320
sorgente. T è il target. Analizziamo

639
00:32:45,320 --> 00:32:48,720
prima questo algoritmo. Prendiamo S,

640
00:32:48,720 --> 00:32:51,720
vediamo chi sono i successori di S.

641
00:32:51,720 --> 00:32:54,000
Tutti loro li prendiamo e li infiliamo

642
00:32:54,000 --> 00:32:57,600
in un sacco. Ok,

643
00:32:57,600 --> 00:32:59,120
prendiamo,

644
00:32:59,120 --> 00:33:01,080
no, facciamo così, vediamo i successori

645
00:33:01,080 --> 00:33:04,240
di S, se tra loro c'è T, diciamo di sì,

646
00:33:04,240 --> 00:33:05,919
sennò li prendiamo e li mettiamo in un

647
00:33:05,919 --> 00:33:09,159
sacco. Tiriamo fuori dal sacco un uno di

648
00:33:09,159 --> 00:33:11,720
questi vertici, vediamo chi sono i suoi

649
00:33:11,720 --> 00:33:14,360
successori. Supponiamo che il grafo non

650
00:33:14,360 --> 00:33:16,120
sia ciclico, sennò insomma vanno fatti

651
00:33:16,120 --> 00:33:18,600
tutta una serie di controlli. Vediamo se

652
00:33:18,600 --> 00:33:20,919
fra quelli c'è T. Se C è T, diciamo di

653
00:33:20,919 --> 00:33:22,880
sì, senò prendiamo, li ributtiamo nel

654
00:33:22,880 --> 00:33:27,399
sacco e continuiamo così. Ok, procedura

655
00:33:27,399 --> 00:33:32,360
deterministica. Quanto tempo prende?

656
00:33:35,679 --> 00:33:37,440
No, non mi interessa l'esponente

657
00:33:37,440 --> 00:33:38,760
preciso. È polinomiale? Non è

658
00:33:38,760 --> 00:33:40,679
polinomiale?
È polinomiale.
È

659
00:33:40,679 --> 00:33:42,639
polinomiale. Sarà o quadratico o

660
00:33:42,639 --> 00:33:45,679
pubblico, una cosa del genere. Ok.

661
00:33:45,679 --> 00:33:47,840
deterministico polinomiale. Quanto

662
00:33:47,840 --> 00:33:50,880
spazio usiamo?

663
00:33:50,880 --> 00:33:53,559
Polinomiale.
Usiamo spazio polinomiale.

664
00:33:53,559 --> 00:33:55,600
Usiamo linear space più o meno perché

665
00:33:55,600 --> 00:33:57,919
dobbiamo mettere nodi in questo sacco e

666
00:33:57,919 --> 00:34:00,080
a un certo punto male che ci va

667
00:34:00,080 --> 00:34:03,760
potrebbero comparire tutti. Ok? Quindi

668
00:34:03,760 --> 00:34:05,880
lo spazio che usiamo in questo sacco è

669
00:34:05,880 --> 00:34:08,119
bello grosso. Questo algoritmo non ci

670
00:34:08,119 --> 00:34:10,240
mostra l'appartenenza

671
00:34:10,240 --> 00:34:13,679
di reachability a non deterministic

672
00:34:13,679 --> 00:34:16,200
space perché usiamo troppo spazio. ci

673
00:34:16,200 --> 00:34:18,200
dobbiamo inventare

674
00:34:18,200 --> 00:34:19,760
un

675
00:34:19,760 --> 00:34:23,440
algoritmo non deterministico che usi

676
00:34:23,440 --> 00:34:26,520
solamente, e questo è la parte

677
00:34:26,520 --> 00:34:30,639
trucchettosa, che usi solamente spazio

678
00:34:30,639 --> 00:34:32,919
logaritmico.

679
00:34:32,919 --> 00:34:35,720
Prendetevi un paio di minuti per pensare

680
00:34:35,720 --> 00:34:38,960
e poi iniziamo a ragionarci assieme.

681
00:34:38,960 --> 00:34:40,879
Diretto vuol dire orientato.
Orientato.

682
00:34:40,879 --> 00:34:42,839
Sì, sorry

683
00:34:42,839 --> 00:34:46,040
ho tradotto da directo.

684
00:34:46,040 --> 00:34:48,760
Sì, orientato. Dove l'ho messo? Qua.

685
00:34:48,760 --> 00:34:51,560
Cancelliamo.

686
00:34:51,560 --> 00:34:53,679
Orientato.

687
00:34:53,679 --> 00:34:56,679
Orientato.

688
00:34:57,040 --> 00:34:58,720
Sì, alcune parole in italiano non mi

689
00:34:58,720 --> 00:35:02,480
ricordo più come si dicono.

690
00:35:06,680 --> 00:35:10,359
Che si può fare?

691
00:35:16,200 --> 00:35:18,000
Per risparmiare spazio vi do questo

692
00:35:18,000 --> 00:35:20,440
indizio, eh, per risparmiare spazio

693
00:35:20,440 --> 00:35:22,480
dovete sfruttare il non determinismo,

694
00:35:22,480 --> 00:35:26,200
senò non se ne esce.

695
00:35:38,200 --> 00:35:41,359
Un attimo.

696
00:35:47,920 --> 00:35:52,880
Secondo. Siamo a due. 3. Ok.

697
00:36:04,440 --> 00:36:05,960
Siccome preferisco una lezione un po'

698
00:36:05,960 --> 00:36:08,400
più collegiale, chiamerò prima quelli

699
00:36:08,400 --> 00:36:12,839
che non ho sentito prima. Eh, ok.

700
00:36:14,400 --> 00:36:17,400
Era

701
00:36:18,960 --> 00:36:21,319
carino che quando ero a Oxford facevo

702
00:36:21,319 --> 00:36:24,520
lezione a tre studenti ed era quasi una

703
00:36:24,520 --> 00:36:26,920
lezione one to one, quindi si mette il

704
00:36:26,920 --> 00:36:30,359
foglio in mezzo,

705
00:36:33,560 --> 00:36:35,599
però è da lì che mi viene lo stile

706
00:36:35,599 --> 00:36:37,839
interattivo, perché con loro ci

707
00:36:37,839 --> 00:36:41,200
siedevamo e facevamo cose

708
00:36:50,560 --> 00:36:53,079
Alri, prego.

709
00:36:53,079 --> 00:36:55,960
Eh, io mi stavo immaginando di per un

710
00:36:55,960 --> 00:36:58,000
guest se esiste una strada al massimo

711
00:36:58,000 --> 00:37:03,079
lunga K, dove K è un numero di eh nodi.

712
00:37:03,079 --> 00:37:06,800
Mh. Eh, altrimenti

713
00:37:06,800 --> 00:37:09,480
Ma quindi lei deve gessare

714
00:37:09,480 --> 00:37:11,800
K nodi,

715
00:37:11,800 --> 00:37:13,960
lui deve gestare e scrivere sul nastro.

716
00:37:13,960 --> 00:37:17,680
Sì,
è quello che spazio lineare.

717
00:37:17,680 --> 00:37:20,079
Troppo spazio.

718
00:37:20,079 --> 00:37:22,720
Buon tentativo. Guess. Guess di cose.

719
00:37:22,720 --> 00:37:26,160
Prego.
Io farei un gest, però,

720
00:37:26,160 --> 00:37:29,079
cioè, poi faccio il primo nodo, faccio

721
00:37:29,079 --> 00:37:33,240
un guess, appunto, del primo passaggio

722
00:37:33,240 --> 00:37:35,440
ecco

723
00:37:35,440 --> 00:37:37,880
e a questo punto sovrassivo dal nuovo

724
00:37:37,880 --> 00:37:40,040
nodo. In questo modo, cioè parole tipo

725
00:37:40,040 --> 00:37:42,119
ogni singolo passaggio

726
00:37:42,119 --> 00:37:44,520
Sì. Ok.
Intanto possiamo fare un chest

727
00:37:44,520 --> 00:37:45,720
dell'intero percorso. Posso fare un

728
00:37:45,720 --> 00:37:49,960
chest? Il passaggio.
Sì.
E ok. Buono

729
00:37:49,960 --> 00:37:52,000
l'impianto. Ok.

730
00:37:52,000 --> 00:37:53,839
L'idea che ci dava il nostro collega

731
00:37:53,839 --> 00:37:56,480
Gesso, il F è corretta. Il problema è

732
00:37:56,480 --> 00:37:58,240
che dobbiamo risparmiare spazio. Come

733
00:37:58,240 --> 00:38:00,480
risparmiamo in quel modo. Che cosa

734
00:38:00,480 --> 00:38:03,720
facciamo noi? Gessiamo. È strano, eh,

735
00:38:03,720 --> 00:38:05,079
perché adesso dobbiamo aggiungere un po'

736
00:38:05,079 --> 00:38:06,400
di dettagli, poi scriverò uno

737
00:38:06,400 --> 00:38:08,160
pseudocodice, così capiamo come

738
00:38:08,160 --> 00:38:10,000
funziona.

739
00:38:10,000 --> 00:38:11,520
La questione è che noi non possiamo

740
00:38:11,520 --> 00:38:13,599
gessare tutto il patto assieme perché

741
00:38:13,599 --> 00:38:15,520
occupa troppo spazio, quindi ne dobbiamo

742
00:38:15,520 --> 00:38:18,160
gessare dei pezzi.

743
00:38:18,160 --> 00:38:20,800
Che pezzo gessiamo? Noi gessiamo di

744
00:38:20,800 --> 00:38:23,280
volta in volta solo il passo successivo,

745
00:38:23,280 --> 00:38:27,920
quindi sono in s gesso il nodo di dopo.

746
00:38:27,920 --> 00:38:29,839
Ok?

747
00:38:29,839 --> 00:38:32,520
Come faccio a stabilire che non sto

748
00:38:32,520 --> 00:38:36,520
gessando spazzatura? Verifico che il

749
00:38:36,520 --> 00:38:38,319
gess

750
00:38:38,319 --> 00:38:41,079
sia relativo a un arco presente nel

751
00:38:41,079 --> 00:38:44,520
grafo. Ok? Quindi io gesso uno dei

752
00:38:44,520 --> 00:38:46,920
successivi di S. Non è che gess una cosa

753
00:38:46,920 --> 00:38:50,400
a caso. Gess uno dei successivi di ss.

754
00:38:50,400 --> 00:38:53,000
Una volta che ho questo qua e sto usando

755
00:38:53,000 --> 00:38:55,880
al momento poco spazio perché uso

756
00:38:55,880 --> 00:38:58,480
l'identificativo del nodo. Oppure come

757
00:38:58,480 --> 00:39:01,599
potrete leggere sugli appunti di Calutti

758
00:39:01,599 --> 00:39:05,079
posso gessare il pointer alla posizione

759
00:39:05,079 --> 00:39:07,319
nel nastro di input di dove compare il

760
00:39:07,319 --> 00:39:09,800
nome del nodo. Ok? Cioè è una questione

761
00:39:09,800 --> 00:39:12,079
per rappresentare compattamenti. Quindi

762
00:39:12,079 --> 00:39:16,160
se abbiamo, che ne so,

763
00:39:16,160 --> 00:39:19,720
16 nodi, per dire, numerati da 0 a 15, a

764
00:39:19,720 --> 00:39:22,800
me servono 4 bit per dare nome a quei

765
00:39:22,800 --> 00:39:26,720
nodi. Ok? Quindi cosa faccio? sono in s

766
00:39:26,720 --> 00:39:28,960
gesso è il suo successivo. Sto solo

767
00:39:28,960 --> 00:39:32,040
ghessando il nome identificativo di

768
00:39:32,040 --> 00:39:33,800
questo nodo, quindi mi serve spazio

769
00:39:33,800 --> 00:39:36,720
logaritmico per rappresentarlo.

770
00:39:36,720 --> 00:39:40,119
Dopodiché quando devo gessare il passo

771
00:39:40,119 --> 00:39:44,280
successivo, ok? Io prendo, a questo

772
00:39:44,280 --> 00:39:46,440
punto sarà in un S prim', prendo un

773
00:39:46,440 --> 00:39:52,680
successivo di S'ado in S2. Ok?

774
00:39:52,680 --> 00:39:54,680
È chiaro?

775
00:39:54,680 --> 00:39:56,920
E dove lo vado a scrivere? Sullo stesso

776
00:39:56,920 --> 00:40:00,760
spazio, cioè io lo riuso. Io in memoria

777
00:40:00,760 --> 00:40:03,560
mantengo costantemente nodo corrente,

778
00:40:03,560 --> 00:40:05,520
nodo successivo, giusto per fare il

779
00:40:05,520 --> 00:40:08,000
controllo che ci sia un arco. Dopodiché

780
00:40:08,000 --> 00:40:10,560
cambio e vado a riscrivere di volta in

781
00:40:10,560 --> 00:40:12,280
volta. Ok? Dobbiamo sfruttare il fatto

782
00:40:12,280 --> 00:40:13,960
che riusiamo lo spazio. Questa è la

783
00:40:13,960 --> 00:40:16,480
potenza delle classi spaziali. Un

784
00:40:16,480 --> 00:40:20,240
secondo. Allora, che cosa succede? Se

785
00:40:20,240 --> 00:40:21,880
esisterà,

786
00:40:21,880 --> 00:40:28,680
no, un modo di arrivare a destinazione,

787
00:40:28,680 --> 00:40:33,280
la macchina la macchina lo trova. Ok?

788
00:40:33,280 --> 00:40:36,480
Però noi dobbiamo garantirci

789
00:40:36,480 --> 00:40:38,560
che cosa? che questa macchina non

790
00:40:38,560 --> 00:40:42,160
lucchi, perché io sto solo chiestando,

791
00:40:42,160 --> 00:40:44,160
sto solo chiestando il successivo, eh,

792
00:40:44,160 --> 00:40:48,480
io non ho una visione di insieme di dove

793
00:40:48,480 --> 00:40:51,280
mi sto spostando nel grafo, sto

794
00:40:51,280 --> 00:40:53,720
luppando. In genere negli algoritmi che

795
00:40:53,720 --> 00:40:55,560
noi abbiamo visto al corso di algoritmi

796
00:40:55,560 --> 00:40:57,640
e strutture dati, come fate ad evitare i

797
00:40:57,640 --> 00:40:59,880
loop? Vi tenete una struttura dati che

798
00:40:59,880 --> 00:41:01,920
dice io questo nodo l'ho già visto, ma

799
00:41:01,920 --> 00:41:03,800
se noi abbiamo una lista del genere

800
00:41:03,800 --> 00:41:06,000
nella macchina quanto spazio siiamo?

801
00:41:06,000 --> 00:41:08,119
lineare
lineare e quindi è una cosa che

802
00:41:08,119 --> 00:41:09,800
non si può fare, cioè quindi noi

803
00:41:09,800 --> 00:41:13,400
dobbiamo evitare il looping senza tenere

804
00:41:13,400 --> 00:41:17,160
traccia di che cosa abbiamo visto. Ok,

805
00:41:17,160 --> 00:41:20,440
chiaro? Quindi, che cosa abbiamo? Questa

806
00:41:20,440 --> 00:41:22,800
macchina

807
00:41:22,800 --> 00:41:25,880
gessa di volta in volta il next step e

808
00:41:25,880 --> 00:41:29,560
in questo modo ci evitiamo di

809
00:41:29,560 --> 00:41:31,359
di rappresentare tutto il patto in

810
00:41:31,359 --> 00:41:34,560
memoria e risparmiamo spazio. Abbiamo un

811
00:41:34,560 --> 00:41:36,599
problema però che se la se il grafo è

812
00:41:36,599 --> 00:41:38,920
ciclico sta macchina inizia a ciclare

813
00:41:38,920 --> 00:41:41,400
non si finisce più. Ok? Quindi dobbiamo

814
00:41:41,400 --> 00:41:47,119
essere sicuri che noi andiamo a bloccare

815
00:41:47,119 --> 00:41:52,960
i rami di computazione infiniti. Ok?

816
00:41:54,119 --> 00:41:57,920
Non possiamo mantenere la lista delle

817
00:41:57,920 --> 00:42:00,040
cose liste

818
00:42:00,040 --> 00:42:03,760
come si fa generalmente

819
00:42:03,760 --> 00:42:07,200
un attimo. Perché

820
00:42:07,200 --> 00:42:10,359
non possiamo eh non possiamo occupare

821
00:42:10,359 --> 00:42:12,920
tutto quello spazio per memorizzarlo. Ci

822
00:42:12,920 --> 00:42:15,480
serve un'altra cosa. Allora, se mi

823
00:42:15,480 --> 00:42:17,280
ricordo la sequenza c'era prima lei

824
00:42:17,280 --> 00:42:19,880
nulla, poi lei

825
00:42:19,880 --> 00:42:21,599
combinatoria. Ho visto un problema

826
00:42:21,599 --> 00:42:24,520
simile col taglio del grafo.
Mh.
È

827
00:42:24,520 --> 00:42:28,280
simile come problema,
eh che intende per

828
00:42:28,280 --> 00:42:30,160
taglio del grafo. Prendevo la spesa di

829
00:42:30,160 --> 00:42:34,440
limite in area suppeva al grafo. Ci sono

830
00:42:34,440 --> 00:42:36,119
forse si potrebbe fare in quel modo, ma

831
00:42:36,119 --> 00:42:38,760
c'è un modo ancora più semplice. Prego.

832
00:42:38,760 --> 00:42:40,960
E in questo caso mi sa che io mi

833
00:42:40,960 --> 00:42:43,599
concentro solo sullo spazio, posso

834
00:42:43,599 --> 00:42:45,839
contare, cioè io riciclo quest'anno

835
00:42:45,839 --> 00:42:48,240
avanti all'infinito e mi accorgo che non

836
00:42:48,240 --> 00:42:52,119
è corretto se ho ehm visitato tutti i

837
00:42:52,119 --> 00:42:54,000
nodi del grafo, quindi se il mio

838
00:42:54,000 --> 00:42:55,680
conteggio superato.
Esattamente.

839
00:42:55,680 --> 00:42:58,920
Mettiamo un bound sui nodi visti. Ok?

840
00:42:58,920 --> 00:43:01,680
Quindi in memoria noi che cosa teniamo?

841
00:43:01,680 --> 00:43:04,319
Nodo corrente, nodo successivo più un

842
00:43:04,319 --> 00:43:08,160
contatore. Quanti ne ho visti finora?

843
00:43:08,160 --> 00:43:11,760
Se mentre gesso i passi successivi il

844
00:43:11,760 --> 00:43:14,359
contatore supera il numero dei nodi del

845
00:43:14,359 --> 00:43:17,400
grafo, allora sto luppando e io quel

846
00:43:17,400 --> 00:43:20,319
branch di computazione l'ammazzo

847
00:43:20,319 --> 00:43:22,599
tutto. Quindi per accettare che devo

848
00:43:22,599 --> 00:43:25,200
fare? Il branch accettante, la macchina

849
00:43:25,200 --> 00:43:28,319
che fa? Gesso i passi successivi, conto

850
00:43:28,319 --> 00:43:32,359
quanti passi faccio e accetto se arrivo

851
00:43:32,359 --> 00:43:35,240
a Tliola.

852
00:43:35,240 --> 00:43:38,319
Ok? Questo è il trucco. Prego.
Due

853
00:43:38,319 --> 00:43:42,000
domande. Allora, la prima è ma siccome

854
00:43:42,000 --> 00:43:43,480
noi vogliamo mantenerci uno spazio

855
00:43:43,480 --> 00:43:46,480
logaritmico,
sì,
tendenzialmente

856
00:43:46,480 --> 00:43:50,920
eh gli algoritmi di ricerca del del B

857
00:43:50,920 --> 00:43:53,079
ottimale sono molto più piccoli di una

858
00:43:53,079 --> 00:43:57,359
BFS, una BFS. Non possiamo assumere che

859
00:43:57,359 --> 00:44:00,520
il guessing eh della macchina in Cuding

860
00:44:00,520 --> 00:44:02,319
segua appunto gli algoritmi primari di

861
00:44:02,319 --> 00:44:05,319
ricerca del PUAP per avere Ma quegli

862
00:44:05,319 --> 00:44:08,319
algoritmi

863
00:44:09,480 --> 00:44:13,240
tipo la ricerca la ricerca in breath?

864
00:44:13,240 --> 00:44:17,280
Allora, se io mi vado a guardare,

865
00:44:18,800 --> 00:44:21,720
facciamo un esempio. Allora, io qui c'ho

866
00:44:21,720 --> 00:44:26,599
S e devo arrivare a T che sta qua. Ok?

867
00:44:26,599 --> 00:44:28,839
Supponiamo che S c'ha una marea di

868
00:44:28,839 --> 00:44:31,839
successivi

869
00:44:32,319 --> 00:44:35,599
e questo è attaccato a lui. Quando io

870
00:44:35,599 --> 00:44:37,960
metto S

871
00:44:37,960 --> 00:44:39,920
e faccio bread first, prendo i suoi

872
00:44:39,920 --> 00:44:42,160
successivi e li infilo nel sacco. li ho

873
00:44:42,160 --> 00:44:46,119
presi sostanzialmente tutti,

874
00:44:46,359 --> 00:44:50,440
quindi ho usato spazio lineare e è

875
00:44:50,440 --> 00:44:52,200
andata,

876
00:44:52,200 --> 00:44:56,599
però vabbè, in questo esempio è
eh ma io

877
00:44:56,599 --> 00:44:58,480
devo avere la garanzia che la macchina

878
00:44:58,480 --> 00:45:03,720
non usi mai più di più di spazio

879
00:45:03,720 --> 00:45:05,359
cioè quindi su qualsiasi sia l' istanza

880
00:45:05,359 --> 00:45:06,920
di input, qualsiasi forma abbia il

881
00:45:06,920 --> 00:45:09,280
grafo, io devo essere certo di non usare

882
00:45:09,280 --> 00:45:11,000
più di spazio logaritmico. Se mi arriva

883
00:45:11,000 --> 00:45:13,520
una cosa strampa come quella,

884
00:45:13,520 --> 00:45:16,400
al primo salto la macchina si mette nel

885
00:45:16,400 --> 00:45:18,480
salto tutti i successivi DS che sono

886
00:45:18,480 --> 00:45:20,960
quasi tutti noi.
Da qui arriva anche la

887
00:45:20,960 --> 00:45:25,160
seconda domanda, ovvero se noi conto che

888
00:45:25,160 --> 00:45:28,160
letteralmente è un grafico unilaterale

889
00:45:28,160 --> 00:45:30,599
dovè semplicemente una consecuzione di

890
00:45:30,599 --> 00:45:32,240
nodi, no? Sì. Ok?
Quindi noi lo

891
00:45:32,240 --> 00:45:34,800
esploriamo tutto.
Quindi noi

892
00:45:34,800 --> 00:45:37,079
percorrorendo tutto il grado, cioè si

893
00:45:37,079 --> 00:45:40,119
può dire ancora che è logaritmica la

894
00:45:40,119 --> 00:45:43,119
questione.

895
00:45:44,119 --> 00:45:47,240
La logaritmicità dell'algoritmo dipende

896
00:45:47,240 --> 00:45:50,760
dalla quantità di informazione che va

897
00:45:50,760 --> 00:45:53,599
scritta sul nastro, sulla quantità di

898
00:45:53,599 --> 00:45:55,359
gelle che viene usato sul nastro di

899
00:45:55,359 --> 00:45:57,880
lavoro.

900
00:45:57,880 --> 00:46:00,200
Adesso descrivo lo pseudocodice di

901
00:46:00,200 --> 00:46:02,720
questo algoritmo e vediamo che cosa ci

902
00:46:02,720 --> 00:46:05,359
cosa intende per scrivere il nodo, cioè

903
00:46:05,359 --> 00:46:07,920
scrivere il nominativo.
Sì,
quindi,
cioè

904
00:46:07,920 --> 00:46:10,000
quando lei in un algoritmo, non lo so,

905
00:46:10,000 --> 00:46:13,280
programmato Python Java, C++ Sì.
Ok. Nel

906
00:46:13,280 --> 00:46:18,520
momento in cui abbiamo eh current vertex

907
00:46:18,520 --> 00:46:22,280
equals S, ok? Quindi assegniamo S a

908
00:46:22,280 --> 00:46:24,319
current vertex, che cosa sta succedendo

909
00:46:24,319 --> 00:46:26,599
nella macchina? che c'è un blocco di

910
00:46:26,599 --> 00:46:28,480
memoria

911
00:46:28,480 --> 00:46:31,119
il cui contenuto binario prende

912
00:46:31,119 --> 00:46:33,880
l'identificativo del modo S. Questa è la

913
00:46:33,880 --> 00:46:35,480
stessa cosa, solo che invece di scrivere

914
00:46:35,480 --> 00:46:37,839
un programma lo scriviamo su.
Scusi, una

915
00:46:37,839 --> 00:46:40,640
domanda stupida, ma allora seo

916
00:46:40,640 --> 00:46:45,240
ha un nome lunghissimo, cioè si
eh, però

917
00:46:45,240 --> 00:46:48,800
il nome lunghissimo stava in integ

918
00:46:48,800 --> 00:46:51,599
perché è tutto rispetto alla data e poi

919
00:46:51,599 --> 00:46:55,160
li numeriamo anche
Sì, sì.

920
00:46:55,160 --> 00:46:58,480
Cioè, se io ho

921
00:46:58,480 --> 00:47:00,760
i nomi che si chiamano Pipp, Giovanni,

922
00:47:00,760 --> 00:47:03,599
Pluto e Topolino, no? E io mi devo

923
00:47:03,599 --> 00:47:06,400
gessare di identificativi. Sto gessando

924
00:47:06,400 --> 00:47:10,599
della delle cose che stavano nell'input

925
00:47:10,599 --> 00:47:12,400
oppure io li posso semplicemente

926
00:47:12,400 --> 00:47:15,200
numerare. Ok.

927
00:47:15,200 --> 00:47:19,119
Ok. Grazie.
Tutto qua. Allora, facciamo

928
00:47:19,119 --> 00:47:22,720
questo e poi ci fermiamo.

929
00:47:26,680 --> 00:47:29,079
Alri. Quindi abbiamo

930
00:47:29,079 --> 00:47:32,079
rich

931
00:47:34,000 --> 00:47:38,240
che prendiamo in input G, S.

932
00:47:38,240 --> 00:47:40,400
Funziona così.

933
00:47:40,400 --> 00:47:45,119
P è il nodo corrente e prende S.

934
00:47:45,119 --> 00:47:47,359
Poi prendiamo il contatore N e gli

935
00:47:47,359 --> 00:47:49,720
assegniamo uno che abbiamo visto un

936
00:47:49,720 --> 00:47:52,720
nodo.

937
00:47:53,280 --> 00:47:57,800
Dopodiché if P è uguale uguale a T, cioè

938
00:47:57,800 --> 00:48:01,480
siamo arrivati, allora

939
00:48:01,480 --> 00:48:04,480
accettiamo.

940
00:48:06,559 --> 00:48:12,520
Dopodiché Pacciamo un guess.

941
00:48:14,040 --> 00:48:18,319
di un vertice

942
00:48:18,800 --> 00:48:24,119
di G. Ok? Poi facciamo un controllo. If

943
00:48:24,119 --> 00:48:26,920
P'

944
00:48:26,920 --> 00:48:28,960
appartiene

945
00:48:28,960 --> 00:48:31,440
agli archi

946
00:48:31,440 --> 00:48:34,760
del grafo,

947
00:48:35,280 --> 00:48:38,119
eh no un attimo. Se non appartiene al

948
00:48:38,119 --> 00:48:41,520
grafo agli archi, allora

949
00:48:41,520 --> 00:48:42,920
rigettiamo.

950
00:48:42,920 --> 00:48:45,989
[Musica]

951
00:48:46,040 --> 00:48:52,240
Ok. Poi semplicemente mettiamo P' in P,

952
00:48:52,240 --> 00:48:56,520
incrementiamo il contatore.

953
00:48:56,839 --> 00:49:02,319
Se n è minore o è minore o uguale al

954
00:49:02,319 --> 00:49:05,319
numero è minore

955
00:49:05,319 --> 00:49:09,760
o uguale sì al alla al numero dei nodi,

956
00:49:09,760 --> 00:49:12,400
then go

957
00:49:12,400 --> 00:49:16,839
a e diamo la label a là.

958
00:49:16,839 --> 00:49:18,400
Altrimenti

959
00:49:18,400 --> 00:49:21,400
peggate.

960
00:49:24,480 --> 00:49:27,920
Vedete tutto? Sì. Ok. Allora, questo è

961
00:49:27,920 --> 00:49:30,599
un algoritmo molto semplice. Partiamo

962
00:49:30,599 --> 00:49:34,760
dal nodo S. Inizializziamo il contatore.

963
00:49:34,760 --> 00:49:37,200
Se P che il nodo corrente è uguale alla

964
00:49:37,200 --> 00:49:39,359
destinazione, accettiamo perché ci siamo

965
00:49:39,359 --> 00:49:42,559
arrivati. Altrimenti che siamo in primo

966
00:49:42,559 --> 00:49:44,920
un qualsiasi vertice di C. Come vedete,

967
00:49:44,920 --> 00:49:47,040
noi non ci curiamo di vedere se qualcosa

968
00:49:47,040 --> 00:49:49,920
che è stato già visitato o meno. Se la

969
00:49:49,920 --> 00:49:51,760
cosa che abbiamo cessato non fa parte

970
00:49:51,760 --> 00:49:55,520
degli altri, rifiutiamo.

971
00:49:57,480 --> 00:50:02,400
Dopodiché assegniamo P' a P e possiamo

972
00:50:02,400 --> 00:50:05,280
continuare successivamente.

973
00:50:05,280 --> 00:50:07,839
Incrementiamo il contatore. Se siamo

974
00:50:07,839 --> 00:50:10,359
arrivati, se non stiamo eccedendo la

975
00:50:10,359 --> 00:50:12,599
taglia dei nodi, ritorniamo qua e

976
00:50:12,599 --> 00:50:15,240
continuiamo la procedura. altrimenti ci

977
00:50:15,240 --> 00:50:18,240
fermiamo.

978
00:50:18,680 --> 00:50:22,960
Ok? Allora, questo algoritmo è corretto

979
00:50:22,960 --> 00:50:26,160
in quanto

980
00:50:29,040 --> 00:50:32,000
in quanto nel momento in cui c'è un pat

981
00:50:32,000 --> 00:50:35,000
da S a T dentro G, ci sarà una sequenza

982
00:50:35,000 --> 00:50:38,839
di gess lunghezza al + n che mi

983
00:50:38,839 --> 00:50:41,240
permetterà di arrivare lì e arrivare

984
00:50:41,240 --> 00:50:42,960
alla parte in cui ci spostiamo nello

985
00:50:42,960 --> 00:50:46,799
stato accettante. Se questo pat G non ci

986
00:50:46,799 --> 00:50:50,520
sta, non ci sarà nessuna sequenza di gas

987
00:50:50,520 --> 00:50:53,240
di alq n steps che ci permetterà di

988
00:50:53,240 --> 00:50:56,160
arrivare t, quindi alla fine rigetteremo

989
00:50:56,160 --> 00:51:00,319
su tutti i brgch. Ok?

990
00:51:00,319 --> 00:51:02,079
È chiaro come funziona questo algoritmo?

991
00:51:02,079 --> 00:51:05,440
Ok. Cosa ci serve da memorizzare? Cosa

992
00:51:05,440 --> 00:51:11,319
abbiamo su workta tape? Abbiamo eh

993
00:51:11,960 --> 00:51:17,000
abbiamo P che è il nodo corrente, P' che

994
00:51:17,000 --> 00:51:19,839
è il nodo successivo e lì noi

995
00:51:19,839 --> 00:51:22,280
memorizziamo due identificativi. Se se

996
00:51:22,280 --> 00:51:24,400
li contiamo i nodi gli diamo

997
00:51:24,400 --> 00:51:26,839
l'identificativo e quello là e prende

998
00:51:26,839 --> 00:51:30,960
spazio lì spazio

999
00:51:30,960 --> 00:51:33,200
logaritmico. Un altro modo, come

1000
00:51:33,200 --> 00:51:35,000
troverete sugli appunti di Calauti, è

1001
00:51:35,000 --> 00:51:38,839
che lì in Patore

1002
00:51:38,880 --> 00:51:41,680
a dove c'è la descrizione del nodo sul

1003
00:51:41,680 --> 00:51:46,079
nastro, c'è la 14 input. Quello lo si

1004
00:51:46,079 --> 00:51:47,880
rappresenta sicuramente in spazio

1005
00:51:47,880 --> 00:51:50,880
logaritmico. Io uso i nomi perché è più

1006
00:51:50,880 --> 00:51:53,040
intuitivo. Senò in linea di principio

1007
00:51:53,040 --> 00:51:55,280
uno lì ci mette il puntatore alla cella

1008
00:51:55,280 --> 00:51:57,079
sul nastro di input e quella ha sempre

1009
00:51:57,079 --> 00:51:59,559
taglia logaritmica. Quindi che cosa ho?

1010
00:51:59,559 --> 00:52:02,839
Devo memorizzare il nodo corrente,

1011
00:52:02,839 --> 00:52:05,760
il nodo successivo,

1012
00:52:05,760 --> 00:52:08,640
il contatore,

1013
00:52:08,640 --> 00:52:11,280
tutti questi. Quindi abbiamo tre

1014
00:52:11,280 --> 00:52:14,359
elementi, ognuno dei quali prende spazio

1015
00:52:14,359 --> 00:52:16,960
logaritmico. Quindi questa che cos'è? è

1016
00:52:16,960 --> 00:52:18,960
una procedura

1017
00:52:18,960 --> 00:52:22,280
log space da parte di una macchina non

1018
00:52:22,280 --> 00:52:24,799
deterministica che decide la

1019
00:52:24,799 --> 00:52:27,400
raggiungibilità in un grafo orientato da

1020
00:52:27,400 --> 00:52:31,160
cui richability è un problema in

1021
00:52:31,160 --> 00:52:32,760
nondeterministic

1022
00:52:32,760 --> 00:52:37,200
space. Chiaro? Ok. E possiamo fare un

1023
00:52:37,200 --> 00:52:40,040
po' di pausa, una decina di minuti, 10

1024
00:52:40,040 --> 00:52:43,839
minuti più o meno.

1025
00:52:44,040 --> 00:52:49,880
Eh, dov'è? Dov'è? Quand'è? Dove sta?

1026
00:52:49,920 --> 00:52:52,359
Un tempo ci stava il mouse. Dov'è?

1027
00:52:52,359 --> 00:52:54,359
Eccolo qua.

1028
00:52:54,359 --> 00:52:57,079
È a destra. A destra.

1029
00:52:57,079 --> 00:53:00,680
Spunta, spunta.

1030
00:53:05,150 --> 00:53:09,840
[Musica]

1031
00:53:15,000 --> 00:53:19,240
Alri. Right. Right. Ok. Allora,

1032
00:53:19,240 --> 00:53:21,920
prima quando ragionavamo sul problema

1033
00:53:21,920 --> 00:53:24,079
sul problema sul nostro fantastico

1034
00:53:24,079 --> 00:53:26,440
problema di receability vi ho detto se

1035
00:53:26,440 --> 00:53:28,720
volete risparmiare spazio logaritmico

1036
00:53:28,720 --> 00:53:31,000
dovete usare dovete usare il nond

1037
00:53:31,000 --> 00:53:33,839
determinismo perché se non volete usare

1038
00:53:33,839 --> 00:53:36,799
il non determinismo non ne usciamo.

1039
00:53:36,799 --> 00:53:39,319
Perché vi dicevo questo? Perché ho una

1040
00:53:39,319 --> 00:53:41,400
conoscenza che a voi ancora non avevo

1041
00:53:41,400 --> 00:53:45,200
comunicato che è questa. Non la gente si

1042
00:53:45,200 --> 00:53:47,200
è chiesta, ma il nondeterminismo per

1043
00:53:47,200 --> 00:53:50,599
risolvere richility è determinante?

1044
00:53:50,599 --> 00:53:52,520
Possiamo fare in log space

1045
00:53:52,520 --> 00:53:54,720
deterministico,

1046
00:53:54,720 --> 00:53:56,760
non si sa.

1047
00:53:56,760 --> 00:53:58,760
È una di quelle fantastiche questioni

1048
00:53:58,760 --> 00:54:01,319
della complessità nella quali algoritmi

1049
00:54:01,319 --> 00:54:03,799
deterministici log space per richability

1050
00:54:03,799 --> 00:54:05,720
non ce ne stanno, però nessuno ha mai

1051
00:54:05,720 --> 00:54:08,119
dimostrato che non sia possibile. Ok.

1052
00:54:08,119 --> 00:54:10,599
dopo tanti anni riteniamo che non sia

1053
00:54:10,599 --> 00:54:12,839
fattibile, ma non è che ne siamo certi,

1054
00:54:12,839 --> 00:54:14,680
lo assumiamo perché, insomma, ci abbiamo

1055
00:54:14,680 --> 00:54:16,839
sbattuto la testa così a lungo che ormai

1056
00:54:16,839 --> 00:54:19,920
riteniamo che non sia non sia fattibile.

1057
00:54:19,920 --> 00:54:21,960
La questione è che nessuno ha mai

1058
00:54:21,960 --> 00:54:23,920
mostrato formalmente che questa cosa non

1059
00:54:23,920 --> 00:54:28,920
si possa fare. Allora, il tutto proviene

1060
00:54:28,920 --> 00:54:32,640
e come si è studiata la gente questa

1061
00:54:32,640 --> 00:54:34,520
cosa qua?

1062
00:54:34,520 --> 00:54:36,760
Ha fatto dei ragionamenti simili alla

1063
00:54:36,760 --> 00:54:39,040
questione

1064
00:54:39,040 --> 00:54:42,040
P versus NP.

1065
00:54:42,040 --> 00:54:44,240
che nel momento in cui noi sappiamo che

1066
00:54:44,240 --> 00:54:46,720
log space sta dentro non deterministic

1067
00:54:46,720 --> 00:54:48,760
lo log space non sappiamo se queste due

1068
00:54:48,760 --> 00:54:52,319
classi c'è una relazione di contenimento

1069
00:54:52,319 --> 00:54:54,720
stretto o meno

1070
00:54:54,720 --> 00:54:57,200
e le persone se ne sono inventate delle

1071
00:54:57,200 --> 00:54:59,200
nozioni simili a quelle che furono

1072
00:54:59,200 --> 00:55:02,079
utilizzate per studiare la questione P

1073
00:55:02,079 --> 00:55:04,760
versus NP che si sono inventati si sono

1074
00:55:04,760 --> 00:55:07,200
inventati il concetto dei problemi più

1075
00:55:07,200 --> 00:55:09,640
difficili della classe NL. Vi ricorda

1076
00:55:09,640 --> 00:55:11,160
qualcosa?

1077
00:55:11,160 --> 00:55:14,799
Ok? Come c'abbiamo i problemi NP

1078
00:55:14,799 --> 00:55:18,079
completi, abbiamo i problemi NL completi

1079
00:55:18,079 --> 00:55:20,920
che sono i problemi più difficili della

1080
00:55:20,920 --> 00:55:24,880
classe NL e riceability è uno di quelli,

1081
00:55:24,880 --> 00:55:28,680
ok? È un problema tosto della classe non

1082
00:55:28,680 --> 00:55:31,520
deterministic lo space e per queste

1083
00:55:31,520 --> 00:55:34,880
ragioni riteniamo riteniamo che non

1084
00:55:34,880 --> 00:55:37,160
possa essere risolvibile il

1085
00:55:37,160 --> 00:55:38,720
deterministic

1086
00:55:38,720 --> 00:55:41,240
space. Ok? Allora, quello che noi

1087
00:55:41,240 --> 00:55:43,680
dobbiamo fare adesso, defini definiamo

1088
00:55:43,680 --> 00:55:46,880
cos'è un problema non deterministic log

1089
00:55:46,880 --> 00:55:49,400
space completo è una generalizzazione di

1090
00:55:49,400 --> 00:55:51,359
cose che abbiamo già visto per NP,

1091
00:55:51,359 --> 00:55:52,960
quindi lo facciamo assieme così ci

1092
00:55:52,960 --> 00:55:56,319
esercitiamo a ricordarci i concetti e a

1093
00:55:56,319 --> 00:55:58,720
estenderli.

1094
00:55:58,720 --> 00:56:01,039
Allora, ve la ricordate la definizione

1095
00:56:01,039 --> 00:56:03,960
di NP completezza?

1096
00:56:03,960 --> 00:56:06,880
un problema, un linguaggio di decisione

1097
00:56:06,880 --> 00:56:09,200
è sì, un linguaggio di decisione, un

1098
00:56:09,200 --> 00:56:12,880
linguaggio è NP completo. Se

1099
00:56:12,880 --> 00:56:15,680
appartiene ad NP e qualsiasi problema

1100
00:56:15,680 --> 00:56:17,720
appartenente ad NP è riducibile a quelli

1101
00:56:17,720 --> 00:56:19,760
quali.
È riduci in quale modo?
Eh,

1102
00:56:19,760 --> 00:56:22,000
polinomiale.
Inopinomiale. Ok, questa

1103
00:56:22,000 --> 00:56:26,400
era la definizione di NP completezza.

1104
00:56:26,400 --> 00:56:29,039
Allora, non possiamo usare la

1105
00:56:29,039 --> 00:56:31,559
stessissima definizione, ne dobbiamo

1106
00:56:31,559 --> 00:56:34,160
usare una simile. In particolare il

1107
00:56:34,160 --> 00:56:37,160
problema si annila nella riduzione.

1108
00:56:37,160 --> 00:56:40,599
Ridurre polinomialmente

1109
00:56:40,599 --> 00:56:42,440
problemi

1110
00:56:42,440 --> 00:56:44,640
dentro NL

1111
00:56:44,640 --> 00:56:47,200
è troppo potente, cioè noi potremmo

1112
00:56:47,200 --> 00:56:49,680
ridurre problemi difficili a problemi

1113
00:56:49,680 --> 00:56:52,319
facili se avessimo possibilità di fare

1114
00:56:52,319 --> 00:56:56,520
riduzioni in tempo polinomiale perché

1115
00:56:56,520 --> 00:56:59,000
ok vabbò lo vedremo domani, ma vi do

1116
00:56:59,000 --> 00:57:03,079
l'anteprima. P sta qua, eh,

1117
00:57:03,079 --> 00:57:06,760
P sta qua sopra, eh,

1118
00:57:06,760 --> 00:57:09,240
lo vediamo domani sta cosa. Prendetemi

1119
00:57:09,240 --> 00:57:11,960
sulla parola. P sta lì sopra. Allora,

1120
00:57:11,960 --> 00:57:14,280
fare riduzioni polinomiali per problemi

1121
00:57:14,280 --> 00:57:17,599
che stanno qua dentro e sono riduzioni

1122
00:57:17,599 --> 00:57:19,880
un po' troppo forti. Allora, le persone

1123
00:57:19,880 --> 00:57:22,440
si sono inventate tutta una pletora di

1124
00:57:22,440 --> 00:57:25,440
riduzioni,

1125
00:57:25,440 --> 00:57:29,839
le le cui più semplici sono le riduzioni

1126
00:57:29,839 --> 00:57:33,599
log space, ok? Dice riduzione

1127
00:57:33,599 --> 00:57:35,960
polinomiale, riduzione spazio

1128
00:57:35,960 --> 00:57:38,119
logaritmico. Intuitivamente, secondo

1129
00:57:38,119 --> 00:57:40,599
voi, una riduzione log space che cosa

1130
00:57:40,599 --> 00:57:43,520
potrà mai essere? Un attimo, qualcuno di

1131
00:57:43,520 --> 00:57:47,599
nuovo? Voci nuove.

1132
00:57:47,799 --> 00:57:51,440
Facciamo il coro e poi andiamo a cantare

1133
00:57:51,440 --> 00:57:53,119
all'Antoniano, allo Zecchino d'oro.

1134
00:57:53,119 --> 00:57:56,760
Andiamo, guys. Cosa potrà mai essere una

1135
00:57:56,760 --> 00:58:00,640
riduzione? Lo space.

1136
00:58:01,839 --> 00:58:03,400
Io nel frattempo ho registrato i

1137
00:58:03,400 --> 00:58:05,359
prenotati. Vorrei sentire qualche voce

1138
00:58:05,359 --> 00:58:08,359
nuova.

1139
00:58:10,039 --> 00:58:12,000
Nuova. Sì, prego.
La funzione

1140
00:58:12,000 --> 00:58:15,160
calcolabile in spazio logico.
Ok. Ok.

1141
00:58:15,160 --> 00:58:17,000
Quindi ci dobbiamo inventare che cosa

1142
00:58:17,000 --> 00:58:19,520
significa che una funzione sia

1143
00:58:19,520 --> 00:58:22,160
calcolabile in spazio logaritmico prima,

1144
00:58:22,160 --> 00:58:24,559
ok? Perché ci serve una funzione di

1145
00:58:24,559 --> 00:58:27,079
trasformazione calcolabile in spazio

1146
00:58:27,079 --> 00:58:30,039
logaritmico. Vi ricordate come avevamo

1147
00:58:30,039 --> 00:58:32,599
definito le funzioni calcolabili in

1148
00:58:32,599 --> 00:58:35,920
tempo polinomiale?

1149
00:58:38,440 --> 00:58:41,640
Erano definite tramite il concetto di
di

1150
00:58:41,640 --> 00:58:43,960
trasduttore. Cos'è un trasduttore? è una

1151
00:58:43,960 --> 00:58:46,640
macchina di Touring Stramb nastro di

1152
00:58:46,640 --> 00:58:49,920
output. Ok? Quindi le funzioni sono

1153
00:58:49,920 --> 00:58:52,119
calcolate da macchine di touring che

1154
00:58:52,119 --> 00:58:54,200
hanno un nastro particolare sola

1155
00:58:54,200 --> 00:58:56,079
scrittura

1156
00:58:56,079 --> 00:58:59,280
nel quale la macchina sputa fuori il

1157
00:58:59,280 --> 00:59:01,680
proprio output. Ok? Questa era la

1158
00:59:01,680 --> 00:59:04,480
nozione di trasduttore

1159
00:59:04,480 --> 00:59:07,880
perché adesso arriva la ragione del

1160
00:59:07,880 --> 00:59:10,880
perché il nastro di output sia di sola

1161
00:59:10,880 --> 00:59:13,480
scrittura. Ok? E in particolare ha pure

1162
00:59:13,480 --> 00:59:16,119
questa caratteristica. La testina va in

1163
00:59:16,119 --> 00:59:18,119
un solo verso. Perché mai ce la

1164
00:59:18,119 --> 00:59:20,720
inventiamo così? Perché nel momento in

1165
00:59:20,720 --> 00:59:24,640
cui sto andando troppo veloce, ok? Nel

1166
00:59:24,640 --> 00:59:28,160
momento in cui vogliamo imporre un

1167
00:59:28,160 --> 00:59:30,920
vincolo spaziale

1168
00:59:30,920 --> 00:59:33,680
a un trasduttore

1169
00:59:33,680 --> 00:59:36,480
e il trasduttore sul nastro di output

1170
00:59:36,480 --> 00:59:38,960
può fare quello che gli pare, potrebbe

1171
00:59:38,960 --> 00:59:41,359
iniziare a usare il nastro di output

1172
00:59:41,359 --> 00:59:43,000
come foglio di brutta e poi te lo

1173
00:59:43,000 --> 00:59:44,680
consegnano all'esame e sì, è un po'

1174
00:59:44,680 --> 00:59:48,440
mischiato, no? Sul sul nastro di output

1175
00:59:48,440 --> 00:59:51,520
ci va la bella, ci va il risultato. Ok?

1176
00:59:51,520 --> 00:59:54,559
Quindi un trasduttore

1177
00:59:54,559 --> 00:59:58,079
così definito in cui il nastro di input

1178
00:59:58,079 --> 01:00:00,559
lo possiamo solo leggere, il nastro di

1179
01:00:00,559 --> 01:00:04,240
output può essere solo scritto, diventa

1180
01:00:04,240 --> 01:00:08,319
sensato che cosa? Imporre il vincolo di

1181
01:00:08,319 --> 01:00:10,960
spazio sul nastro di lavoro. Ok? Questa

1182
01:00:10,960 --> 01:00:12,920
è la ragione per cui il nostro di output

1183
01:00:12,920 --> 01:00:15,200
è sola scrittura, in maniera tale che

1184
01:00:15,200 --> 01:00:19,280
diventi sensato imporre il vincolo

1185
01:00:19,280 --> 01:00:22,160
sullo spazio del del del nastro di

1186
01:00:22,160 --> 01:00:24,200
lavoro. Perché? Perché se dobbiamo

1187
01:00:24,200 --> 01:00:27,400
produrre un output grosso e noi andiamo

1188
01:00:27,400 --> 01:00:29,640
pure a contare lo spazio per scrivere,

1189
01:00:29,640 --> 01:00:31,240
eh ma noi quell'output dovevamo

1190
01:00:31,240 --> 01:00:34,920
generarlo, no? Quindi non potremmo mai

1191
01:00:34,920 --> 01:00:37,160
avere un trasduttore long space se

1192
01:00:37,160 --> 01:00:40,599
dobbiamo scrivere un un output lungo.

1193
01:00:40,599 --> 01:00:43,720
Quindi noi vogliamo imporre il vincolo

1194
01:00:43,720 --> 01:00:47,079
di spazio solamente sul nastro di lavoro

1195
01:00:47,079 --> 01:00:49,680
e per questa ragione noi imponiamo che

1196
01:00:49,680 --> 01:00:51,760
sul nastro di output possiamo solamente

1197
01:00:51,760 --> 01:00:53,720
scrivere. Quindi la macchina non può

1198
01:00:53,720 --> 01:00:57,520
processare, scrive e basta. Cioè, se non

1199
01:00:57,520 --> 01:01:00,880
è di lettura, vuol dire che il contenuto

1200
01:01:00,880 --> 01:01:03,280
del nastro di output non viene mai

1201
01:01:03,280 --> 01:01:05,920
considerato per valutare il next step.

1202
01:01:05,920 --> 01:01:08,400
Questa è la questione. Ok? Se io posso

1203
01:01:08,400 --> 01:01:10,359
solo scrivere su quel nastro, cosa ci

1204
01:01:10,359 --> 01:01:12,520
sta su quel nastro? Non entra mai nella

1205
01:01:12,520 --> 01:01:13,920
valutazione della funzione di

1206
01:01:13,920 --> 01:01:16,480
transizione. Quella è la ragione. Ok?

1207
01:01:16,480 --> 01:01:19,920
Quindi retap. Cos'è un trasduttore long

1208
01:01:19,920 --> 01:01:22,799
space? è un trasduttore

1209
01:01:22,799 --> 01:01:25,559
che ha quindi nastro di input di sola

1210
01:01:25,559 --> 01:01:29,559
lettura, nastro di lavoro work di

1211
01:01:29,559 --> 01:01:32,880
lettura scrittura, nastro di output di

1212
01:01:32,880 --> 01:01:36,039
sola scrittura.

1213
01:01:36,039 --> 01:01:37,960
Il trasuttore lavora in spazio

1214
01:01:37,960 --> 01:01:40,680
logaritmico se lo spazio utilizzato su

1215
01:01:40,680 --> 01:01:44,760
un nastro di lavoro è bound da un

1216
01:01:44,760 --> 01:01:51,079
logaritmo. Ok? e l' ottiene per ok?

1217
01:01:51,079 --> 01:01:54,240
Un tale trasduttore

1218
01:01:54,240 --> 01:01:57,480
calcola una certa funzione f

1219
01:01:57,480 --> 01:02:02,039
se per un qualsiasi input

1220
01:02:02,039 --> 01:02:04,599
eh che diamo a questo trasduttore su

1221
01:02:04,599 --> 01:02:08,559
quella stringa W il trasduttore lascerà

1222
01:02:08,559 --> 01:02:12,119
a fine calcolo sul nastro di output f.

1223
01:02:12,119 --> 01:02:15,520
Ok? Tutto qua. Possiamo quindi ora

1224
01:02:15,520 --> 01:02:17,160
definire, quindi è chiaro cos'è un

1225
01:02:17,160 --> 01:02:20,079
trasduttore in soldoni è un algoritmo

1226
01:02:20,079 --> 01:02:24,200
che produce un output e impiega spazio

1227
01:02:24,200 --> 01:02:26,279
algaritmico per farlo sul nastro di

1228
01:02:26,279 --> 01:02:28,520
lavoro. Ok? tutto qua, non è nulla di

1229
01:02:28,520 --> 01:02:31,279
particolare. Possiamo quindi definire

1230
01:02:31,279 --> 01:02:36,119
cos'è una riduzione log space,

1231
01:02:36,119 --> 01:02:37,680
quindi

1232
01:02:37,680 --> 01:02:39,359
siano

1233
01:02:39,359 --> 01:02:45,160
A e B due linguaggi.

1234
01:02:48,920 --> 01:02:51,920
Esiste

1235
01:02:52,079 --> 01:02:56,400
una riduzione

1236
01:02:56,760 --> 01:03:00,200
log space

1237
01:03:00,799 --> 01:03:03,559
da A

1238
01:03:03,559 --> 01:03:06,760
a b

1239
01:03:07,559 --> 01:03:10,039
denotato

1240
01:03:10,039 --> 01:03:12,440
con

1241
01:03:12,440 --> 01:03:17,160
A ug l b. Vedete, uso un simbolo

1242
01:03:17,160 --> 01:03:19,160
diverso. Quando è polinomial time la

1243
01:03:19,160 --> 01:03:21,599
mettiamo P. Quando è log space mettiamo

1244
01:03:21,599 --> 01:03:24,839
L. Completate voi la definizione. Quindi

1245
01:03:24,839 --> 01:03:28,960
A si riduce in log space a B.

1246
01:03:35,160 --> 01:03:37,680
Sì,
per ogni stringa appartenente ad

1247
01:03:37,680 --> 01:03:41,000
manca un pezzo.

1248
01:03:41,920 --> 01:03:45,440
Lei sta dicendo per ogni stringa w
vale

1249
01:03:45,440 --> 01:03:48,279
w appartiene ad a
come tale w appartiene

1250
01:03:48,279 --> 01:03:52,720
ad asse solo se e f di w
ed f chi è?
F è

1251
01:03:52,720 --> 01:03:54,400
una funzione calcolabile
che non abbiamo

1252
01:03:54,400 --> 01:03:57,279
ancora. Ok. Quindi
esiste una funzione,

1253
01:03:57,279 --> 01:04:00,720
Esiste, bravissimo, esiste

1254
01:04:00,720 --> 01:04:04,520
una funzione

1255
01:04:04,520 --> 01:04:07,559
fpa cosa?

1256
01:04:07,559 --> 01:04:11,839
Stringa. String.
String su string.

1257
01:04:12,200 --> 01:04:15,200
F caratteristiche deve avere?

1258
01:04:15,200 --> 01:04:16,480
Deve essere calcolabile da un

1259
01:04:16,480 --> 01:04:19,039
trasduttore
calcolabile in spazio

1260
01:04:19,039 --> 01:04:22,839
logaritmico calcolabile

1261
01:04:23,200 --> 01:04:26,119
in log space.

1262
01:04:26,119 --> 01:04:29,799
Ed inoltre
per ogni stringa w e se w

1263
01:04:29,799 --> 01:04:32,960
appartene ad a w appartina ad a se solo

1264
01:04:32,960 --> 01:04:36,599
se
esattamente. Ok,

1265
01:04:36,599 --> 01:04:39,359
quindi la nozione di riduzione è

1266
01:04:39,359 --> 01:04:41,760
sostanzialmente mantenuta mantenuta.

1267
01:04:41,760 --> 01:04:43,160
L'unica cosa è che la funzione di

1268
01:04:43,160 --> 01:04:45,160
trasformazione che richiediamo è che

1269
01:04:45,160 --> 01:04:49,160
venga calcolato in log space, sottolineo

1270
01:04:49,160 --> 01:04:53,839
qua, log space deterministico, eh, cioè

1271
01:04:53,839 --> 01:04:56,160
non può fare cose strambe la riduzione,

1272
01:04:56,160 --> 01:04:59,000
deve è una cosa semplicissima. log space

1273
01:04:59,000 --> 01:05:00,520
deterministico.

1274
01:05:00,520 --> 01:05:03,000
In realtà non l'abbiamo mai

1275
01:05:03,000 --> 01:05:05,960
sottolineato, ma moltissime delle

1276
01:05:05,960 --> 01:05:08,200
riduzioni che abbiamo visto, tipo la

1277
01:05:08,200 --> 01:05:10,359
riduzione da indipendenzetta a vertex

1278
01:05:10,359 --> 01:05:13,279
cover, era una riduzione long space. Non

1279
01:05:13,279 --> 01:05:15,000
ve l'ho detto perché ancora non avevamo

1280
01:05:15,000 --> 01:05:19,359
il concetto. Quella sì traduce in

1281
01:05:19,359 --> 01:05:20,960
polinomial time, ma quella era una

1282
01:05:20,960 --> 01:05:23,039
riduzione che prendeva il grafo e lo

1283
01:05:23,039 --> 01:05:25,319
sputava in output, quindi spazio di

1284
01:05:25,319 --> 01:05:26,920
lavoro non ne usava proprio. Quella è

1285
01:05:26,920 --> 01:05:29,039
una riduzione log space, la prende, la

1286
01:05:29,039 --> 01:05:32,000
butta. Chiaro? L'unica cosa che faceva

1287
01:05:32,000 --> 01:05:35,520
calcolava la differenza. n - k faceva

1288
01:05:35,520 --> 01:05:37,720
era lunga trasformazione, si può

1289
01:05:37,720 --> 01:05:41,880
dimostrare che eh le sottrazioni, le

1290
01:05:41,880 --> 01:05:44,000
operazioni, le operazioni aritmetiche si

1291
01:05:44,000 --> 01:05:46,520
fanno in taglia log space degli

1292
01:05:46,520 --> 01:05:49,400
operandi, ok? Quindi quella era una

1293
01:05:49,400 --> 01:05:51,359
trasformazione log space, in realtà ne

1294
01:05:51,359 --> 01:05:53,160
abbiamo viste tante di trasformazioni

1295
01:05:53,160 --> 01:05:56,880
log space, ok? Logace deterministiche,

1296
01:05:56,880 --> 01:05:59,640
ok? E possiamo, una volta che abbiamo la

1297
01:05:59,640 --> 01:06:02,640
definizione

1298
01:06:02,960 --> 01:06:05,960
di

1299
01:06:06,400 --> 01:06:10,599
riduzione log space, possiamo definire

1300
01:06:10,599 --> 01:06:16,559
i linguaggi NL completi. Un linguaggio

1301
01:06:19,960 --> 01:06:25,599
L e NL complete.

1302
01:06:26,119 --> 01:06:28,000
Eh,

1303
01:06:28,000 --> 01:06:31,400
secondo voi

1304
01:06:32,480 --> 01:06:37,000
L appartiene a NL e per ogni L'O

1305
01:06:37,000 --> 01:06:41,240
appartenente a NL si ha una riduzione

1306
01:06:41,240 --> 01:06:43,520
da

1307
01:06:43,520 --> 01:06:47,160
N da L' a L.

1308
01:06:47,160 --> 01:06:49,400
Sì, esattamente.

1309
01:06:49,400 --> 01:06:51,720
Ok,

1310
01:06:51,720 --> 01:06:54,720
questo

1311
01:06:55,160 --> 01:06:56,880
l

1312
01:06:56,880 --> 01:07:01,720
Lness, sì, questa qui è membership.

1313
01:07:01,720 --> 01:07:04,720
Membership

1314
01:07:04,799 --> 01:07:10,440
in NL e questa è NL hardness.

1315
01:07:10,440 --> 01:07:13,279
Esattamente.

1316
01:07:13,279 --> 01:07:17,480
Quindi un problema è NL hard, se è

1317
01:07:17,480 --> 01:07:20,039
almeno difficile quando tutti i problemi

1318
01:07:20,039 --> 01:07:23,760
della classe NL ed è NL completo se sta

1319
01:07:23,760 --> 01:07:26,200
anche in NL, quindi è uno dei problemi

1320
01:07:26,200 --> 01:07:30,520
più complicati della classe NL. Un

1321
01:07:30,520 --> 01:07:33,880
risultato che si può dimostrare simile a

1322
01:07:33,880 --> 01:07:37,760
quello che abbiamo visto per P versus

1323
01:07:37,760 --> 01:07:40,720
NP. Si può mostrare che nel momento in

1324
01:07:40,720 --> 01:07:45,039
cui un linguaggio NL completo fosse in

1325
01:07:45,039 --> 01:07:47,319
logpace

1326
01:07:47,319 --> 01:07:50,760
e non deterministic log space sarebbero

1327
01:07:50,760 --> 01:07:54,680
la stessa classe. Ok?

1328
01:07:54,680 --> 01:07:58,039
Quello che dimostriamo ora è che

1329
01:07:58,039 --> 01:08:03,119
spazio ne abbiamo, ma più o meno.

1330
01:08:03,319 --> 01:08:05,760
Quello che dimostriamo ora è che tiriamo

1331
01:08:05,760 --> 01:08:09,240
una bella linea.

1332
01:08:10,440 --> 01:08:13,559
un problema che rich ability non solo è

1333
01:08:13,559 --> 01:08:15,680
un problema in NL, come abbiamo visto

1334
01:08:15,680 --> 01:08:18,000
prima, ma è anche un problema NL art,

1335
01:08:18,000 --> 01:08:22,600
cioè è un problema tosto per la classe

1336
01:08:22,600 --> 01:08:25,120
NL. Quindi quello che noi mostriamo ora

1337
01:08:25,120 --> 01:08:28,640
è che richility

1338
01:08:29,080 --> 01:08:33,080
è no appartiene, no? Eh,

1339
01:08:33,080 --> 01:08:37,080
NL complete.

1340
01:08:40,199 --> 01:08:44,319
Per le riduzioni per le riduzioni

1341
01:08:44,319 --> 01:08:46,560
log space valgono tutte le proprietà che

1342
01:08:46,560 --> 01:08:49,960
valevano per eh per le riduzioni

1343
01:08:49,960 --> 01:08:52,359
polinomiali, quindi la transitività

1344
01:08:52,359 --> 01:08:54,279
eccetera. E mi ricordo che noi quando

1345
01:08:54,279 --> 01:08:56,600
facevamo le riduzioni di NPR no

1346
01:08:56,600 --> 01:09:00,520
prendevamo un problema noto NP argo e lo

1347
01:09:00,520 --> 01:09:03,000
riducvamo al problema di interesse.

1348
01:09:03,000 --> 01:09:06,480
Abbiamo problemi noti NL hard? No.

1349
01:09:06,480 --> 01:09:08,359
Quindi dobbiamo far vedere che qualsiasi

1350
01:09:08,359 --> 01:09:11,000
linguaggio di NL si riduce a

1351
01:09:11,000 --> 01:09:12,600
ricciability. Quindi dobbiamo fare una

1352
01:09:12,600 --> 01:09:15,480
cosa che ha la valenza del teorema di

1353
01:09:15,480 --> 01:09:20,000
Cook però su NL. Ok? In realtà è più

1354
01:09:20,000 --> 01:09:22,199
semplice, non è così non è così

1355
01:09:22,199 --> 01:09:23,960
complicato,

1356
01:09:23,960 --> 01:09:25,920
però si può fa', dobbiamo un attimo

1357
01:09:25,920 --> 01:09:29,159
ragionare. Ok,

1358
01:09:29,159 --> 01:09:32,319
solite domande. Quindi, per mostrare che

1359
01:09:32,319 --> 01:09:35,359
richability è NL completo, noi dobbiamo

1360
01:09:35,359 --> 01:09:38,359
far vedere che preso un linguaggio L

1361
01:09:38,359 --> 01:09:41,040
generico, questo si riduce in log space

1362
01:09:41,040 --> 01:09:44,759
deterministico a reachability.

1363
01:09:44,759 --> 01:09:48,839
Ok? Qual è il problema di partenza?

1364
01:09:49,679 --> 01:09:54,239
qualsiasi
L generico, ok? Si riduce log

1365
01:09:54,239 --> 01:09:58,320
space a reachability.

1366
01:09:59,679 --> 01:10:02,640
Cos'è un'istanza per L?

1367
01:10:02,640 --> 01:10:05,239
Stringa.
Una stringa.

1368
01:10:05,239 --> 01:10:09,520
Cos'è un'istanza per richability?

1369
01:10:12,400 --> 01:10:15,760
Grafo sorgente.
È una tripla. Grafo

1370
01:10:15,760 --> 01:10:18,239
sorgente target. Ok, quindi ci dobbiamo

1371
01:10:18,239 --> 01:10:21,880
inventare una funzione che mappi una

1372
01:10:21,880 --> 01:10:24,719
stringa W verso una tripla grafo

1373
01:10:24,719 --> 01:10:29,480
sorgente targets. Tempo ne abbiamo. Sì,

1374
01:10:29,480 --> 01:10:30,760
eh.

1375
01:10:30,760 --> 01:10:32,280
E a questo punto possiamo fare delle

1376
01:10:32,280 --> 01:10:34,719
considerazioni. Sono considerazioni che

1377
01:10:34,719 --> 01:10:36,400
avevamo già fatto per il teorema di

1378
01:10:36,400 --> 01:10:38,800
Cook, quindi vado un attimo più veloce

1379
01:10:38,800 --> 01:10:42,800
per poi focalizzarci su sulla riduzione

1380
01:10:42,800 --> 01:10:45,480
in sé, perché questa riduzione produce

1381
01:10:45,480 --> 01:10:47,120
grafi e non formule buule, quindi

1382
01:10:47,120 --> 01:10:48,760
dobbiamo un attimo capire dove si

1383
01:10:48,760 --> 01:10:52,760
colloca. Avevamo osservato che noi anche

1384
01:10:52,760 --> 01:10:54,400
perché il teorema di Cook, avevamo

1385
01:10:54,400 --> 01:10:56,960
osservato che L è un linguaggio

1386
01:10:56,960 --> 01:10:58,719
generico, un linguaggio che non sappiamo

1387
01:10:58,719 --> 01:11:00,640
che cosa sia. Quindi non sappiamo se

1388
01:11:00,640 --> 01:11:01,840
sono forme, non sappiamo se sono

1389
01:11:01,840 --> 01:11:03,560
grafiche, non sappiamo niente. Sappiamo

1390
01:11:03,560 --> 01:11:07,920
che le istanze di L sono stringhe

1391
01:11:07,920 --> 01:11:10,880
e noi queste stringhe vanno trasformate

1392
01:11:10,880 --> 01:11:14,040
in dei grafi tale per cui se W

1393
01:11:14,040 --> 01:11:16,560
appartiene a L nel grafo G c'è un pat da

1394
01:11:16,560 --> 01:11:19,560
S a T. Se W non appartiene a L nel grafo

1395
01:11:19,560 --> 01:11:22,840
G non ci deve stare un pat da S a T. Ok?

1396
01:11:22,840 --> 01:11:24,920
Bello rognoso sta cosa perché noi d L

1397
01:11:24,920 --> 01:11:26,920
non sappiamo niente. Come abbiamo

1398
01:11:26,920 --> 01:11:29,560
superato questa cosa per il teorema? Sul

1399
01:11:29,560 --> 01:11:31,760
teorema di Cook abbiamo detto di n

1400
01:11:31,760 --> 01:11:35,360
sappiamo niente. Sappiamo che cosa? Che

1401
01:11:35,360 --> 01:11:37,639
esiste una macchina non deterministica

1402
01:11:37,639 --> 01:11:40,080
che in tempo polinomiale

1403
01:11:40,080 --> 01:11:41,679
decide il linguaggio e quindi qui ci

1404
01:11:41,679 --> 01:11:44,159
siamo inventati tutto quel gran casino

1405
01:11:44,159 --> 01:11:46,480
per far vedere che il funzionamento di

1406
01:11:46,480 --> 01:11:49,159
quella macchina non deterministica

1407
01:11:49,159 --> 01:11:51,480
poteva essere codificato all'interno di

1408
01:11:51,480 --> 01:11:53,760
una formula bulearca. Qua dobbiamo fare

1409
01:11:53,760 --> 01:11:56,960
una cosa simile. Il funzionamento di una

1410
01:11:56,960 --> 01:12:00,840
macchina NL che decide

1411
01:12:00,840 --> 01:12:03,719
Linguaggio L va trasformato in un

1412
01:12:03,719 --> 01:12:07,040
grafico. Questa è una cosa. Ok? In

1413
01:12:07,040 --> 01:12:09,040
realtà è più semplice di quello che

1414
01:12:09,040 --> 01:12:10,960
abbiamo visto per il teorema di Cook,

1415
01:12:10,960 --> 01:12:13,239
infatti spero che in 20 minuti ce la

1416
01:12:13,239 --> 01:12:15,520
facciamo. Ok?

1417
01:12:15,520 --> 01:12:18,800
Allora, andiamo per intuizione.

1418
01:12:18,800 --> 01:12:20,880
Cosa facevamo sul teorema di Cook? Noi

1419
01:12:20,880 --> 01:12:22,800
avevamo che nella formula buleana

1420
01:12:22,800 --> 01:12:25,520
dovevamo codificare sostanzialmente le

1421
01:12:25,520 --> 01:12:27,360
configurazioni della macchina, i

1422
01:12:27,360 --> 01:12:30,120
passaggi, questo step, quest'altro step,

1423
01:12:30,120 --> 01:12:32,560
eccetera. Qui facciamo una cosa simile,

1424
01:12:32,560 --> 01:12:35,080
però dobbiamo sfruttare il fatto che

1425
01:12:35,080 --> 01:12:38,320
l'istanza di arrivo ha un grafo.

1426
01:12:38,320 --> 01:12:39,880
Che ci andiamo a ficcare in questo

1427
01:12:39,880 --> 01:12:41,920
grafo. Vi do l'intuizione prima e poi

1428
01:12:41,920 --> 01:12:45,440
vediamo come si fa.

1429
01:12:45,440 --> 01:12:47,320
I nodi

1430
01:12:47,320 --> 01:12:50,639
del grafo G

1431
01:12:50,639 --> 01:12:52,480
rappresenteranno,

1432
01:12:52,480 --> 01:12:55,679
cioè noi andremo a costruire un grafo G

1433
01:12:55,679 --> 01:13:01,800
i cui nodi saranno le configurazioni

1434
01:13:01,800 --> 01:13:07,159
della macchina M sulla stringa W.

1435
01:13:07,520 --> 01:13:12,080
Quindi i nodi di G ci diranno a che

1436
01:13:12,080 --> 01:13:14,600
punto della computazione

1437
01:13:14,600 --> 01:13:19,400
la macchina M che decide L è, mentre

1438
01:13:19,400 --> 01:13:23,560
esegue su B. Quindi i nodi sono le foto.

1439
01:13:23,560 --> 01:13:26,040
Nei nodi abbiamo le foto. A che punto è

1440
01:13:26,040 --> 01:13:29,239
la computazione. Quelli sono i nodi. I

1441
01:13:29,239 --> 01:13:33,639
nodi verranno collegati da archi

1442
01:13:33,639 --> 01:13:38,080
se uno stato è il legal successor del

1443
01:13:38,080 --> 01:13:41,320
precedente. Tutto qua. Dopodiché dentro

1444
01:13:41,320 --> 01:13:44,040
questo grafo avremo la foto dello stato

1445
01:13:44,040 --> 01:13:47,000
iniziale e la foto del target e potremo

1446
01:13:47,000 --> 01:13:49,120
andare dallo stato iniziale a quello

1447
01:13:49,120 --> 01:13:51,800
finale solamente se quello è accettante.

1448
01:13:51,800 --> 01:13:54,440
Tutto qua. Ok, questa è l'idea che ci

1449
01:13:54,440 --> 01:13:56,159
sta. Adesso però dobbiamo trovare il

1450
01:13:56,159 --> 01:13:58,920
modo di farlo. Ok? È chiaro qual è

1451
01:13:58,920 --> 01:14:01,800
l'obiettivo? Dovremmo generare un grafo

1452
01:14:01,800 --> 01:14:03,840
che ha tanti nodi quanti sono i

1453
01:14:03,840 --> 01:14:05,920
possibili stati di funzionamento della

1454
01:14:05,920 --> 01:14:10,120
macchina M su W. Quei nodi li andiamo a

1455
01:14:10,120 --> 01:14:12,080
collegare in base alla funzione di

1456
01:14:12,080 --> 01:14:14,960
transizione.

1457
01:14:14,960 --> 01:14:18,719
La parte trichi di tutto ciò è che

1458
01:14:18,719 --> 01:14:21,400
questo vada fatto in in spazio

1459
01:14:21,400 --> 01:14:24,760
logaritmico deterministico, quindi non è

1460
01:14:24,760 --> 01:14:26,639
che lo possiamo generare tutto quel

1461
01:14:26,639 --> 01:14:29,440
grafo e tenerlo su memoria di lavoro

1462
01:14:29,440 --> 01:14:31,679
perché occuperebbe troppo spazio. Quindi

1463
01:14:31,679 --> 01:14:34,320
noi tra virgolette dobbiamo generare su

1464
01:14:34,320 --> 01:14:36,280
un nastro di output, cioè questa

1465
01:14:36,280 --> 01:14:38,320
funzione futa

1466
01:14:38,320 --> 01:14:40,840
sul proprio nastro di output, la tripla

1467
01:14:40,840 --> 01:14:44,360
GST non può mantenere nella propria

1468
01:14:44,360 --> 01:14:47,840
memoria di lavoro pezzi di grafo intero,

1469
01:14:47,840 --> 01:14:50,840
occupa troppo spazio. Possiamo tenere

1470
01:14:50,840 --> 01:14:53,360
cose intermedie

1471
01:14:53,360 --> 01:14:56,840
e dobbiamo sputare in output qualcosa

1472
01:14:56,840 --> 01:14:59,560
che noi sappiamo essere corretto già nel

1473
01:14:59,560 --> 01:15:01,960
momento in cui lo stiamo scrivendo.

1474
01:15:01,960 --> 01:15:03,560
Questa è la cosa, ok? È la parte

1475
01:15:03,560 --> 01:15:05,280
difficile perché non possiamo tenere in

1476
01:15:05,280 --> 01:15:08,719
memoria il grafo, occupa troppo spazio.

1477
01:15:08,719 --> 01:15:10,360
Allora,

1478
01:15:10,360 --> 01:15:13,880
facciamo così.

1479
01:15:14,239 --> 01:15:17,960
Qua metto il coso e poi pagina no.

1480
01:15:17,960 --> 01:15:22,280
Vi dicevo che a noi servono tanti nodi

1481
01:15:22,280 --> 01:15:25,560
quanti sono i nodi, quanti sono le

1482
01:15:25,560 --> 01:15:28,400
possibili foto, abbiamo detto del

1483
01:15:28,400 --> 01:15:30,280
nastro,

1484
01:15:30,280 --> 01:15:32,000
eh

1485
01:15:32,000 --> 01:15:34,000
le foto della computazione, dello stato

1486
01:15:34,000 --> 01:15:37,639
di computazione della macchina M. Ok?

1487
01:15:37,639 --> 01:15:40,040
Allora, vi ricordo che questa macchina M

1488
01:15:40,040 --> 01:15:42,080
è una macchina particolare il cui nastro

1489
01:15:42,080 --> 01:15:45,199
di input non può essere scritto.

1490
01:15:45,199 --> 01:15:46,520
Ok?

1491
01:15:46,520 --> 01:15:49,639
Di conseguenza,

1492
01:15:49,639 --> 01:15:51,560
la caratterizzazione

1493
01:15:51,560 --> 01:15:54,000
delle possibili condizioni in cui si

1494
01:15:54,000 --> 01:15:57,560
trovi la computazione di M su W sono

1495
01:15:57,560 --> 01:16:01,239
caratterizzate da quali elementi?

1496
01:16:01,239 --> 01:16:04,120
La il nastro di input rimane sempre lo

1497
01:16:04,120 --> 01:16:06,960
stesso, quindi non è caratterizzante.

1498
01:16:06,960 --> 01:16:09,600
Quello che caratterizza è dove sta la

1499
01:16:09,600 --> 01:16:11,520
testina,

1500
01:16:11,520 --> 01:16:14,719
quindi la posizione della testina sul

1501
01:16:14,719 --> 01:16:17,280
nastro di input, ma non il suo

1502
01:16:17,280 --> 01:16:19,360
contenuto, perché quello rimarrebbe

1503
01:16:19,360 --> 01:16:22,440
costante in tutte tutte le ID. Quindi

1504
01:16:22,440 --> 01:16:25,840
non è necessario generare nodi in questo

1505
01:16:25,840 --> 01:16:29,000
grafo G che prendono in considerazione

1506
01:16:29,000 --> 01:16:31,960
il fatto che il contenuto del nostro

1507
01:16:31,960 --> 01:16:34,199
input cambi. No, quello non c'è bisogno.

1508
01:16:34,199 --> 01:16:36,280
Dobbiamo considerare che la testina sul

1509
01:16:36,280 --> 01:16:38,280
nastro di input può essere in posizioni

1510
01:16:38,280 --> 01:16:40,920
diverse, ma non che il contenuto cambi,

1511
01:16:40,920 --> 01:16:44,520
non è caratterizzante. Ok? Quindi,

1512
01:16:44,520 --> 01:16:46,360
quali informazioni ci servono per

1513
01:16:46,360 --> 01:16:49,440
stabilire a che punto del guado la

1514
01:16:49,440 --> 01:16:51,480
macchina M è?

1515
01:16:51,480 --> 01:16:55,679
Dove sta la testina sul nastro di input?

1516
01:16:55,679 --> 01:16:57,760
Il contenuto del nastro di lavoro,

1517
01:16:57,760 --> 01:17:00,679
perché quello può essere scritto, dove

1518
01:17:00,679 --> 01:17:04,400
sta la testina sul nastro di lavoro

1519
01:17:04,400 --> 01:17:07,280
e lo stato corrente di computazione, se

1520
01:17:07,280 --> 01:17:10,080
siamo in Q4, se siamo in Q11, eccetera.

1521
01:17:10,080 --> 01:17:12,199
Ok?

1522
01:17:12,199 --> 01:17:16,320
Quindi questa foto

1523
01:17:16,320 --> 01:17:19,960
del dello stato corrente della

1524
01:17:19,960 --> 01:17:22,800
computazione è caratterizzato potrebbe

1525
01:17:22,800 --> 01:17:25,400
essere scritta su una stringa di questo

1526
01:17:25,400 --> 01:17:28,400
tipo.

1527
01:17:32,920 --> 01:17:36,400
Quindi una stringa la cui parte iniziale

1528
01:17:36,400 --> 01:17:40,280
contiene il contiene il contenuto del

1529
01:17:40,280 --> 01:17:44,400
nastro di lavoro di M

1530
01:17:45,280 --> 01:17:51,600
H1 e H2 che sono le posizioni. Sono dei

1531
01:17:51,600 --> 01:17:54,120
numeri. Dice la testina sul primo nastro

1532
01:17:54,120 --> 01:17:56,280
alla cella 15, la testina sul secondo

1533
01:17:56,280 --> 01:18:00,880
nastro sta alla cella 170. Ok? e poi un

1534
01:18:00,880 --> 01:18:04,440
codice Q per dirci in quale stato siamo,

1535
01:18:04,440 --> 01:18:07,639
Q3, Q4, Q58,

1536
01:18:07,639 --> 01:18:11,920
eccetera. Ok? È chiaro? Quindi questa è

1537
01:18:11,920 --> 01:18:13,480
l'informazione.

1538
01:18:13,480 --> 01:18:17,080
Se in questa stringa noi scriviamo

1539
01:18:17,080 --> 01:18:19,080
queste informazioni così come ce le

1540
01:18:19,080 --> 01:18:22,199
siamo dette, noi siamo in grado di

1541
01:18:22,199 --> 01:18:24,920
stabilire a che punto del calcolo la

1542
01:18:24,920 --> 01:18:29,000
macchina M. È chiaro?

1543
01:18:29,000 --> 01:18:31,480
Questa stringa è una stringa di simboli

1544
01:18:31,480 --> 01:18:34,719
miei principi.

1545
01:18:34,719 --> 01:18:36,159
Gli possiamo dare il significato che

1546
01:18:36,159 --> 01:18:38,000
vogliamo.

1547
01:18:38,000 --> 01:18:42,520
Può essere il nome dei nodi in G.

1548
01:18:43,120 --> 01:18:45,800
Noi utilizziamo questa stringa come la

1549
01:18:45,800 --> 01:18:49,719
label dei nodi di G. Quindi la label dei

1550
01:18:49,719 --> 01:18:53,159
nodi in G ci dirà cosa c'è su workday,

1551
01:18:53,159 --> 01:18:54,920
dove sta la testina di primo nastro,

1552
01:18:54,920 --> 01:18:57,080
dove sta la sina di secondo nastro, in

1553
01:18:57,080 --> 01:19:00,480
quale stato la macchina.

1554
01:19:00,480 --> 01:19:02,719
È chiaro? Cioè, noi facciamo sto trucco,

1555
01:19:02,719 --> 01:19:04,679
questa cosa di Ma sai che sta

1556
01:19:04,679 --> 01:19:06,639
configurazione io la uso per dare il

1557
01:19:06,639 --> 01:19:10,719
nome ai nodi di G?

1558
01:19:11,080 --> 01:19:14,760
Adesso se io prendo inizio a dare

1559
01:19:14,760 --> 01:19:17,880
simboli a questa stringa, alcune saranno

1560
01:19:17,880 --> 01:19:20,440
sensate, altre saranno non sensate. Nel

1561
01:19:20,440 --> 01:19:22,280
momento in cui le generiamo, facciamo un

1562
01:19:22,280 --> 01:19:24,199
check per vedere se stiamo buttando

1563
01:19:24,199 --> 01:19:27,400
fuori spazzatura o meno. Sì, prego.
Ti

1564
01:19:27,400 --> 01:19:29,280
scusi, ma la stringa che abbiamo

1565
01:19:29,280 --> 01:19:32,920
costruito è è la nostra assunzione? Al

1566
01:19:32,920 --> 01:19:34,320
momento stiamo solo facendo delle

1567
01:19:34,320 --> 01:19:36,639
considerazioni su quale informazione ci

1568
01:19:36,639 --> 01:19:40,080
serve per catturare lo stato di

1569
01:19:40,080 --> 01:19:42,880
avanzamento dei lavori di N. Dobbiamo

1570
01:19:42,880 --> 01:19:45,320
sapere cosa c'è sul nastro di lavoro,

1571
01:19:45,320 --> 01:19:47,320
dove stanno le due testine e in quale

1572
01:19:47,320 --> 01:19:49,000
stato si trovi la luce.
Quindi per

1573
01:19:49,000 --> 01:19:50,840
adesso siamo ancora nella fase di idea.

1574
01:19:50,840 --> 01:19:54,880
Ideaidea. Fase diidea. Ok.

1575
01:19:54,880 --> 01:20:00,320
Allora, la macchina M che decide L,

1576
01:20:01,480 --> 01:20:05,080
la macchina M che decide L è una

1577
01:20:05,080 --> 01:20:09,040
macchina in quale classe di complessità?

1578
01:20:09,040 --> 01:20:12,320
NL. Quanto spazio usa?

1579
01:20:12,320 --> 01:20:14,600
Log space. Quindi questo quanto spazio

1580
01:20:14,600 --> 01:20:16,880
è?

1581
01:20:16,880 --> 01:20:20,679
Logaritmo di n

1582
01:20:20,679 --> 01:20:25,080
log n è la lunghezza di W. Ok.

1583
01:20:31,080 --> 01:20:34,560
Quanto occupa?

1584
01:20:34,560 --> 01:20:37,000
Scriviamo qua.

1585
01:20:37,000 --> 01:20:42,920
Quanto occupa l'indice sul primo nastro?

1586
01:20:45,600 --> 01:20:50,480
È un numero. Quindi la 18ª cella. Quanto

1587
01:20:50,480 --> 01:20:54,120
quanto bit ci servono?

1588
01:20:54,120 --> 01:20:57,199
logaritmo di sotto
e quindi in generale

1589
01:20:57,199 --> 01:20:59,239
se la lunghezza del nostro input n

1590
01:20:59,239 --> 01:21:01,679
quanti bit ci servono per indicizzare le

1591
01:21:01,679 --> 01:21:04,719
celle su input
logaritmo
logaritmo di n

1592
01:21:04,719 --> 01:21:09,320
quindi qua abbiamo o di log n

1593
01:21:09,600 --> 01:21:13,400
questo qua h2
questo qua

1594
01:21:13,400 --> 01:21:17,159
quasi
è log di log
log di log perché

1595
01:21:17,159 --> 01:21:20,320
abbi dobbiamo indicizzare un nastro di

1596
01:21:20,320 --> 01:21:22,480
taglia logaritmica quindi qua Qua sotto

1597
01:21:22,480 --> 01:21:25,800
siamo o di log

1598
01:21:25,800 --> 01:21:27,480
n.

1599
01:21:27,480 --> 01:21:31,960
Ok. Numero di stati.

1600
01:21:33,400 --> 01:21:36,480
Quanto spazio ci serve per indigizzare

1601
01:21:36,480 --> 01:21:40,960
per nominare gli stati? Eh,

1602
01:21:40,960 --> 01:21:43,960
sicuri

1603
01:21:45,239 --> 01:21:48,120
logaritmico sul numero di stati, però

1604
01:21:48,120 --> 01:21:52,440
no. Attenzione, prego.
Che sia relativo

1605
01:21:52,440 --> 01:21:55,280
all'ap, quindi direi
No, no, no, sono

1606
01:21:55,280 --> 01:22:01,239
gli stati della macchina M che sono

1607
01:22:03,960 --> 01:22:07,480
numero.
E questo numero com'è?

1608
01:22:07,480 --> 01:22:10,239
È fissato. Sì. Il numero di stati della

1609
01:22:10,239 --> 01:22:12,000
macchina non cambia rispetto all'input,

1610
01:22:12,000 --> 01:22:13,920
quindi il numero di bit che ci servono

1611
01:22:13,920 --> 01:22:18,520
per rappresentare Q è una costante.

1612
01:22:18,520 --> 01:22:21,280
Ok? Quindi, se prendiamo questa stringa

1613
01:22:21,280 --> 01:22:24,440
rappresentativa, quanto spazio ci serve

1614
01:22:24,440 --> 01:22:27,880
per scriverla?

1615
01:22:28,400 --> 01:22:32,000
Log
log. Ok? Quindi noi siamo in grado

1616
01:22:32,000 --> 01:22:35,960
di scrivere questa stringa con l'ad n.

1617
01:22:35,960 --> 01:22:38,600
Ok?

1618
01:22:38,600 --> 01:22:42,880
Allora, la nostra idea era ora qual è? È

1619
01:22:42,880 --> 01:22:45,000
sputare perché noi stiamo definendo la

1620
01:22:45,000 --> 01:22:48,040
funzione di trasformazione fia b e tira

1621
01:22:48,040 --> 01:22:50,000
fuori gst.

1622
01:22:50,000 --> 01:22:52,920
Dobbiamo far vedere ora la funzione fare

1623
01:22:52,920 --> 01:22:56,360
fuori questa questo grafo. Ok? Allora,

1624
01:22:56,360 --> 01:23:00,920
il principio che usa è questo.

1625
01:23:02,960 --> 01:23:05,199
Ricordo che noi sostanzialmente dovremo

1626
01:23:05,199 --> 01:23:08,840
definire un grafo fatto così. I suoi

1627
01:23:08,840 --> 01:23:13,400
nodi sono tanti quanti le label, quelle

1628
01:23:13,400 --> 01:23:15,520
label.

1629
01:23:15,520 --> 01:23:21,320
Gli archi verranno messi fra nodi

1630
01:23:21,320 --> 01:23:23,400
che sono uno illegal successor

1631
01:23:23,400 --> 01:23:25,600
dell'altro secondo la funzione di

1632
01:23:25,600 --> 01:23:28,600
transizione.

1633
01:23:28,800 --> 01:23:30,920
Le configurazioni,

1634
01:23:30,920 --> 01:23:33,520
i nodi relativi a configurazioni

1635
01:23:33,520 --> 01:23:36,800
accettate verranno agganciate a un nodo

1636
01:23:36,800 --> 01:23:38,400
extra

1637
01:23:38,400 --> 01:23:42,440
che chiameremo T. Il nodo S è il nodo

1638
01:23:42,440 --> 01:23:44,120
relativo alla configurazione iniziale

1639
01:23:44,120 --> 01:23:46,719
della macchina. Tutto qua. Ok? Questa

1640
01:23:46,719 --> 01:23:48,600
cosa però va fatto in spazio

1641
01:23:48,600 --> 01:23:51,000
logaritmico, quindi dobbiamo riciclare

1642
01:23:51,000 --> 01:23:55,440
roba. Cosa fa questo trasduttore F? per

1643
01:23:55,440 --> 01:23:57,320
riuscire a generare, perché il grafo che

1644
01:23:57,320 --> 01:24:00,159
genera è bello grosso, eh, perché noi

1645
01:24:00,159 --> 01:24:04,000
abbiamo che questo qui

1646
01:24:04,000 --> 01:24:08,239
è il nome dei nodi,

1647
01:24:08,239 --> 01:24:10,880
quindi tutti i possibili nodi sono tutte

1648
01:24:10,880 --> 01:24:12,639
le possibili stringhe che hanno questa

1649
01:24:12,639 --> 01:24:17,560
forma, no? E quante sono?

1650
01:24:24,679 --> 01:24:27,840
Sì, noi dobbiamo generare

1651
01:24:27,840 --> 01:24:32,520
un grafo G i cui nodi hanno i nomi,

1652
01:24:32,520 --> 01:24:35,159
tutti i possibili nomi che si possono

1653
01:24:35,159 --> 01:24:36,920
costruire su una stringa che ha questa

1654
01:24:36,920 --> 01:24:41,320
forma. Quanti sono?

1655
01:24:42,719 --> 01:24:46,520
Attenzione, attenzione.

1656
01:24:47,360 --> 01:24:49,639
No,

1657
01:24:49,639 --> 01:24:52,880
abbiamo una stringa di 5 bit. Quante

1658
01:24:52,880 --> 01:24:56,719
sono le stringhe di 5 bit?

1659
01:24:56,719 --> 01:25:00,080
2^ qu. Abbiamo una stringa di 10 bit.

1660
01:25:00,080 --> 01:25:03,280
Quante sono le stringhe di 10 bit?

1661
01:25:03,280 --> 01:25:06,400
Abbiamo una stringa di 12

1662
01:25:06,400 --> 01:25:09,360
simboli ternari. Quante sono?

1663
01:25:09,360 --> 01:25:13,360
3^ 12
3^ 12 Quindi noi abbiamo Quante

1664
01:25:13,360 --> 01:25:18,080
sono le stringhe costruibili qua sopra?

1665
01:25:18,080 --> 01:25:23,440
2^ log n su n.
Sì, sarebbe una costante

1666
01:25:23,440 --> 01:25:27,000
che è la taglia dell'alfabeto

1667
01:25:27,000 --> 01:25:30,440
eh per la taglia di questa stringa.

1668
01:25:30,440 --> 01:25:33,679
Quindi noi avremo che il numero totale

1669
01:25:33,679 --> 01:25:35,880
dei dei nomi che hanno questa forma,

1670
01:25:35,880 --> 01:25:37,440
cioè quindi il numero totale che dei

1671
01:25:37,440 --> 01:25:40,800
nodi che vanno a finire in G è un

1672
01:25:40,800 --> 01:25:43,760
esponenziale rispetto a questa taglia.

1673
01:25:43,760 --> 01:25:47,360
Ma questa taglia è logaritmica

1674
01:25:47,360 --> 01:25:51,239
nella taglia di w, perciò avremo un

1675
01:25:51,239 --> 01:25:55,040
polinomio nella taglia di W. Ma se

1676
01:25:55,040 --> 01:25:57,239
quello è un polinomio nella taglia di W,

1677
01:25:57,239 --> 01:25:59,400
mica può finire tutto nel work tape di

1678
01:25:59,400 --> 01:26:01,800
F, non abbiamo spazio, eh. Quindi noi

1679
01:26:01,800 --> 01:26:03,600
questo grafo non è che lo possiamo

1680
01:26:03,600 --> 01:26:05,280
piazzare tutto là, poi quando siamo

1681
01:26:05,280 --> 01:26:08,880
sicuri lo soriniamo, no? va costruito

1682
01:26:08,880 --> 01:26:12,000
pezzo a pezzo e buttato fuori. Allora,

1683
01:26:12,000 --> 01:26:15,920
facciamo in questo modo.

1684
01:26:15,920 --> 01:26:18,880
Praticamente la macchina, il trasduttore

1685
01:26:18,880 --> 01:26:21,880
che fa F, fa questa cosa qua. Si prende

1686
01:26:21,880 --> 01:26:24,119
quella stringa lì, no, con tutti i

1687
01:26:24,119 --> 01:26:28,600
campi, come abbiamo visto, eccetera.

1688
01:26:29,480 --> 01:26:32,360
Vi do l'intuizione di come si fa. Eh,

1689
01:26:32,360 --> 01:26:35,280
poi penso che sugli appunti di Calauti

1690
01:26:35,280 --> 01:26:37,040
sia più preciso, però visti le

1691
01:26:37,040 --> 01:26:40,600
tempistiche cerco di farvi capire.

1692
01:26:40,600 --> 01:26:44,679
Sostanzialmente la macchina F questo,

1693
01:26:44,679 --> 01:26:48,480
istanzia una di questa stringa

1694
01:26:48,480 --> 01:26:52,360
sul nastro di lavoro

1695
01:26:53,480 --> 01:26:57,360
e fa questo check.

1696
01:26:57,639 --> 01:27:00,119
Questa stringa è qualcosa di sensato

1697
01:27:00,119 --> 01:27:03,400
perché per esempio come posizione

1698
01:27:03,400 --> 01:27:06,320
delle testine e come nome dei stati

1699
01:27:06,320 --> 01:27:07,840
potrebbero comparire simboli che non

1700
01:27:07,840 --> 01:27:09,679
c'entrano assolutamente niente perché la

1701
01:27:09,679 --> 01:27:11,880
la stringa la macchina che fa? Devo

1702
01:27:11,880 --> 01:27:16,239
generare stringhe di 137 simboli e io ne

1703
01:27:16,239 --> 01:27:18,360
inizio a generare tutte, però alcune di

1704
01:27:18,360 --> 01:27:20,880
queste sono senza senso. Quindi parto

1705
01:27:20,880 --> 01:27:23,400
dalla stringa 00,

1706
01:27:23,400 --> 01:27:28,840
poi parto da 00 stella, 00

1707
01:27:28,840 --> 01:27:31,440
casetta. Ok. Cioè io mi faccio come

1708
01:27:31,440 --> 01:27:33,520
faccio il conto? Vado avanti. Come li

1709
01:27:33,520 --> 01:27:35,560
avete visti i contachilometri, quelli

1710
01:27:35,560 --> 01:27:37,199
quelli digitali, quelli di una volta che

1711
01:27:37,199 --> 01:27:39,679
giravano. Io li faccio gira tutti, me le

1712
01:27:39,679 --> 01:27:41,520
faccio tutte le rappresentazioni.

1713
01:27:41,520 --> 01:27:45,080
Allora, la macchina F che fa F che fa?

1714
01:27:45,080 --> 01:27:47,239
Si prende questa string, se la mette su

1715
01:27:47,239 --> 01:27:49,520
work daye, quanto spazio occupa?

1716
01:27:49,520 --> 01:27:51,040
Logaritmico.

1717
01:27:51,040 --> 01:27:53,159
Inizia a ciclarsene,

1718
01:27:53,159 --> 01:27:56,840
quindi guarda la corrente. Ha senso, sì,

1719
01:27:56,840 --> 01:27:58,920
sputata in output, quello è un nodo.

1720
01:27:58,920 --> 01:28:01,560
Vado alla successiva. Ha senso, no?

1721
01:28:01,560 --> 01:28:03,239
Andiamo alla prossima. Guardo la

1722
01:28:03,239 --> 01:28:06,159
successiva. Ha senso sì, sputate in

1723
01:28:06,159 --> 01:28:10,560
output e così a poco a poco genero tutti

1724
01:28:10,560 --> 01:28:15,000
i nodi di G. Not che i nodi di G vengono

1725
01:28:15,000 --> 01:28:18,480
sputati in output senza essere tutti

1726
01:28:18,480 --> 01:28:22,480
presenti allo stesso momento sul nastro

1727
01:28:22,480 --> 01:28:24,760
di lavoro. È questo il trucco, cioè che

1728
01:28:24,760 --> 01:28:27,119
io non li posso tenere tutti assieme.

1729
01:28:27,119 --> 01:28:28,880
Quindi io c'ho questa stringa e la

1730
01:28:28,880 --> 01:28:31,840
ciclo. Vado avanti avanti e sputo fuori.

1731
01:28:31,840 --> 01:28:36,800
Ta ta ta. Ok, è chiaro? Finito questo

1732
01:28:36,800 --> 01:28:38,560
giro,

1733
01:28:38,560 --> 01:28:41,080
prendo una stringa e aggiungo un

1734
01:28:41,080 --> 01:28:42,800
simbolo,

1735
01:28:42,800 --> 01:28:44,360
escludo quest'ultimo nodo che lo

1736
01:28:44,360 --> 01:28:47,040
chiamiamo VDAR.

1737
01:28:47,040 --> 01:28:49,960
Questo sarà T, che è un nodo differente

1738
01:28:49,960 --> 01:28:51,679
da tutti gli altri perché perché c'è un

1739
01:28:51,679 --> 01:28:53,199
simbolo in più. Ok? Quindi è un nodo

1740
01:28:53,199 --> 01:28:55,080
speciale.

1741
01:28:55,080 --> 01:28:57,520
Cancelliamo tutto, ripuliamo il

1742
01:28:57,520 --> 01:29:01,239
worktake, ripartiamo stavolta con due

1743
01:29:01,239 --> 01:29:04,239
stringhe

1744
01:29:04,800 --> 01:29:08,880
e io le conto entrambe e però stavolta

1745
01:29:08,880 --> 01:29:11,000
faccio lo stesso giochino per fare cosa?

1746
01:29:11,000 --> 01:29:15,080
Per considerare tutte le coppie.

1747
01:29:15,080 --> 01:29:18,880
Che ci faccio con queste coppie? Simile.

1748
01:29:18,880 --> 01:29:21,520
La prima è sensata. Sì. La seconda è

1749
01:29:21,520 --> 01:29:24,600
sensata. Sì, la seconda è un legal

1750
01:29:24,600 --> 01:29:27,239
successor della prima. Sì, sputo la

1751
01:29:27,239 --> 01:29:29,679
coppia in output. Quella è un'arma.

1752
01:29:29,679 --> 01:29:31,840
Quando non verifico questa condizione,

1753
01:29:31,840 --> 01:29:33,840
vado alla successiva. Vi faccio notare

1754
01:29:33,840 --> 01:29:36,520
che il grafo non è mai presente

1755
01:29:36,520 --> 01:29:38,920
completamente

1756
01:29:38,920 --> 01:29:41,520
su worktape. Cioè, noi stiamo avanzando

1757
01:29:41,520 --> 01:29:43,880
contatori. Prego.
Ma possiamo fare

1758
01:29:43,880 --> 01:29:48,199
direttamente le coppie di fare prima i

1759
01:29:48,199 --> 01:29:50,400
figoli?
Si potrebbe anche fare. Sì, sì,

1760
01:29:50,400 --> 01:29:52,040
sì. Si potrebbe anche fare magari. in

1761
01:29:52,040 --> 01:29:54,080
una rappresentazione nella quale non c'è

1762
01:29:54,080 --> 01:29:55,920
una rappresentazione esplicita dei nodi,

1763
01:29:55,920 --> 01:29:57,639
ma abbiamo direttamente gli archi.

1764
01:29:57,639 --> 01:29:59,800
Quello si può fare, è una scelta tipo

1765
01:29:59,800 --> 01:30:01,440
sugli appunti di Cala che credo sia

1766
01:30:01,440 --> 01:30:04,159
fatto così. Ok?

1767
01:30:04,159 --> 01:30:07,960
Sì, prego.
Quindi, allora, prima i nodi.

1768
01:30:07,960 --> 01:30:10,080
Un secondo, un secondo. Finisco questo e

1769
01:30:10,080 --> 01:30:12,119
poi perché potremmo non aver tempo, poi

1770
01:30:12,119 --> 01:30:14,080
in caso mi fa la domanda. Ci siamo, che

1771
01:30:14,080 --> 01:30:17,480
facciamo? Usiamo cicliamo questa stringa

1772
01:30:17,480 --> 01:30:19,760
per sputare i nodi.

1773
01:30:19,760 --> 01:30:23,280
Cicliamo le e poi sputiamo VAR che è un

1774
01:30:23,280 --> 01:30:26,600
nodo con un nome speciale. Poi cicliamo

1775
01:30:26,600 --> 01:30:29,560
su tutte le coppie così su quelle

1776
01:30:29,560 --> 01:30:32,320
sensate mettiamo gli archi in output.

1777
01:30:32,320 --> 01:30:36,560
Ok? Cosa rimane da fare? Mentre cicliamo

1778
01:30:36,560 --> 01:30:38,920
queste, dopo che abbiamo fatto il ciclo

1779
01:30:38,920 --> 01:30:42,159
delle coppie, cancelliamo tutto,

1780
01:30:42,159 --> 01:30:45,440
rifacciamo il giochino dell'esplorazione

1781
01:30:45,440 --> 01:30:47,159
per andare a vedere quali sono le

1782
01:30:47,159 --> 01:30:50,800
configurazioni con uno stato accettante.

1783
01:30:50,800 --> 01:30:54,920
Quelle lì le agganciamo a Bostar,

1784
01:30:54,920 --> 01:30:56,560
ok? Perché dobbiamo fare tutto sto

1785
01:30:56,560 --> 01:30:58,440
gioco.

1786
01:30:58,440 --> 01:31:01,600
Abbiamo generato G,

1787
01:31:01,600 --> 01:31:03,679
vanno generate. È chiaro come G viene

1788
01:31:03,679 --> 01:31:05,159
generato?

1789
01:31:05,159 --> 01:31:07,280
Perché avremo dentro G ci sono tanti

1790
01:31:07,280 --> 01:31:11,119
nodi relativi a stati a configurazione

1791
01:31:11,119 --> 01:31:13,360
accettanti, ma noi il pat deve essere da

1792
01:31:13,360 --> 01:31:15,400
S verso un nodo specifico, quindi ne

1793
01:31:15,400 --> 01:31:17,400
mettiamo uno fettizio in maniera tale

1794
01:31:17,400 --> 01:31:19,239
che il pat è sempre verso il nodo

1795
01:31:19,239 --> 01:31:21,520
fittizio. Ok?

1796
01:31:21,520 --> 01:31:25,520
Generiamo il grafo. S è la è il nodo del

1797
01:31:25,520 --> 01:31:28,159
3G che è la configurazione iniziale

1798
01:31:28,159 --> 01:31:32,760
della partenza T e distante. Finito.

1799
01:31:32,760 --> 01:31:36,440
Per come è costruito questo grafo a un

1800
01:31:36,440 --> 01:31:43,960
pat da S a T? Se solo se m accetta w

1801
01:31:43,960 --> 01:31:47,280
e quindi siccome l era un linguaggio

1802
01:31:47,280 --> 01:31:50,080
generico che si riduce a ritability

1803
01:31:50,080 --> 01:31:56,400
allora avremo che richability è NL hard.

1804
01:31:56,400 --> 01:32:00,320
Chiaro? Sì.
Prego.
Ma dopo appena

1805
01:32:00,320 --> 01:32:02,520
analizzato le coppie
non vado avanti per

1806
01:32:02,520 --> 01:32:05,159
analizzare 30.
No, no, no. Le coppie ci

1807
01:32:05,159 --> 01:32:07,760
servono perché noi dobbiamo generare gli

1808
01:32:07,760 --> 01:32:10,320
archi del grafo e gli archi del grafo

1809
01:32:10,320 --> 01:32:12,880
sono coppie perché io devo devo poter

1810
01:32:12,880 --> 01:32:16,320
dire vado dal nodo 3 al modo 6, quindi

1811
01:32:16,320 --> 01:32:18,719
genero le coppie sono sensate. Uno è

1812
01:32:18,719 --> 01:32:21,880
successo l'altro sì. Allora lo

1813
01:32:21,880 --> 01:32:24,480
chiaro?

1814
01:32:24,480 --> 01:32:26,840
Prego. Star, cioè quindi lo star alla

1815
01:32:26,840 --> 01:32:32,560
fine viene messo in negli stati finali.

1816
01:32:32,560 --> 01:32:37,440
Star è un nodo specifico di G che riceve

1817
01:32:37,440 --> 01:32:40,000
come archi entranti

1818
01:32:40,000 --> 01:32:44,520
da tutti i nodi accettati.

1819
01:32:45,600 --> 01:32:48,400
E viene generato

1820
01:32:48,400 --> 01:32:51,159
generando un nodo aggiuntivo con una

1821
01:32:51,159 --> 01:32:53,040
stringa più lunga in maniera tale che

1822
01:32:53,040 --> 01:32:55,199
non sia nessuno degli altri che abbiamo

1823
01:32:55,199 --> 01:32:57,400
la certezza che non sia nessuno degli

1824
01:32:57,400 --> 01:33:00,080
altri. Ok?

1825
01:33:00,080 --> 01:33:03,159
Great guys.

1826
01:33:03,159 --> 01:33:07,239
Qua proprio eh.

1827
01:33:08,280 --> 01:33:11,400
Allora, fermato