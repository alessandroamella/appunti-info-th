1
00:00:05,160 --> 00:00:07,799
Ragazzi, iniziamo. Ah, scusate, oggi

2
00:00:07,799 --> 00:00:12,320
siamo stan cerco di tenermi un po'

3
00:00:12,320 --> 00:00:14,040
energico.

4
00:00:14,040 --> 00:00:15,639
Ok.

5
00:00:15,639 --> 00:00:17,720
Ok. Oggi iniziamo

6
00:00:17,720 --> 00:00:22,240
un topic completamente diverso.

7
00:00:22,240 --> 00:00:25,640
Ah! Ah! Oggi iniziamo

8
00:00:25,640 --> 00:00:28,800
complessità strutturale.

9
00:00:28,800 --> 00:00:31,400
Io lo trovo affascinante, ma la mia

10
00:00:31,400 --> 00:00:33,120
valutazione non conta perché è la mia

11
00:00:33,120 --> 00:00:35,840
area di ricerca e

12
00:00:35,840 --> 00:00:37,440
molti dei miei colleghi lo trovano

13
00:00:37,440 --> 00:00:40,480
veramente orrendo. Posso capirlo,

14
00:00:40,480 --> 00:00:44,200
a me diverte. Ok, quindi complessità

15
00:00:44,200 --> 00:00:46,199
strutturale, cos'è la complessità

16
00:00:46,199 --> 00:00:49,800
strutturale dei problemi? Ok, prima

17
00:00:49,800 --> 00:00:52,480
cosa, come sono andate

18
00:00:52,480 --> 00:00:57,120
le lezioni finora? Si capiva? Ok,

19
00:00:57,120 --> 00:01:00,160
sicuramente non avrete tutto chiaro o

20
00:01:00,160 --> 00:01:03,359
tutto disponibile al momento a richiamo,

21
00:01:03,359 --> 00:01:05,680
però vabbò è abbastanza naturale. Cose

22
00:01:05,680 --> 00:01:08,360
nuove, un po' troppi teoretici un

23
00:01:08,360 --> 00:01:11,640
attresso all'altro, insomma, that's al

24
00:01:11,640 --> 00:01:15,439
ok, come siete messi con la nozione di

25
00:01:15,439 --> 00:01:18,280
riduzione oggi? Non ne vediamo, però

26
00:01:18,280 --> 00:01:20,720
dalla prossima volta.

27
00:01:20,720 --> 00:01:23,479
Riduzioni. Riduzioni, ci siete? Ok,

28
00:01:23,479 --> 00:01:26,280
perché riduzioni ci servono, per seò

29
00:01:26,280 --> 00:01:28,320
complessità strutturale senza riduzioni

30
00:01:28,320 --> 00:01:31,479
è praticamente impossibile da fare. La

31
00:01:31,479 --> 00:01:33,560
nozione è identica. Aggiungeremo un

32
00:01:33,560 --> 00:01:35,399
pezzettino in più alla nozione di

33
00:01:35,399 --> 00:01:38,680
riduzione e il resto si si usa nello

34
00:01:38,680 --> 00:01:42,079
stessissimo modo.

35
00:01:42,079 --> 00:01:46,920
Ok? Quindi se finora

36
00:01:46,920 --> 00:01:51,320
facciamo il nostro solito disegnino,

37
00:01:51,960 --> 00:01:54,960
questo qua, qui c'abbiamo R,

38
00:01:54,960 --> 00:01:56,799
qua c'abbiamo R, poi abbiamo visto

39
00:01:56,799 --> 00:01:58,799
questa cosa un po' più sofisticata della

40
00:01:58,799 --> 00:02:01,799
classe C.

41
00:02:01,799 --> 00:02:04,920
Qui non la non la depict, non la

42
00:02:04,920 --> 00:02:07,560
dipingiamo, non la disegniamo. Ok,

43
00:02:07,560 --> 00:02:08,879
allora finora ci siamo. Quello che di

44
00:02:08,879 --> 00:02:10,959
qui ci siamo occupati finora

45
00:02:10,959 --> 00:02:13,560
sostanzialmente è dati dei linguaggi o

46
00:02:13,560 --> 00:02:16,000
dei problemi di decisione, stabilire se

47
00:02:16,000 --> 00:02:17,800
quel linguaggio stava qua, se stava qua,

48
00:02:17,800 --> 00:02:19,920
se stava qua fuori. L'ultima volta

49
00:02:19,920 --> 00:02:21,920
abbiamo visto se sta in co re, quindi se

50
00:02:21,920 --> 00:02:25,599
sono linguaggi complementari di R o se

51
00:02:25,599 --> 00:02:28,040
stanno fuori re e co re, quindi sono

52
00:02:28,040 --> 00:02:31,200
ancora più difficili. Ok, lì abbiamo una

53
00:02:31,200 --> 00:02:33,680
pletora di problemi difficili, c'è una

54
00:02:33,680 --> 00:02:36,239
scala di problemi sempre più difficili.

55
00:02:36,239 --> 00:02:38,840
Non non li guarderemo, a noi non

56
00:02:38,840 --> 00:02:41,400
interessa, ok? Eh, e sono argomenti

57
00:02:41,400 --> 00:02:43,480
sofisticati che riguardano la logica

58
00:02:43,480 --> 00:02:46,000
matematica. Se vi interessa, quello è il

59
00:02:46,000 --> 00:02:49,040
tipo di area che dovreste andare a a

60
00:02:49,040 --> 00:02:50,680
spulciare, che si chiama teoria della

61
00:02:50,680 --> 00:02:53,280
ricorsione. Ok? E lì si studiano questi

62
00:02:53,280 --> 00:02:57,200
problemi molto sofisticati,

63
00:02:57,200 --> 00:02:58,720
però da un punto di vista un po' più

64
00:02:58,720 --> 00:03:00,599
pratico, sebbene affascinante, la teoria

65
00:03:00,599 --> 00:03:02,360
è sempre affascinante, però da un punto

66
00:03:02,360 --> 00:03:04,879
di vista pratico, sapere se un problema

67
00:03:04,879 --> 00:03:06,799
è indecidibile o doppiamente

68
00:03:06,799 --> 00:03:11,080
indecidibile, insomma di un po'

69
00:03:11,080 --> 00:03:13,400
non così utile, però se quello è ci

70
00:03:13,400 --> 00:03:14,760
stanno, ci sta tutta una

71
00:03:14,760 --> 00:03:17,400
categorizzazione di problemi

72
00:03:17,400 --> 00:03:19,920
infinitamente complicati che noi non

73
00:03:19,920 --> 00:03:22,360
guarderemo, sono tutti fuori il re, for

74
00:03:22,360 --> 00:03:26,400
re, eccetera. Ok? Cioè si costruisce

75
00:03:26,400 --> 00:03:28,360
proprio a strati. Il problema che

76
00:03:28,360 --> 00:03:30,760
abbiamo visto l'altra volta, Halt per

77
00:03:30,760 --> 00:03:33,599
ogni sta in una classe a parte sua, il

78
00:03:33,599 --> 00:03:35,920
suo complemento sta in un'altra classe a

79
00:03:35,920 --> 00:03:38,200
parte. Allora poi uno si chiede ma c'è

80
00:03:38,200 --> 00:03:40,120
qualcosa che è al di fuori di quello?

81
00:03:40,120 --> 00:03:42,159
Sì, c sta e sono problemi ancora più

82
00:03:42,159 --> 00:03:44,680
difficili, però non non li andiamo a

83
00:03:44,680 --> 00:03:47,319
vedere. Quello di cui ci andremo a

84
00:03:47,319 --> 00:03:51,879
occupare da ora per il resto della

85
00:03:51,879 --> 00:03:54,959
del corso è sostanzialmente

86
00:03:54,959 --> 00:03:57,720
questo insieme qua. Ok? Noi ci andiamo

87
00:03:57,720 --> 00:04:01,680
ora a occupare dei problemi ricorsivi,

88
00:04:01,680 --> 00:04:04,360
dei problemi decidibili, ok? Perché

89
00:04:04,360 --> 00:04:06,079
abbiamo visto a sufficienza problemi

90
00:04:06,079 --> 00:04:07,680
indecidibili, abbiamo visto che ce ne

91
00:04:07,680 --> 00:04:10,959
stanno tanti, che sono belli tosti. Ok?

92
00:04:10,959 --> 00:04:12,439
C'è tutta un'area della ricerca

93
00:04:12,439 --> 00:04:14,519
dell'informatica teorica che invece si

94
00:04:14,519 --> 00:04:16,320
focalizza

95
00:04:16,320 --> 00:04:20,479
eh all'interno della classe R, ok? Cioè

96
00:04:20,479 --> 00:04:22,000
stabilire

97
00:04:22,000 --> 00:04:24,400
la complessità dei problemi dentro R.

98
00:04:24,400 --> 00:04:27,280
Allora, la questione è meramente di tipo

99
00:04:27,280 --> 00:04:30,000
storico perché nel momento in cui tutta

100
00:04:30,000 --> 00:04:32,680
questa teoria nacque, negli anni 30

101
00:04:32,680 --> 00:04:34,720
conturing, la teoria delle funzioni

102
00:04:34,720 --> 00:04:37,520
ricorsive in realtà predata, quello,

103
00:04:37,520 --> 00:04:40,199
però insomma le persone erano in quel

104
00:04:40,199 --> 00:04:43,280
momento abbastanza

105
00:04:43,280 --> 00:04:45,160
interessate dal capire se un problema

106
00:04:45,160 --> 00:04:47,919
fosse decidibile o meno. La questione è

107
00:04:47,919 --> 00:04:49,560
che a quel momento era in quel momento

108
00:04:49,560 --> 00:04:52,680
storico era tutto abbastanza astratto.

109
00:04:52,680 --> 00:04:54,520
Non ci stavano macchine reali di

110
00:04:54,520 --> 00:04:57,080
calcolo, a parte

111
00:04:57,080 --> 00:04:59,440
che ne so, la differenzial engine o

112
00:04:59,440 --> 00:05:01,600
l'analytical engine di Babac, ma la

113
00:05:01,600 --> 00:05:03,160
differenzial engine, per esempio, non

114
00:05:03,160 --> 00:05:05,080
era mai stata costruita. Un prototipo

115
00:05:05,080 --> 00:05:06,960
funzionante della differenzial engine è

116
00:05:06,960 --> 00:05:08,759
stata fatta di recente e si è visto che

117
00:05:08,759 --> 00:05:10,720
quella macchina avrebbe funzionato se

118
00:05:10,720 --> 00:05:12,840
qualcuno l'avesse costruito. Però

119
00:05:12,840 --> 00:05:15,000
macchine di calcolo sofisticate ci

120
00:05:15,000 --> 00:05:17,800
stavano negli anni 30 che ci stava?

121
00:05:17,800 --> 00:05:20,680
gestavano le macchine per il censimento

122
00:05:20,680 --> 00:05:22,199
automatico.

123
00:05:22,199 --> 00:05:23,600
Quelle erano macchine, però non è che

124
00:05:23,600 --> 00:05:25,400
sapevano far di conto, leggevano le

125
00:05:25,400 --> 00:05:28,000
schede perforate per fare le statistiche

126
00:05:28,000 --> 00:05:29,600
in maniera automatica, facevano dei

127
00:05:29,600 --> 00:05:32,440
conteggi, ma non erano programmabili. Le

128
00:05:32,440 --> 00:05:35,080
macchine programmabili erano macchine

129
00:05:35,080 --> 00:05:37,360
che stavano nella testa dei matematici,

130
00:05:37,360 --> 00:05:40,160
ok? Quindi non c'era nulla a

131
00:05:40,160 --> 00:05:42,960
disposizione e quello di cui ci

132
00:05:42,960 --> 00:05:45,479
chiedevano è ma questa macchina semmai

133
00:05:45,479 --> 00:05:47,960
fosse in grado di costruirla che genere

134
00:05:47,960 --> 00:05:50,039
di problemi sarebbe in grado di

135
00:05:50,039 --> 00:05:52,639
risolvere? E di fatto i primi i primi

136
00:05:52,639 --> 00:05:54,479
risultati di indecidibilità, no? Il

137
00:05:54,479 --> 00:05:59,000
problema dell'arresto che data 1935-36,

138
00:05:59,000 --> 00:06:02,000
se ricordo bene la parte di Turing

139
00:06:02,000 --> 00:06:03,520
riguardava una macchina astratta, cioè

140
00:06:03,520 --> 00:06:05,199
non è che questa macchina esisteva, però

141
00:06:05,199 --> 00:06:07,440
si sapeva già che sem mai fossimo stati

142
00:06:07,440 --> 00:06:09,240
in grado di costruirla ci sarebbero

143
00:06:09,240 --> 00:06:11,280
stati problemi che quella macchina non

144
00:06:11,280 --> 00:06:13,479
sarebbe stata in grado di risolvere. Ok?

145
00:06:13,479 --> 00:06:15,520
Quindi la gente più che altro si buttò

146
00:06:15,520 --> 00:06:17,599
su questa cosa, cosa è decidibile, cosa

147
00:06:17,599 --> 00:06:20,360
non cosa non è decidibile,

148
00:06:20,360 --> 00:06:24,680
tipo il teorema di Ris degli anni 50,

149
00:06:24,680 --> 00:06:27,160
quindi erano quel genere di cose che

150
00:06:27,160 --> 00:06:29,000
venivano

151
00:06:29,000 --> 00:06:31,199
venivano studiate. però con l'avanzare

152
00:06:31,199 --> 00:06:33,240
della tecnologia, quindi anni 40,

153
00:06:33,240 --> 00:06:35,160
seconda guerra mondiale, la

154
00:06:35,160 --> 00:06:37,080
disponibilità di calcolatori elettronici

155
00:06:37,080 --> 00:06:40,000
per il calcolo dei tracciati balistici

156
00:06:40,000 --> 00:06:43,400
eccetera, inizia iniziammo come genere

157
00:06:43,400 --> 00:06:46,800
umano ad avere i primi computer, i primi

158
00:06:46,800 --> 00:06:49,120
computer programmabili, i primi computer

159
00:06:49,120 --> 00:06:52,199
elettronici a valvole eccetera, tipo

160
00:06:52,199 --> 00:06:54,759
ENIAC, EDAC, queste cose qua, tale per

161
00:06:54,759 --> 00:06:59,120
cui iniziamo ad avere i primi programmi,

162
00:06:59,120 --> 00:07:00,280
ok?

163
00:07:00,280 --> 00:07:03,400
E mentre il

164
00:07:03,400 --> 00:07:05,879
la gente si scontrava con cosa si può

165
00:07:05,879 --> 00:07:08,479
calcolare o cosa non si può calcolare,

166
00:07:08,479 --> 00:07:10,039
nel momento in cui avevamo delle

167
00:07:10,039 --> 00:07:12,479
macchine fisiche, iniziò a diventare

168
00:07:12,479 --> 00:07:15,120
evidente che certi problemi li

169
00:07:15,120 --> 00:07:17,000
risolvevamo in poco tempo e altri

170
00:07:17,000 --> 00:07:18,840
problemi li risolvevamo in molto più

171
00:07:18,840 --> 00:07:21,800
tempo. Alcuni problemi richiedevano una

172
00:07:21,800 --> 00:07:24,000
grande quantità di memoria, altri

173
00:07:24,000 --> 00:07:26,360
problemi ne richiedevano molto meno. Ok?

174
00:07:26,360 --> 00:07:29,280
Quindi lo studio della complessità

175
00:07:29,280 --> 00:07:30,919
strutturale dei problemi che adesso

176
00:07:30,919 --> 00:07:32,759
definiremo in maniera un po' più preciso

177
00:07:32,759 --> 00:07:34,680
nasce da una questione meramente

178
00:07:34,680 --> 00:07:37,400
tecnologica, cioè in quel momento

179
00:07:37,400 --> 00:07:39,720
avevamo a disposizione delle macchine

180
00:07:39,720 --> 00:07:42,560
reali, la gente si è iniziata a chiedere

181
00:07:42,560 --> 00:07:44,879
"Ma questo problema in quanto tempo lo

182
00:07:44,879 --> 00:07:48,720
vedrò risolto?" Questa domanda nasce dal

183
00:07:48,720 --> 00:07:51,159
fatto che la macchina esisteva e quindi

184
00:07:51,159 --> 00:07:53,440
la gente si trovava lì ad aspettare la

185
00:07:53,440 --> 00:07:57,080
risposta. quando avevamo quando non

186
00:07:57,080 --> 00:07:59,840
c'erano le macchine, allora non era una

187
00:07:59,840 --> 00:08:01,000
questione che veniva presa in

188
00:08:01,000 --> 00:08:02,560
considerazione. Le persone si

189
00:08:02,560 --> 00:08:05,159
chiedevano: "Ok, è in grado di farlo?

190
00:08:05,159 --> 00:08:06,960
Non è in grado di farlo". Dopodiché,

191
00:08:06,960 --> 00:08:09,400
quando iniziarono veramente a

192
00:08:09,400 --> 00:08:11,400
programmare i primi computer, mi si

193
00:08:11,400 --> 00:08:13,280
resero conto che c'erano problemi molto

194
00:08:13,280 --> 00:08:15,479
più difficili di altri, cioè dei

195
00:08:15,479 --> 00:08:18,400
problemi che erano che richiedevano con

196
00:08:18,400 --> 00:08:21,319
gli algoritmi di cui disponevano molto

197
00:08:21,319 --> 00:08:24,240
più tempo di tanti altri algoritmi o di

198
00:08:24,240 --> 00:08:26,560
altri problemi. Ok? A quel punto la

199
00:08:26,560 --> 00:08:30,879
questione che nacque è: "Ma l'algoritmo

200
00:08:30,879 --> 00:08:32,760
che abbiamo per risolvere questo

201
00:08:32,760 --> 00:08:35,320
problema è lento? perché siamo noi che

202
00:08:35,320 --> 00:08:37,959
non siamo furbi a sufficienza da tirarne

203
00:08:37,959 --> 00:08:40,599
fuori uno veloce o la o il problema è

204
00:08:40,599 --> 00:08:42,240
talmente complicato che noi non

205
00:08:42,240 --> 00:08:44,200
riusciremo mai ad avere un algoritmo

206
00:08:44,200 --> 00:08:48,399
veloce. Ok? E quindi questa cosa venne

207
00:08:48,399 --> 00:08:50,360
formalizzata

208
00:08:50,360 --> 00:08:52,600
dopo un bel po' di tempo. I seminal

209
00:08:52,600 --> 00:08:54,800
paper in cui definirono la complessità

210
00:08:54,800 --> 00:08:56,800
computazionale delle macchine di touring

211
00:08:56,800 --> 00:08:59,560
sono del 1965.

212
00:08:59,560 --> 00:09:03,079
Sono tre lavori che hanno dato avvio

213
00:09:03,079 --> 00:09:04,519
allo studio della complessità

214
00:09:04,519 --> 00:09:08,600
strutturale. Gli autori erano Hartmanis,

215
00:09:08,600 --> 00:09:12,000
Stern e Lewis che scrissero tre lavori

216
00:09:12,000 --> 00:09:14,760
apparsi tutti nel 1965

217
00:09:14,760 --> 00:09:17,160
in cui descrivevano questa nozione, se

218
00:09:17,160 --> 00:09:18,880
avevano inventato questa nozione di

219
00:09:18,880 --> 00:09:21,200
complessità delle macchine, ok? Cioè,

220
00:09:21,200 --> 00:09:23,440
prima di allora questa idea non ci

221
00:09:23,440 --> 00:09:25,399
stava, magari le persone se n'erano pure

222
00:09:25,399 --> 00:09:27,279
accorte che serviva questo genere di

223
00:09:27,279 --> 00:09:30,160
nozione, ma fino a quella data non

224
00:09:30,160 --> 00:09:32,240
abbiamo una descrizione formale di

225
00:09:32,240 --> 00:09:34,839
questo concetto. Ok?

226
00:09:34,839 --> 00:09:37,160
Che cosa introdussero? Sostanzialmente

227
00:09:37,160 --> 00:09:39,240
loro introdussero il concetto di

228
00:09:39,240 --> 00:09:41,920
complessità temporale e complessità

229
00:09:41,920 --> 00:09:44,079
spaziale delle macchine di Turing che

230
00:09:44,079 --> 00:09:47,360
adesso definiremo in maniera un po' più

231
00:09:47,360 --> 00:09:51,120
precisa. semplicemente intuitivamente

232
00:09:51,120 --> 00:09:54,000
con questa nozione.

233
00:09:54,000 --> 00:09:56,040
La complessità temporale di una macchina

234
00:09:56,040 --> 00:09:58,320
di Touring è legata al numero di passi

235
00:09:58,320 --> 00:10:00,600
che la macchina fa prima di arrestarsi e

236
00:10:00,600 --> 00:10:03,160
dare la risposta. Ok? Questo era il

237
00:10:03,160 --> 00:10:05,560
senso sostanzialmente

238
00:10:05,560 --> 00:10:07,399
perché notarono, appunto, infatti se

239
00:10:07,399 --> 00:10:09,240
leggete l'introduzione di quel lavoro

240
00:10:09,240 --> 00:10:11,680
dice sì, notiamo che sui computer reali

241
00:10:11,680 --> 00:10:13,519
alcuni algoritmi girano più veloci,

242
00:10:13,519 --> 00:10:16,959
altri algoritmi girano più lenti.

243
00:10:16,959 --> 00:10:19,040
la necessità di sviluppare una teoria

244
00:10:19,040 --> 00:10:20,680
che tenga conto di questo, cioè fra

245
00:10:20,680 --> 00:10:22,760
tutti i problemi decidibili, quali sono

246
00:10:22,760 --> 00:10:24,200
quelli facili, quali sono quelli

247
00:10:24,200 --> 00:10:27,720
difficili e proposero quindi l'idea di

248
00:10:27,720 --> 00:10:30,360
caratterizzare la complessità

249
00:10:30,360 --> 00:10:32,760
temporale delle macchine di touring come

250
00:10:32,760 --> 00:10:35,480
contando il numero di steps. Ok? E

251
00:10:35,480 --> 00:10:37,440
questa cosa era abbastanza facile da

252
00:10:37,440 --> 00:10:39,399
definire perché la macchina in touring

253
00:10:39,399 --> 00:10:41,079
noi abbiamo i passaggi, i singoli

254
00:10:41,079 --> 00:10:43,360
passaggi, uno step, due step, tre step.

255
00:10:43,360 --> 00:10:44,880
Quindi quella cosa è molto facile da

256
00:10:44,880 --> 00:10:47,320
contare rispetto alla complessità

257
00:10:47,320 --> 00:10:49,880
computazionale di algoritmi che rannano

258
00:10:49,880 --> 00:10:51,959
su macchine reali e a quel punto è un

259
00:10:51,959 --> 00:10:53,839
po' difficile contare il numero di

260
00:10:53,839 --> 00:10:55,560
passaggi, ma su macchine di Touring è

261
00:10:55,560 --> 00:10:58,440
semplicissimo. Contiamo il numero di

262
00:10:58,440 --> 00:11:00,519
transizioni prima che la macchina si

263
00:11:00,519 --> 00:11:04,399
arresti in maniera similare, poi lo

264
00:11:04,399 --> 00:11:07,160
introdurremo però sì quando faremo

265
00:11:07,160 --> 00:11:09,200
complessità spaziale, oggi introduciamo

266
00:11:09,200 --> 00:11:11,480
solo complessità temporale, sempre in

267
00:11:11,480 --> 00:11:13,519
quegli anni introdussero, ve lo do

268
00:11:13,519 --> 00:11:14,959
intuitivamente, il concetto di

269
00:11:14,959 --> 00:11:17,360
complessità spaziale, nel senso ma

270
00:11:17,360 --> 00:11:20,760
quante celle la macchina deve leggere,

271
00:11:20,760 --> 00:11:23,079
no, o scrivere prima di dare la

272
00:11:23,079 --> 00:11:25,839
risposta, perché la complessità spaziale

273
00:11:25,839 --> 00:11:27,279
è una cosa sono un po' diverse perché io

274
00:11:27,279 --> 00:11:29,160
le celle le posso sovrascrivere, quindi

275
00:11:29,160 --> 00:11:30,880
magari sovrascrivendolo in maniera

276
00:11:30,880 --> 00:11:33,240
opportuna posso mantenere il numero di

277
00:11:33,240 --> 00:11:36,000
celle usate più piccolo e quello andava

278
00:11:36,000 --> 00:11:40,079
in qualche modo a to mimic a mimare, no,

279
00:11:40,079 --> 00:11:41,760
la quantità di memoria che era

280
00:11:41,760 --> 00:11:44,240
necessaria in un computer per poter

281
00:11:44,240 --> 00:11:47,639
risolvere un certo problema. Ok? Quindi

282
00:11:47,639 --> 00:11:49,600
il tutto nasce da una questione

283
00:11:49,600 --> 00:11:52,120
meramente tecnologica. Nel momento in

284
00:11:52,120 --> 00:11:54,639
cui avendo a disposizione macchine

285
00:11:54,639 --> 00:11:56,440
reali, le persone si iniziarono a

286
00:11:56,440 --> 00:11:58,399
chiedere "Ma com'è possibile che alcuni

287
00:11:58,399 --> 00:12:00,680
algoritmi vanno veloci e altri vanno

288
00:12:00,680 --> 00:12:03,120
lenti?" E allora iniziò tutto questo

289
00:12:03,120 --> 00:12:05,279
studio. Ok?

290
00:12:05,279 --> 00:12:08,279
Questo studio si chiama complessità

291
00:12:08,279 --> 00:12:10,240
strutturale

292
00:12:10,240 --> 00:12:14,000
perché ci vuole occupare della della

293
00:12:14,000 --> 00:12:16,240
complessità della struttura dei

294
00:12:16,240 --> 00:12:19,680
problemi, cioè com'è che la struttura di

295
00:12:19,680 --> 00:12:22,480
un problema influenza

296
00:12:22,480 --> 00:12:26,880
o meno la complessità degli algoritmi

297
00:12:26,880 --> 00:12:28,920
che lo risolvono. Voi avete visto nei

298
00:12:28,920 --> 00:12:31,040
corsi di algoritmi che gli algoritmi

299
00:12:31,040 --> 00:12:32,800
sono caratterizzati da una certa

300
00:12:32,800 --> 00:12:35,320
complessità. Quello che noi andremo a

301
00:12:35,320 --> 00:12:37,199
fare nelle lezioni a venire non è

302
00:12:37,199 --> 00:12:39,079
studiare la complessità degli algoritmi

303
00:12:39,079 --> 00:12:40,880
che comunque ci serve perché la

304
00:12:40,880 --> 00:12:43,040
complessità degli algoritmi viene usata

305
00:12:43,040 --> 00:12:45,079
come base per lo studio della

306
00:12:45,079 --> 00:12:47,560
complessità strutturale. Oggetto della

307
00:12:47,560 --> 00:12:49,880
complessità strutturale è ma qual è la

308
00:12:49,880 --> 00:12:52,959
complessità del problema? Questa è la

309
00:12:52,959 --> 00:12:55,040
differenza. Ok? Non ci interessiamo più

310
00:12:55,040 --> 00:12:58,040
del singolo algoritmo che risolve un

311
00:12:58,040 --> 00:13:01,240
certo problema. Noi ci

312
00:13:01,240 --> 00:13:03,680
interessiamo, vogliamo capire ma la

313
00:13:03,680 --> 00:13:06,839
struttura di questo problema come

314
00:13:06,839 --> 00:13:09,480
impatta la complessità degli algoritmi

315
00:13:09,480 --> 00:13:12,120
che lo risolvono? Questo problema è

316
00:13:12,120 --> 00:13:14,320
tosto di suo tale per cui tutti gli

317
00:13:14,320 --> 00:13:16,079
algoritmi che lo risolvono prenderanno

318
00:13:16,079 --> 00:13:18,160
sempre esponenziale. Questa è la

319
00:13:18,160 --> 00:13:20,160
domanda. Questa è la domanda che ci

320
00:13:20,160 --> 00:13:23,240
porremo da qui al termine del corso. Ok?

321
00:13:23,240 --> 00:13:26,240
studiare sostanzialmente da un problema,

322
00:13:26,240 --> 00:13:28,920
stabilire la famiglia

323
00:13:28,920 --> 00:13:32,120
di problemi dalle quali di complessità

324
00:13:32,120 --> 00:13:34,560
simile dalle quali questo problema viene

325
00:13:34,560 --> 00:13:37,480
preso. Ok?

326
00:13:37,480 --> 00:13:39,680
Quindi questo è un po' un po'

327
00:13:39,680 --> 00:13:41,680
l'introduzione, non è un argomento che

328
00:13:41,680 --> 00:13:45,320
in genere insomma la gente ci fa ricerca

329
00:13:45,320 --> 00:13:48,040
perché è abbastanza abbastanza teorico,

330
00:13:48,040 --> 00:13:51,240
però studiare la complessità strutturale

331
00:13:51,240 --> 00:13:53,839
dei problemi, ad esempio, ci permette di

332
00:13:53,839 --> 00:13:56,839
stabilire dove si annida la complessità

333
00:13:56,839 --> 00:13:59,320
del problema, cioè quale pezzo di questo

334
00:13:59,320 --> 00:14:02,120
problema lo rende difficile. E se io

335
00:14:02,120 --> 00:14:04,680
impongo dei constraint semplificatori su

336
00:14:04,680 --> 00:14:06,320
quella parte là, il problema diventa

337
00:14:06,320 --> 00:14:08,639
polinomiale. Quindi questo poi ci

338
00:14:08,639 --> 00:14:10,839
permette, per esempio, di sviluppare

339
00:14:10,839 --> 00:14:13,959
algoritmi euristici dove si possono fare

340
00:14:13,959 --> 00:14:16,360
delle assunzioni, eccetera. Ok? Quindi

341
00:14:16,360 --> 00:14:19,120
lo studio della complessità strutturale

342
00:14:19,120 --> 00:14:23,120
è uno studio che ci permette di capire

343
00:14:23,120 --> 00:14:26,279
dove si annidi la difficoltà dei

344
00:14:26,279 --> 00:14:28,959
problemi, ok? e questo ci dà

345
00:14:28,959 --> 00:14:30,720
informazioni sullo sviluppo di algoritmi

346
00:14:30,720 --> 00:14:33,279
per la loro risoluzione.

347
00:14:33,279 --> 00:14:36,399
Alrght? Allora, noi sostanzialmente

348
00:14:36,399 --> 00:14:39,639
quindi ci focalizzeremo

349
00:14:39,639 --> 00:14:43,240
su questo oggetto qui l'insieme dei

350
00:14:43,240 --> 00:14:46,199
problemi decidibili. Quindi da ora in

351
00:14:46,199 --> 00:14:48,560
poi tutti gli algoritmi di cui di cui

352
00:14:48,560 --> 00:14:51,000
parleremo sono algoritmi che decidono

353
00:14:51,000 --> 00:14:53,279
linguaggio. Quindi avremo sempre

354
00:14:53,279 --> 00:14:55,480
garanzia di risposta sì, avremo sempre

355
00:14:55,480 --> 00:14:57,639
garanzia di risposta no. Ok? Quindi sono

356
00:14:57,639 --> 00:14:59,480
algoritmi standard, quelli che avete

357
00:14:59,480 --> 00:15:01,600
sempre visto in tutti i corsi, cioè

358
00:15:01,600 --> 00:15:04,079
algoritmi veri e propri, una sequenza

359
00:15:04,079 --> 00:15:07,320
finita di passi che quindi finisce,

360
00:15:07,320 --> 00:15:10,360
termina sempre. Ok? Allora, l'obiettivo

361
00:15:10,360 --> 00:15:12,800
è sostanzialmente

362
00:15:12,800 --> 00:15:16,199
iniziare ad arricchire la struttura di

363
00:15:16,199 --> 00:15:19,759
questo insieme andando a identificare

364
00:15:19,759 --> 00:15:23,199
all'interno di R classi di linguaggi di

365
00:15:23,199 --> 00:15:25,880
difficoltà differenti. troveremo classi

366
00:15:25,880 --> 00:15:28,519
di problemi facili, classi di problemi

367
00:15:28,519 --> 00:15:30,880
difficili o equivalentemente classi di

368
00:15:30,880 --> 00:15:33,360
linguaggi facili e classi di linguaggi

369
00:15:33,360 --> 00:15:38,000
difficili perché non sospendiamo la

370
00:15:38,000 --> 00:15:39,480
l'assunzione che abbiamo fatto, cioè che

371
00:15:39,480 --> 00:15:41,680
studiamo i problemi tramite i linguaggi.

372
00:15:41,680 --> 00:15:43,639
Quello si fa sempre, quindi avremo

373
00:15:43,639 --> 00:15:46,120
classi di linguaggi semplici e classi di

374
00:15:46,120 --> 00:15:48,519
linguaggi

375
00:15:48,519 --> 00:15:51,319
difficili. Ok? Allora, possiamo

376
00:15:51,319 --> 00:15:53,800
introdurre quindi i primi concetti che

377
00:15:53,800 --> 00:15:56,560
riguardano la complessità computazionale

378
00:15:56,560 --> 00:15:57,920
delle macchine di Touring, degli

379
00:15:57,920 --> 00:15:59,560
algoritmi delle macchine di Touring.

380
00:15:59,560 --> 00:16:01,360
Badate che in quello che diremo oggi,

381
00:16:01,360 --> 00:16:03,079
oggi parleremo della complessità

382
00:16:03,079 --> 00:16:05,040
computazionale delle macchine, però noi

383
00:16:05,040 --> 00:16:07,079
sappiamo che queste macchine ormai sono

384
00:16:07,079 --> 00:16:10,959
algoritmi se ci focalizziamo all'interno

385
00:16:10,959 --> 00:16:12,720
delle classe dei linguaggi decidibili

386
00:16:12,720 --> 00:16:15,040
perché sono algoritmi che terminano. Ok?

387
00:16:15,040 --> 00:16:17,480
Quindi, quando dirò la complessità di di

388
00:16:17,480 --> 00:16:19,399
una macchina o la complessità di un

389
00:16:19,399 --> 00:16:21,680
algoritmo, starò sostanzialmente usando

390
00:16:21,680 --> 00:16:26,800
dei sinomi di Ok? Alri. Yes.
Questo

391
00:16:26,800 --> 00:16:31,880
grazie al teorema di Bon.
Eh, non lo so.

392
00:16:31,880 --> 00:16:33,880
Non non conosco il risultato. Il teorema

393
00:16:33,880 --> 00:16:38,000
di chi?
Iini e Bon
mi manca. Ok, poi me

394
00:16:38,000 --> 00:16:40,440
lo segna, vado a verificare.

395
00:16:40,440 --> 00:16:44,199
Allora, ehm,

396
00:16:45,680 --> 00:16:47,680
linguaggi, dobbiamo definire la

397
00:16:47,680 --> 00:16:53,279
complessità temporale temporale dei

398
00:16:53,279 --> 00:16:55,040
delle macchine di touring o degli

399
00:16:55,040 --> 00:16:57,399
algoritmi. Ok, prima nozione,

400
00:16:57,399 --> 00:17:01,319
computation time, tempo di esecuzione.

401
00:17:01,319 --> 00:17:05,720
Io lo chiamerei computation time,

402
00:17:09,199 --> 00:17:10,760
sia

403
00:17:10,760 --> 00:17:16,000
m una macchina

404
00:17:16,280 --> 00:17:19,480
di Turing

405
00:17:19,600 --> 00:17:21,679
è W,

406
00:17:21,679 --> 00:17:25,319
una stringa

407
00:17:25,319 --> 00:17:28,319
input

408
00:17:29,240 --> 00:17:32,880
per M.

409
00:17:37,840 --> 00:17:40,039
Il computation time o il tempo di

410
00:17:40,039 --> 00:17:43,039
esecuzione

411
00:17:44,799 --> 00:17:53,480
di m su w è il numero di passi

412
00:17:56,360 --> 00:17:59,360
che

413
00:18:00,039 --> 00:18:02,200
M

414
00:18:02,200 --> 00:18:05,200
esegue

415
00:18:05,520 --> 00:18:08,159
prima

416
00:18:08,159 --> 00:18:11,559
di arrestarsi

417
00:18:13,320 --> 00:18:16,520
su W. Ok? Quindi una definizione molto

418
00:18:16,520 --> 00:18:19,280
semplice.

419
00:18:19,280 --> 00:18:22,679
Come la definiamo invece se la macchina

420
00:18:22,679 --> 00:18:25,080
M è non deterministica?

421
00:18:25,080 --> 00:18:27,880
Dobbiamo leggermente adattare la

422
00:18:27,880 --> 00:18:30,840
definizione. Sì. E possiamo fare il

423
00:18:30,840 --> 00:18:32,840
numero di, cioè noi abbiamo l'albero di

424
00:18:32,840 --> 00:18:35,080
computazione qui, possiamo fare il

425
00:18:35,080 --> 00:18:38,600
numero di noi, di
m più o meno la

426
00:18:38,600 --> 00:18:41,200
definiamo così. Prendiamo il computation

427
00:18:41,200 --> 00:18:44,520
time e la lunghezza del branch, così è

428
00:18:44,520 --> 00:18:47,240
finito, no?

429
00:18:47,240 --> 00:18:49,080
Sì, è la lunghezza della più lunga

430
00:18:49,080 --> 00:18:52,159
computazione della macchina su W. Ok?

431
00:18:52,159 --> 00:18:54,240
Quindi, se c'ha rami più lunghi di

432
00:18:54,240 --> 00:18:56,400
altri, noi andiamo a prendere il più

433
00:18:56,400 --> 00:19:00,799
lungo. Quindi

434
00:19:00,840 --> 00:19:05,400
se la macchina

435
00:19:06,039 --> 00:19:11,600
M è non deterministica,

436
00:19:17,039 --> 00:19:20,960
il computation time

437
00:19:23,480 --> 00:19:25,880
è dato

438
00:19:25,880 --> 00:19:27,520
dalla

439
00:19:27,520 --> 00:19:30,520
lunghezza

440
00:19:31,039 --> 00:19:34,480
del branch più lungo,

441
00:19:34,480 --> 00:19:39,159
del branch di computazione più lungo,

442
00:19:43,400 --> 00:19:46,039
più lungo.

443
00:19:46,039 --> 00:19:48,400
Ok, quindi questo per noi è il

444
00:19:48,400 --> 00:19:50,000
computation time di una macchina di

445
00:19:50,000 --> 00:19:52,200
touring. Prendiamo e contiamo i passi.

446
00:19:52,200 --> 00:19:56,120
Molto semplice. Ok.

447
00:19:58,120 --> 00:20:00,720
Come? Scusi,
il computational time è

448
00:20:00,720 --> 00:20:03,000
dato
è data dalla lunghezza del branch

449
00:20:03,000 --> 00:20:04,960
di computazione più lungo nel momento in

450
00:20:04,960 --> 00:20:07,200
cui siamo su una macchina non

451
00:20:07,200 --> 00:20:11,440
deterministica. Ok?

452
00:20:11,919 --> 00:20:14,919
Alrght.

453
00:20:16,679 --> 00:20:20,880
sia t n

454
00:20:20,880 --> 00:20:24,400
una funzione

455
00:20:24,760 --> 00:20:29,600
che va da interi a interi

456
00:20:29,600 --> 00:20:32,159
tale che

457
00:20:32,159 --> 00:20:35,520
t n

458
00:20:35,520 --> 00:20:38,520
decreasing

459
00:20:40,159 --> 00:20:43,840
è strettamente positiva.

460
00:20:47,919 --> 00:20:50,520
Ok? Quindi queste sono due condizioni

461
00:20:50,520 --> 00:20:54,400
importanti. TDN è una funzione

462
00:20:54,400 --> 00:20:57,360
che va da che mappa interi su interi. È

463
00:20:57,360 --> 00:21:00,280
una funzione non decrescente e

464
00:21:00,280 --> 00:21:03,159
strettamente positiva. Una funzione si

465
00:21:03,159 --> 00:21:06,799
fatta la chiamiamo time function,

466
00:21:06,799 --> 00:21:09,200
funzione temporale, non lo so in

467
00:21:09,200 --> 00:21:11,520
italiano. Time function, in genere viene

468
00:21:11,520 --> 00:21:14,279
chiamata time function. Quindi cos'è una

469
00:21:14,279 --> 00:21:16,000
time function? Una time function è

470
00:21:16,000 --> 00:21:18,559
semplicemente una funzione da interi

471
00:21:18,559 --> 00:21:21,320
versi interi che è strettamente positiva

472
00:21:21,320 --> 00:21:24,960
ed è non decrescente. Ok? La potevamo

473
00:21:24,960 --> 00:21:26,960
chiamare Giovanni, l'hanno chiamata time

474
00:21:26,960 --> 00:21:30,039
function. Ok?

475
00:21:30,039 --> 00:21:33,600
Allora, noi abbiamo il concetto di

476
00:21:33,600 --> 00:21:36,720
running time,

477
00:21:36,720 --> 00:21:38,799
running time di una macchina di Touring.

478
00:21:38,799 --> 00:21:41,080
Ok? Qui quindi il la prima nozione era

479
00:21:41,080 --> 00:21:44,720
il computation time di una macchina di

480
00:21:44,720 --> 00:21:46,880
touring e ora abbiamo una cosa diversa

481
00:21:46,880 --> 00:21:49,279
che è il running time di una macchina di

482
00:21:49,279 --> 00:21:52,840
Turing. Ok?

483
00:21:54,799 --> 00:21:58,720
Oplà. Sia tdn

484
00:21:58,720 --> 00:22:01,840
una time

485
00:22:01,840 --> 00:22:04,840
function.

486
00:22:05,600 --> 00:22:09,720
La macchina

487
00:22:09,840 --> 00:22:12,880
di Turing

488
00:22:12,880 --> 00:22:17,919
M a running time. Questo è il passaggio

489
00:22:17,919 --> 00:22:21,159
che ci serve. Running time

490
00:22:21,159 --> 00:22:24,159
TDN.

491
00:22:24,279 --> 00:22:25,919
Se

492
00:22:25,919 --> 00:22:28,679
per tutte

493
00:22:28,679 --> 00:22:32,120
le stringhe

494
00:22:32,360 --> 00:22:34,400
W

495
00:22:34,400 --> 00:22:36,159
a parte

496
00:22:36,159 --> 00:22:38,919
un numero finito,

497
00:22:38,919 --> 00:22:43,600
questa è una finezza, un numero finito,

498
00:22:44,440 --> 00:22:48,679
il computation time

499
00:22:50,440 --> 00:22:58,240
di m su W non è non eccede

500
00:22:59,679 --> 00:23:02,400
t valutata sulla lunghezza della string

501
00:23:02,400 --> 00:23:04,320
input. Ok?

502
00:23:04,320 --> 00:23:09,000
Ripeto, quindi noi abbiamo la due

503
00:23:09,000 --> 00:23:10,960
nozioni, computation time di una

504
00:23:10,960 --> 00:23:13,080
macchina di tunering, running time di

505
00:23:13,080 --> 00:23:16,320
una macchina di Il computation time di

506
00:23:16,320 --> 00:23:18,840
una macchina di touring è proprio il

507
00:23:18,840 --> 00:23:21,080
numero di passi che la macchina fa su

508
00:23:21,080 --> 00:23:23,000
una certa stringa. Quindi noi parliamo

509
00:23:23,000 --> 00:23:25,039
del computation time di una macchina di

510
00:23:25,039 --> 00:23:27,039
Touring su una certa stringa. Ok? Lì

511
00:23:27,039 --> 00:23:29,279
proprio andiamo a contar. Nel caso in

512
00:23:29,279 --> 00:23:31,080
cui la macchina diuring è non

513
00:23:31,080 --> 00:23:33,039
deterministica, il computation timer

514
00:23:33,039 --> 00:23:35,039
della macchina

515
00:23:35,039 --> 00:23:38,360
di Turing è dato dalla lunghezza del

516
00:23:38,360 --> 00:23:40,120
branch di computazione più lungo. Ok?

517
00:23:40,120 --> 00:23:42,240
Quindi questo è computation time da un

518
00:23:42,240 --> 00:23:45,720
da un lato. Sulla nozione di computation

519
00:23:45,720 --> 00:23:47,880
time costruiamo

520
00:23:47,880 --> 00:23:50,279
la nozione di running time di una

521
00:23:50,279 --> 00:23:53,960
macchina, ok? Che è più vicino alla

522
00:23:53,960 --> 00:23:56,159
nozione di complessità di algoritmo che

523
00:23:56,159 --> 00:23:58,400
conoscete, ok? Perché voi conoscete la

524
00:23:58,400 --> 00:24:00,200
nozione di complessità di algoritmo che

525
00:24:00,200 --> 00:24:02,440
è data da una certa funzione, ok?

526
00:24:02,440 --> 00:24:05,320
Quindi, computation time è quanti passi

527
00:24:05,320 --> 00:24:06,960
la macchina di Touring fa prima di

528
00:24:06,960 --> 00:24:09,880
fermarsi su una certa stringa. Running

529
00:24:09,880 --> 00:24:12,720
time invece è una stima tramite una

530
00:24:12,720 --> 00:24:14,600
funzione del tempo che la macchina di

531
00:24:14,600 --> 00:24:17,840
Touring ci mette a calcolare. Ok? Comeè

532
00:24:17,840 --> 00:24:20,760
definito il running time di una macchina

533
00:24:20,760 --> 00:24:22,919
di touring? Prima ci serve il concetto

534
00:24:22,919 --> 00:24:25,360
di time function. Time function è un

535
00:24:25,360 --> 00:24:27,559
nome che diamo a delle funzioni che

536
00:24:27,559 --> 00:24:30,000
mappano interi su interi e sono non

537
00:24:30,000 --> 00:24:32,279
decrescenti e strettamente positive.

538
00:24:32,279 --> 00:24:35,039
Quindi la time function è una funzione

539
00:24:35,039 --> 00:24:37,279
fatta così. Noi diciamo che una macchina

540
00:24:37,279 --> 00:24:39,880
di touring m

541
00:24:39,880 --> 00:24:45,039
ha running time tdn con tdn una time

542
00:24:45,039 --> 00:24:49,679
function. Se per ogni stringa che noi

543
00:24:49,679 --> 00:24:53,880
diamo in input alla nostra macchina M,

544
00:24:53,880 --> 00:24:59,000
il computation time di M su W è bound da

545
00:24:59,000 --> 00:25:02,600
cosa? Da t valutato sulla lunghezza

546
00:25:02,600 --> 00:25:05,000
della stringa input, ok? E questo deve

547
00:25:05,000 --> 00:25:07,840
valere su tutte le stringhe in input, a

548
00:25:07,840 --> 00:25:10,840
parte un numero finito di S. Ok? Questa

549
00:25:10,840 --> 00:25:13,240
è proprio la definizione più pulita che

550
00:25:13,240 --> 00:25:15,480
si trova sul testo di Conselen, mi pare,

551
00:25:15,480 --> 00:25:17,240
ok? Non la troverete su altri testi,

552
00:25:17,240 --> 00:25:21,440
però Ruffle è il running time è un bound

553
00:25:21,440 --> 00:25:24,279
funzionale su quanto tempo macchina

554
00:25:24,279 --> 00:25:28,559
gira, quello è. Ok,

555
00:25:28,559 --> 00:25:32,240
scusate prima scusi che c'è il sole

556
00:25:32,240 --> 00:25:36,000
dietro non la vedo. Ok. sia funzione

557
00:25:36,000 --> 00:25:39,399
tale che è un percing

558
00:25:39,399 --> 00:25:42,039
è eh strettamente positiva. Sì, è

559
00:25:42,039 --> 00:25:44,320
scritto un po' a caso

560
00:25:44,320 --> 00:25:46,080
perché perché vogliamo che il time

561
00:25:46,080 --> 00:25:48,080
function perché viene definito così,

562
00:25:48,080 --> 00:25:50,000
così viene definito proprio sui sul

563
00:25:50,000 --> 00:25:53,279
testo sul paper di hardis. Una time

564
00:25:53,279 --> 00:25:55,120
function viene caratterizzata in questo

565
00:25:55,120 --> 00:25:57,000
modo perché uno ci aspettiamo che la

566
00:25:57,000 --> 00:25:59,919
macchina impieghi del tempo superiore a

567
00:25:59,919 --> 00:26:04,000
zero a rispondere, ok? e due perché più

568
00:26:04,000 --> 00:26:06,000
grosso è l'input più ci aspettiamo che

569
00:26:06,000 --> 00:26:07,880
la macchina richieda tempo. Ecco perché

570
00:26:07,880 --> 00:26:09,880
le time function sono definite in questo

571
00:26:09,880 --> 00:26:15,399
modo. Ok? Eh, alright.

572
00:26:15,720 --> 00:26:17,279
Questo

573
00:26:17,279 --> 00:26:19,399
chiara questa definizione? Quindi

574
00:26:19,399 --> 00:26:21,200
computation time da un lato che è una

575
00:26:21,200 --> 00:26:24,000
cosa molto grezza, cioè molto raw,

576
00:26:24,000 --> 00:26:26,039
direttamente agganciata al numero di

577
00:26:26,039 --> 00:26:27,679
passi che la macchina fa prima di

578
00:26:27,679 --> 00:26:29,480
arrestarsi su una certa stringa. Poi c'è

579
00:26:29,480 --> 00:26:31,679
il running time che è come una

580
00:26:31,679 --> 00:26:33,799
descrizione più ad alto livello che ci

581
00:26:33,799 --> 00:26:36,200
dice "Guarda, questa macchina si arresta

582
00:26:36,200 --> 00:26:39,520
in n²". Ok? Quindi se gli dai una

583
00:26:39,520 --> 00:26:42,760
stringa di taglia 10 si ferma in alpi

584
00:26:42,760 --> 00:26:45,000
100 passi. Se gli dai una stringa di

585
00:26:45,000 --> 00:26:47,600
taglia 100 si ferma in al più 10.000

586
00:26:47,600 --> 00:26:50,520
passi. Ok? Quindi running time è una

587
00:26:50,520 --> 00:26:53,480
cosa che lega il tempo di esecuzione

588
00:26:53,480 --> 00:26:56,640
della macchina a una funzione, ok? Che è

589
00:26:56,640 --> 00:26:58,399
quello che in genere immagine avrete

590
00:26:58,399 --> 00:27:00,520
visto sul corso di algoritmi, cioè

591
00:27:00,520 --> 00:27:03,520
questo algoritmo è big o di n cubo per

592
00:27:03,520 --> 00:27:06,000
dire. Ok? Quindi il running time è

593
00:27:06,000 --> 00:27:08,200
quello che avete sempre visto, solo che

594
00:27:08,200 --> 00:27:11,039
ora l'abbiamo definito sulla nozione di

595
00:27:11,039 --> 00:27:14,399
macchina di macchina di tuning. Ok?

596
00:27:14,399 --> 00:27:16,240
Facciamo un piccolo recap di altre

597
00:27:16,240 --> 00:27:18,600
nozioni, giusto per essere sicuri che

598
00:27:18,600 --> 00:27:20,440
abbiamo tutti in testa la stessa

599
00:27:20,440 --> 00:27:22,000
definizione,

600
00:27:22,000 --> 00:27:24,960
che sono la notazione asintotica

601
00:27:24,960 --> 00:27:27,480
e anche per i nostri colleghi matematici

602
00:27:27,480 --> 00:27:29,640
che non so se l'hanno vista. Notazione

603
00:27:29,640 --> 00:27:32,640
asintotica.

604
00:27:33,080 --> 00:27:34,640
Asintotica.

605
00:27:34,640 --> 00:27:36,960
Oggi scrivo veramente

606
00:27:36,960 --> 00:27:38,520
Ok.

607
00:27:38,520 --> 00:27:44,919
Alright. Big O. Big O. Ok.

608
00:27:47,360 --> 00:27:53,519
Allora, noi diciamo che una funzione fn

609
00:27:53,519 --> 00:27:55,240
è

610
00:27:55,240 --> 00:28:01,480
big o di gdn per un'altra funzione gdn

611
00:28:01,480 --> 00:28:04,200
se

612
00:28:04,200 --> 00:28:07,200
esistono

613
00:28:07,240 --> 00:28:12,399
due costanti c e ed n0

614
00:28:12,399 --> 00:28:17,519
tali che per ogni n maggiore o uguale di

615
00:28:17,519 --> 00:28:19,120
n0

616
00:28:19,120 --> 00:28:25,519
fn è bound dall'alto da c gn.

617
00:28:25,519 --> 00:28:28,320
Ok? Questa è la definizione di

618
00:28:28,320 --> 00:28:30,600
bigotagion. Facciamo una velocissima

619
00:28:30,600 --> 00:28:32,960
rappresentazione.

620
00:28:32,960 --> 00:28:35,960
Ok.

621
00:28:42,559 --> 00:28:45,640
Alri, questo è,

622
00:28:45,640 --> 00:28:48,120
diciamo, fn.

623
00:28:48,120 --> 00:28:52,399
Questo qui è c gn.

624
00:28:52,399 --> 00:28:53,679
Allora, che cosa ci dice questa

625
00:28:53,679 --> 00:28:57,519
definizione? Che la funzione f(n)

626
00:28:57,519 --> 00:28:59,440
è bounded.

627
00:28:59,440 --> 00:29:01,679
Ci vedete?

628
00:29:01,679 --> 00:29:04,200
Abbasso un pochino. Un secondo

629
00:29:04,200 --> 00:29:06,640
sto giro. Come mai?

630
00:29:06,640 --> 00:29:09,120
Ah!

631
00:29:09,360 --> 00:29:13,159
era sceso. Ok?

632
00:29:13,799 --> 00:29:17,919
Allora, una funzione f(n) è bounded

633
00:29:17,919 --> 00:29:21,279
dalla funzione è bounded da sopra dalla

634
00:29:21,279 --> 00:29:26,519
funzione g di n se esiste un certo punto

635
00:29:26,519 --> 00:29:28,679
n0

636
00:29:28,679 --> 00:29:36,360
dopo il quale la funzione c * g n

637
00:29:36,360 --> 00:29:40,600
è maggiore di fn. Ok? Quindi prima di n0

638
00:29:40,600 --> 00:29:42,480
può succedere quello che vogliamo. Dopo

639
00:29:42,480 --> 00:29:44,120
n0

640
00:29:44,120 --> 00:29:47,799
f n deve essere bounded dall'alto dalla

641
00:29:47,799 --> 00:29:50,799
funzione g n moltiplicata per una certa

642
00:29:50,799 --> 00:29:53,080
costante. Ok?

643
00:29:53,080 --> 00:30:00,080
Questa è la definizione di big o dn

644
00:30:01,000 --> 00:30:05,640
è scriveremo in questo modo è big o dn.

645
00:30:05,640 --> 00:30:08,640
Altra notazione che potremo utilizzare

646
00:30:08,640 --> 00:30:13,960
che fn appartiene a big o di gdn.

647
00:30:13,960 --> 00:30:15,600
Intenderemo la stessa cosa. Quando

648
00:30:15,600 --> 00:30:19,919
scriverò fn appartiene a big o di gn sto

649
00:30:19,919 --> 00:30:25,279
intendendo che fn è big o di gdn, ok?

650
00:30:25,279 --> 00:30:28,240
Che sui libri si trova entrambi o con il

651
00:30:28,240 --> 00:30:30,120
verbo essere o con il simbolo di

652
00:30:30,120 --> 00:30:31,679
appartenza.

653
00:30:31,679 --> 00:30:36,120
FNO di Gn. Sì, perché f è limitato da C

654
00:30:36,120 --> 00:30:38,919
n molpicato.
Sì, sì, sì, sì, sì, sì.

655
00:30:38,919 --> 00:30:41,320
Significa intuitivamente

656
00:30:41,320 --> 00:30:44,399
che l'ordine di grandezza della crescita

657
00:30:44,399 --> 00:30:48,720
di fn è bounded da gdn, cioè fn non

658
00:30:48,720 --> 00:30:51,279
cresce più velocemente di gn. Questa è

659
00:30:51,279 --> 00:30:53,960
la è l'intuizione. Questa anche uguale

660
00:30:53,960 --> 00:30:55,760
come
può essere anche uguale.
Può essere

661
00:30:55,760 --> 00:30:58,960
anche uguale, per esempio,

662
00:30:58,960 --> 00:31:03,120
sicuro vi ricorderete che n qu

663
00:31:03,120 --> 00:31:07,039
di n³, ok? Poi quanto noi vogliamo

664
00:31:07,039 --> 00:31:09,279
vicino il bound alla funzione f(n),

665
00:31:09,279 --> 00:31:11,320
quello dipende da dal tipo di analisi

666
00:31:11,320 --> 00:31:13,080
che stiamo facendo, no? Quindi

667
00:31:13,080 --> 00:31:16,320
l'intuizione Big O semplicemente ci sta

668
00:31:16,320 --> 00:31:20,000
dicendo a finale che il tasso di

669
00:31:20,000 --> 00:31:22,320
crescita di fn

670
00:31:22,320 --> 00:31:25,159
superiore al tasso di crescita di GDN,

671
00:31:25,159 --> 00:31:28,840
ok? Significa che è limitato dall'alto

672
00:31:28,840 --> 00:31:31,320
da gdn. Poi questo limite può essere

673
00:31:31,320 --> 00:31:36,679
l'asco o può essere più stringente. Ok?

674
00:31:36,679 --> 00:31:42,080
Quindi questo era Big O. Sì, certo.

675
00:31:43,840 --> 00:31:48,960
Altra nozione big omega.

676
00:31:51,559 --> 00:31:55,600
Quanto spazio ho? Ok? Fn

677
00:31:55,600 --> 00:31:59,760
è big omega di gn

678
00:31:59,760 --> 00:32:05,519
oppure appartiene a big omega di gdn

679
00:32:05,519 --> 00:32:10,480
se esistono una costante c e un numero

680
00:32:10,480 --> 00:32:12,000
n0

681
00:32:12,000 --> 00:32:17,440
tale che per ogni n mag uguale di n0 f n

682
00:32:17,440 --> 00:32:20,480
è maggiore o uguale di c * gn, quindi

683
00:32:20,480 --> 00:32:22,360
esattamente l'opposto.

684
00:32:22,360 --> 00:32:26,200
Ok, facciamo un disegnino.

685
00:32:30,679 --> 00:32:33,679
Allora,

686
00:32:35,840 --> 00:32:39,880
quindi abbiamo n

687
00:32:40,320 --> 00:32:43,600
fn e questo è

688
00:32:43,600 --> 00:32:47,519
c * gn. Ok? E quindi è esattamente il

689
00:32:47,519 --> 00:32:51,880
contrario. Noi diciamo che f

690
00:32:51,880 --> 00:32:55,159
è big omega

691
00:32:55,159 --> 00:33:00,960
di gn se il tasso di crescita di fn

692
00:33:00,960 --> 00:33:03,720
inferiore al tasso di crescita di gn e

693
00:33:03,720 --> 00:33:07,919
quindi gn fa limita la funzione fn dal

694
00:33:07,919 --> 00:33:11,559
basso. Ok? Quindi è un lower bound,

695
00:33:11,559 --> 00:33:14,399
mentre big o è un upper bound, big omega

696
00:33:14,399 --> 00:33:18,240
è un lower bound. Ok?

697
00:33:18,240 --> 00:33:20,559
Anche in questo caso il bounding può

698
00:33:20,559 --> 00:33:23,679
essere stretto, può essere stringente o

699
00:33:23,679 --> 00:33:25,880
lasco. Ok? Quindi noi abbiamo per

700
00:33:25,880 --> 00:33:30,039
esempio che n qua

701
00:33:32,519 --> 00:33:35,639
di n log n²

702
00:33:35,639 --> 00:33:38,960
e big omega di n, per esempio. Ok? Cioè

703
00:33:38,960 --> 00:33:40,760
queste sono funzioni che si sganciano

704
00:33:40,760 --> 00:33:42,840
sempre di più. Perché siamo interessati

705
00:33:42,840 --> 00:33:45,000
a questo? Perché nel momento in cui

706
00:33:45,000 --> 00:33:47,080
andremo ad analizzare il tempo di

707
00:33:47,080 --> 00:33:48,600
esecuzione

708
00:33:48,600 --> 00:33:51,240
delle nostre macchine di Touring, se ci

709
00:33:51,240 --> 00:33:55,559
mettono 3* n qu passi o ce ne mettono 2*

710
00:33:55,559 --> 00:33:57,720
n qu a noi non importa perché a noi

711
00:33:57,720 --> 00:33:59,200
quello che importa è il tasso di

712
00:33:59,200 --> 00:34:01,559
crescita. ci saranno dei teoremi che

713
00:34:01,559 --> 00:34:03,799
forse vi menziono ma sicuramente non vi

714
00:34:03,799 --> 00:34:06,440
dimostro in cui sostanzialmente si fa

715
00:34:06,440 --> 00:34:10,159
vedere che non ha senso andare a

716
00:34:10,159 --> 00:34:12,240
guardare le costanti perché data una

717
00:34:12,240 --> 00:34:15,520
macchina ce n'è sempre una più veloce

718
00:34:15,520 --> 00:34:17,879
che ci permette di ridurre in maniera

719
00:34:17,879 --> 00:34:20,240
lineare il tempo di esecuzione. Quindi

720
00:34:20,240 --> 00:34:24,000
se una macchina ranna in 6 n² quel

721
00:34:24,000 --> 00:34:26,000
teorema ci garantisce che ce n'è una

722
00:34:26,000 --> 00:34:29,159
stessa macchina che ranna in n². Il

723
00:34:29,159 --> 00:34:31,119
trucco è che io posso prendere tanti

724
00:34:31,119 --> 00:34:32,639
simboli,

725
00:34:32,639 --> 00:34:35,639
condensarli in simboli,

726
00:34:35,639 --> 00:34:37,280
in una varietà maggiore di simboli.

727
00:34:37,280 --> 00:34:38,919
Quindi quando leggo una cosa, in realtà

728
00:34:38,919 --> 00:34:40,839
è come se stessi leggendo, che ne so, 8

729
00:34:40,839 --> 00:34:44,040
bit a un colpo, perché c'ho, che ne so,

730
00:34:44,040 --> 00:34:46,679
64 simboli diversi sul nastro e quindi

731
00:34:46,679 --> 00:34:48,159
ogni volta che ne leggo uno è come se

732
00:34:48,159 --> 00:34:51,000
stessi leggendo otto di fila e quindi

733
00:34:51,000 --> 00:34:53,639
posso accelerare il tempo di esecuzione.

734
00:34:53,639 --> 00:34:57,280
Ok? Si chiama linear speedup, che io

735
00:34:57,280 --> 00:35:01,520
rendo questa cosa qua. Ok.

736
00:35:02,599 --> 00:35:07,320
Biga, big teta ve lo dico. Ok.

737
00:35:07,320 --> 00:35:10,560
Big teta.

738
00:35:12,680 --> 00:35:14,599
Fn

739
00:35:14,599 --> 00:35:18,480
è big teta di gn.

740
00:35:18,480 --> 00:35:20,040
Se

741
00:35:20,040 --> 00:35:22,839
fn

742
00:35:22,839 --> 00:35:28,119
è sia big omega di gn

743
00:35:28,119 --> 00:35:30,240
e

744
00:35:30,240 --> 00:35:35,119
bigo di gdn e big omega di gdn.

745
00:35:35,119 --> 00:35:38,839
Alri.
Si legge bene
come
si legge bene.

746
00:35:38,839 --> 00:35:41,520
Ah, ok. Ve la ridico a voce perché sulla

747
00:35:41,520 --> 00:35:46,480
sul poi sul PDF prende una funzione fn

748
00:35:46,480 --> 00:35:51,800
è big teta di gn

749
00:35:51,800 --> 00:35:55,760
se fn è sia

750
00:35:55,760 --> 00:36:02,599
big o di gn che omega di gn.

751
00:36:02,599 --> 00:36:05,319
Quindi vuol dire che GDN non solo è un

752
00:36:05,319 --> 00:36:07,640
upper bound della funzione f(n), ma è

753
00:36:07,640 --> 00:36:09,400
anche un lower bound, il che significa

754
00:36:09,400 --> 00:36:12,760
che fn ha un tasso di crescita che è

755
00:36:12,760 --> 00:36:15,599
equivalente a gdn. Ok? Quindi

756
00:36:15,599 --> 00:36:18,760
aggiungiamo questa nozione qua. Perché

757
00:36:18,760 --> 00:36:20,760
introduciamo questo? Perché tramite

758
00:36:20,760 --> 00:36:23,119
questa nozione noi introduciamo il

759
00:36:23,119 --> 00:36:31,119
concetto di complessità di problemi. Ok?

760
00:36:32,520 --> 00:36:35,079
Time

761
00:36:35,079 --> 00:36:38,079
complexity

762
00:36:38,520 --> 00:36:41,880
upper bound

763
00:36:43,480 --> 00:36:47,920
di un problema

764
00:36:48,760 --> 00:36:52,599
P. Ok. Cos'è il time complexity

765
00:36:52,599 --> 00:36:55,680
upperbound di un problema qui?

766
00:36:55,680 --> 00:37:01,680
Il time complexity upper bound di un P

767
00:37:01,680 --> 00:37:06,000
è big O di f n dove fn è una time

768
00:37:06,000 --> 00:37:09,000
function.

769
00:37:11,040 --> 00:37:14,040
Se tutti

770
00:37:14,040 --> 00:37:17,720
gli algoritmi o tutte le macchine di

771
00:37:17,720 --> 00:37:21,800
Turing che risolvono P

772
00:37:21,800 --> 00:37:23,760
hanno un tempo di esecuzione, hanno un

773
00:37:23,760 --> 00:37:27,440
running time che è big o di fn. Ok?

774
00:37:27,440 --> 00:37:30,240
Quindi la complessità di un problema

775
00:37:30,240 --> 00:37:32,040
viene caratterizzata tramite la

776
00:37:32,040 --> 00:37:33,560
complessità degli algoritmi che lo

777
00:37:33,560 --> 00:37:37,000
risolvono. Ok? Quindi noi diciamo che la

778
00:37:37,000 --> 00:37:39,240
complessità, il time complexity di

779
00:37:39,240 --> 00:37:45,079
upperbound di un problema è big o di fn

780
00:37:45,079 --> 00:37:49,079
se tutti gli algoritmi che lo risolvono,

781
00:37:49,079 --> 00:37:52,200
ma tutti sì, proprio tutti, tutti gli

782
00:37:52,200 --> 00:37:55,240
algoritmi che lo risolvono hanno un

783
00:37:55,240 --> 00:38:00,599
running time che è big o di fn.

784
00:38:00,599 --> 00:38:05,359
Ok? È chiaro? Quindi un problema a che

785
00:38:05,359 --> 00:38:07,400
ne so

786
00:38:07,400 --> 00:38:09,760
sorting

787
00:38:09,760 --> 00:38:12,000
sorting di arrays. È vero, no? Che il

788
00:38:12,000 --> 00:38:14,079
time complexity upperbound del

789
00:38:14,079 --> 00:38:17,119
dell'ordinamento degli array è big o di

790
00:38:17,119 --> 00:38:20,400
n qu?

791
00:38:20,720 --> 00:38:22,720
No.

792
00:38:22,720 --> 00:38:25,440
Ah, sì, sì.
Sì.

793
00:38:25,440 --> 00:38:29,280
Ok. È vero o no?
Sì.

794
00:38:29,280 --> 00:38:33,280
Sì, perché tutti

795
00:38:33,280 --> 00:38:36,000
no. Sorry, sorry, ho sbagliato a definir

796
00:38:36,000 --> 00:38:38,079
eh qua infatti mi stavo mi stavo

797
00:38:38,079 --> 00:38:39,800
confondendo. Devo ritornare il conto.

798
00:38:39,800 --> 00:38:42,280
Boh, cancelliamo questa definizione. Go

799
00:38:42,280 --> 00:38:45,319
back. Time complexity upper bound di un

800
00:38:45,319 --> 00:38:47,560
problema. Sorry guys, ecco perché non mi

801
00:38:47,560 --> 00:38:51,160
ritornava la la definizione di questo.

802
00:38:51,160 --> 00:38:53,560
Il time complexity upper bound di un

803
00:38:53,560 --> 00:38:57,960
problema P è big O di FN.

804
00:38:57,960 --> 00:39:02,240
Esatto. Grammarro. Ok. E codi fn se

805
00:39:02,240 --> 00:39:05,720
esiste anche un solo algoritmo la cui

806
00:39:05,720 --> 00:39:08,520
complessità è Bodi Fdn. Ok, così ha

807
00:39:08,520 --> 00:39:11,520
senso.

808
00:39:12,560 --> 00:39:14,839
Ecco perché mo a sorte non mi veniva.

809
00:39:14,839 --> 00:39:18,240
Com'è possibile questa cosa?
Come
almeno

810
00:39:18,240 --> 00:39:20,240
un algoritmo il cui running time è

811
00:39:20,240 --> 00:39:22,960
quello. Ok? Quindi ora la domanda di

812
00:39:22,960 --> 00:39:26,040
prima è sensata, quindi definizione di

813
00:39:26,040 --> 00:39:29,160
nuovo. Il complexity

814
00:39:29,160 --> 00:39:31,280
time complexity upper bound di un

815
00:39:31,280 --> 00:39:34,640
problema P è big o di fn se esiste

816
00:39:34,640 --> 00:39:37,800
almeno un algoritmo che lo risolve in

817
00:39:37,800 --> 00:39:41,680
time big o d fn. Ok? Quindi ora la

818
00:39:41,680 --> 00:39:43,359
domanda

819
00:39:43,359 --> 00:39:45,720
is meaningful. È vero, no, che il time

820
00:39:45,720 --> 00:39:49,160
complexity upper bound del sorting è big

821
00:39:49,160 --> 00:39:50,960
o di n qu?

822
00:39:50,960 --> 00:39:54,680
Sì, è vero, no, che il time complexity

823
00:39:54,680 --> 00:39:58,920
upper bound del sorting è bigod n cubo.

824
00:39:58,920 --> 00:40:01,520
Sì, è vero, no che il time complexity

825
00:40:01,520 --> 00:40:07,920
upper bound è 2^ n.
Sì,
no.

826
00:40:07,920 --> 00:40:10,680
Sì, perché ci sta un algoritmo che ranna

827
00:40:10,680 --> 00:40:14,880
in al più 2^ n. Selection sort è bigo di

828
00:40:14,880 --> 00:40:19,839
2^ n. È molto lasco, però è big di 2^ n.

829
00:40:19,839 --> 00:40:21,760
È vero o no che il time complexity upper

830
00:40:21,760 --> 00:40:25,480
bound del sorting è n log n? Sì, perché

831
00:40:25,480 --> 00:40:28,800
c'abbiamo merge sort eccetera. È vero,

832
00:40:28,800 --> 00:40:31,920
no, che il time complexity upper bound

833
00:40:31,920 --> 00:40:35,880
del sorting è big ODL? No, perché non

834
00:40:35,880 --> 00:40:37,720
siamo in grado di ordinare in tempo

835
00:40:37,720 --> 00:40:40,560
lineare e di fatto esiste una tecnica

836
00:40:40,560 --> 00:40:43,040
che dimostra, penso che l'abbiate vista,

837
00:40:43,040 --> 00:40:47,200
che non si può ordinare come?
In place.

838
00:40:47,200 --> 00:40:49,560
In place. Sì, sì, sì, sì. Eh, e non

839
00:40:49,560 --> 00:40:51,319
possiamo fare nemmeno assunzioni

840
00:40:51,319 --> 00:40:53,119
statistiche sulla distribuzione

841
00:40:53,119 --> 00:40:55,800
dell'array perché sennò si può eh andare

842
00:40:55,800 --> 00:40:58,440
più veloce. Ok? Quindi abbiamo un array

843
00:40:58,440 --> 00:41:01,319
che su cui non possiamo dire niente. In

844
00:41:01,319 --> 00:41:03,960
quel caso siamo costretti a n log n

845
00:41:03,960 --> 00:41:06,240
perché si può dimostrare che con un

846
00:41:06,240 --> 00:41:08,200
numero asempoticamente inferiore di

847
00:41:08,200 --> 00:41:10,680
confronti l'array potrebbe non essere

848
00:41:10,680 --> 00:41:12,839
ordinato in maniera sensata. Ok? Quindi

849
00:41:12,839 --> 00:41:15,040
quello è il minimo che possiamo fare.

850
00:41:15,040 --> 00:41:17,319
Possiamo definire ora il time complexity

851
00:41:17,319 --> 00:41:18,839
lowerbound.

852
00:41:18,839 --> 00:41:22,440
di un problema qui, eh? Time

853
00:41:22,440 --> 00:41:25,440
complexity

854
00:41:27,240 --> 00:41:30,680
lower bound

855
00:41:32,200 --> 00:41:34,720
di un

856
00:41:34,720 --> 00:41:37,480
problema

857
00:41:37,480 --> 00:41:45,000
P è big o big omega di FM.

858
00:41:45,520 --> 00:41:47,760
Se

859
00:41:47,760 --> 00:41:51,319
tutti gli algoritmi

860
00:41:51,319 --> 00:41:54,720
che lo risolvono

861
00:41:55,520 --> 00:42:01,720
richiedono tempo big omega di fn. Ok?

862
00:42:01,720 --> 00:42:06,440
Ripeto, il time complexity

863
00:42:06,440 --> 00:42:10,640
upper bound di un problema

864
00:42:10,640 --> 00:42:12,839
è

865
00:42:12,839 --> 00:42:14,800
big

866
00:42:14,800 --> 00:42:18,560
omega di fn se tutti gli algoritmi che

867
00:42:18,560 --> 00:42:20,400
lo risolvono

868
00:42:20,400 --> 00:42:22,839
hanno un tempo di esecuzione che è big

869
00:42:22,839 --> 00:42:25,520
omega di fn.

870
00:42:25,520 --> 00:42:28,359
Domanda. È vero, no, che il time

871
00:42:28,359 --> 00:42:31,960
complexity upper bound del sorting è big

872
00:42:31,960 --> 00:42:35,559
omega di n?

873
00:42:36,839 --> 00:42:39,359
Sì, perché tutti gli algoritmi che

874
00:42:39,359 --> 00:42:41,520
ordinano vettori ci mettono almeno

875
00:42:41,520 --> 00:42:43,119
linear time, in particolare ce ne

876
00:42:43,119 --> 00:42:45,359
mettono di più.

877
00:42:45,359 --> 00:42:48,079
È vero, no, che il time complexity lower

878
00:42:48,079 --> 00:42:52,599
bound del sorting è n log n?

879
00:42:52,599 --> 00:42:55,920
Sì, ok. Perché tutti gli algoritmi ci

880
00:42:55,920 --> 00:42:59,359
mettono almeno quello. È vero o no che

881
00:42:59,359 --> 00:43:01,800
il time complexity lowerbound

882
00:43:01,800 --> 00:43:05,720
dell'ordinamento è n qu?

883
00:43:05,720 --> 00:43:08,319
No, perché abbiamo algoritmi che rannano

884
00:43:08,319 --> 00:43:10,640
meglio di quello. Ok? Quindi questa è la

885
00:43:10,640 --> 00:43:15,119
nozione. Quindi tramite la definizione

886
00:43:15,119 --> 00:43:17,720
del time complexity degli algoritmi che

887
00:43:17,720 --> 00:43:20,640
risolvono un certo problema, noi siamo

888
00:43:20,640 --> 00:43:23,599
in grado di parlare della complessità

889
00:43:23,599 --> 00:43:26,920
temporale dei problemi. Ok? Quindi un

890
00:43:26,920 --> 00:43:28,760
problema,

891
00:43:28,760 --> 00:43:30,839
la complessità temporale di un problema

892
00:43:30,839 --> 00:43:32,640
è legata alla complessità temporale

893
00:43:32,640 --> 00:43:34,920
degli algoritmi che lo risolvono. Noi

894
00:43:34,920 --> 00:43:38,319
diremo che un problema è trattabile o

895
00:43:38,319 --> 00:43:42,160
facile se il time complexity upper bound

896
00:43:42,160 --> 00:43:44,920
di questo problema è polinomiale.

897
00:43:44,920 --> 00:43:47,599
Ok? basta che sia polinomiale. In quel

898
00:43:47,599 --> 00:43:49,440
modo noi diremo che il problema è

899
00:43:49,440 --> 00:43:52,640
trattabile o facile.

900
00:43:52,640 --> 00:43:56,640
Se invece il problema non ammette

901
00:43:56,640 --> 00:43:59,680
algoritmi polinomiali, allora diremo che

902
00:43:59,680 --> 00:44:01,920
il problema è difficile. Ok? Quindi è un

903
00:44:01,920 --> 00:44:04,079
po' strano perché la definizione di

904
00:44:04,079 --> 00:44:06,359
problema facile e problema difficile si

905
00:44:06,359 --> 00:44:09,079
basa sugli algoritmi che lo risolvono.

906
00:44:09,079 --> 00:44:11,599
Quindi se abbiamo algoritmi efficienti

907
00:44:11,599 --> 00:44:13,640
noi diciamo che il problema è facile. Se

908
00:44:13,640 --> 00:44:15,839
l'algoritmo efficiente non c'è diciamo

909
00:44:15,839 --> 00:44:18,760
che il problema è difficile. Ok? Adesso

910
00:44:18,760 --> 00:44:21,240
uno potrebbe dire, eh, però un problema

911
00:44:21,240 --> 00:44:24,280
che si si risolve in n^ 1000 non è che è

912
00:44:24,280 --> 00:44:28,240
così così facile da risolvere. Se invece

913
00:44:28,240 --> 00:44:30,520
abbiamo un algoritmo esponenziale che è

914
00:44:30,520 --> 00:44:34,680
2^ n / 1000 per dire, no?

915
00:44:34,680 --> 00:44:37,599
Però di fatto questo sì, questo ci dà un

916
00:44:37,599 --> 00:44:40,920
certo rimando della pratica, però la

917
00:44:40,920 --> 00:44:44,040
questione è che su input che crescono

918
00:44:44,040 --> 00:44:46,400
all'infinito gli algoritmi esponenziali

919
00:44:46,400 --> 00:44:48,640
prima o poi diventano ingestibili. Non

920
00:44:48,640 --> 00:44:50,800
non si può. Non so se mai ci avete

921
00:44:50,800 --> 00:44:53,680
provato a far rannare Napsack su istanze

922
00:44:53,680 --> 00:44:56,599
di 30-40 elementi. Accendete il

923
00:44:56,599 --> 00:44:59,319
computer. Se non avete tecniche tipo

924
00:44:59,319 --> 00:45:01,640
branch and bound, euristiche varie di

925
00:45:01,640 --> 00:45:04,040
ordinamento, uscite, andate a cena,

926
00:45:04,040 --> 00:45:06,520
tornate, il computer sta ancora girando.

927
00:45:06,520 --> 00:45:08,280
Ok? Quindi tutti gli algoritmi

928
00:45:08,280 --> 00:45:10,800
esponenziali su grossi input alla fine

929
00:45:10,800 --> 00:45:13,280
collassano, non non riusciamo a starli

930
00:45:13,280 --> 00:45:16,400
appresso. Però una cosa interessante è

931
00:45:16,400 --> 00:45:19,280
che gran stranamente gran parte dei

932
00:45:19,280 --> 00:45:22,400
problemi semplici ammette

933
00:45:22,400 --> 00:45:25,520
eh algoritmi polinomiali il cui

934
00:45:25,520 --> 00:45:29,480
esponente non è strambo e 3 4 ci sono ci

935
00:45:29,480 --> 00:45:33,160
sono problemi che sono n^ s.

936
00:45:33,160 --> 00:45:35,920
Il test di primalità lo vedremo dopo, è

937
00:45:35,920 --> 00:45:39,400
n^ 12, ok? Però insomma sono numeri

938
00:45:39,400 --> 00:45:42,480
piccolini, come su problemi esponenziali

939
00:45:42,480 --> 00:45:44,760
difficilmente avrei non ci stanno

940
00:45:44,760 --> 00:45:48,559
problemi che 2^ n / 1000 in genere è 2^

941
00:45:48,559 --> 00:45:52,200
2 * n 2^ n / 2. Cioè questi sono le

942
00:45:52,200 --> 00:45:55,559
costanti che in genere troviamo, ok?

943
00:45:55,559 --> 00:45:57,760
E E va bene, ci fermiamo per un po' di

944
00:45:57,760 --> 00:45:59,280
pause.

945
00:45:59,280 --> 00:46:03,000
Facciamo un 10 minuti.

946
00:46:03,000 --> 00:46:07,040
M pausa, pausa, pausa.

947
00:46:11,200 --> 00:46:15,720
Ok, ripartiamo in caso finiamo prima.

948
00:46:15,720 --> 00:46:17,760
Ok,

949
00:46:17,760 --> 00:46:20,359
quindi abbiamo introdotto computation

950
00:46:20,359 --> 00:46:22,640
time di una macchina diuring, running

951
00:46:22,640 --> 00:46:24,839
time di una macchina diuring che per noi

952
00:46:24,839 --> 00:46:27,480
è anche il running time di un algoritmo.

953
00:46:27,480 --> 00:46:29,760
Tramite il running time di algoritmo e

954
00:46:29,760 --> 00:46:32,240
le funzioni e la notazione asintotica

955
00:46:32,240 --> 00:46:35,680
abbiamo definito complex time complexity

956
00:46:35,680 --> 00:46:37,640
upper bound di un algoritmo di un

957
00:46:37,640 --> 00:46:40,640
problema e time complexity lower bound

958
00:46:40,640 --> 00:46:44,119
di un problema.

959
00:46:44,119 --> 00:46:47,160
Quindi essenzialmente il time complexity

960
00:46:47,160 --> 00:46:49,359
upper bound di un problema P è bigo di

961
00:46:49,359 --> 00:46:52,200
fn se esiste un algoritmo che necessita

962
00:46:52,200 --> 00:46:54,800
di quel tempo per risolverlo. Il time

963
00:46:54,800 --> 00:46:57,319
complexity lower bound di un problema è

964
00:46:57,319 --> 00:46:59,880
bigom fn se tutti gli algoritmi

965
00:46:59,880 --> 00:47:04,760
necessitano di almeno fn big di fn per

966
00:47:04,760 --> 00:47:07,520
risolverlo. Ok? I problemi facili sono i

967
00:47:07,520 --> 00:47:09,440
problemi per cui abbiamo algoritmi

968
00:47:09,440 --> 00:47:12,160
polinomiali. Questa è una bellissima

969
00:47:12,160 --> 00:47:16,000
definizione self referenti, ok? E gli i

970
00:47:16,000 --> 00:47:17,559
problemi difficili sono i problemi per i

971
00:47:17,559 --> 00:47:19,839
quali non abbiamo algoritmi che li

972
00:47:19,839 --> 00:47:23,240
risolvono in tempo polinomiale. Ok?

973
00:47:23,240 --> 00:47:25,760
Quindi questa è la cosa.

974
00:47:25,760 --> 00:47:28,400
Quello che facciamo ora

975
00:47:28,400 --> 00:47:33,200
è andare a definire all'interno della

976
00:47:33,200 --> 00:47:37,720
classe R delle classi di complessità,

977
00:47:37,720 --> 00:47:39,800
ok? Perché noi abbiamo detto che la

978
00:47:39,800 --> 00:47:44,040
classe R è una classe di decidibilità o

979
00:47:44,040 --> 00:47:47,640
di calcolabilità. dentro R ci sta tutto

980
00:47:47,640 --> 00:47:50,000
quello che è calcolabile.

981
00:47:50,000 --> 00:47:53,280
Adesso il nostro intento sarà andare a

982
00:47:53,280 --> 00:47:57,240
identificare dentro R ciò che è a bassa

983
00:47:57,240 --> 00:47:59,160
complessità e ciò che è ad alta

984
00:47:59,160 --> 00:48:02,040
complessità, cioè quei linguaggi che per

985
00:48:02,040 --> 00:48:05,800
essere risolti necessitano di poco tempo

986
00:48:05,800 --> 00:48:07,920
e i linguaggi che per essere decisi

987
00:48:07,920 --> 00:48:10,280
necessitano di tanto tempo. Ok? E quindi

988
00:48:10,280 --> 00:48:12,440
noi vogliamo andare a fare un lavoro più

989
00:48:12,440 --> 00:48:15,280
di fino all'interno di R per stabilire

990
00:48:15,280 --> 00:48:17,680
cosa si risolve facilmente e cosa si

991
00:48:17,680 --> 00:48:21,040
risolve difficilmente. Ok? Andiamo

992
00:48:21,040 --> 00:48:26,319
quindi a introdurre la nozione di classe

993
00:48:26,319 --> 00:48:29,319
di complessità.

994
00:48:29,319 --> 00:48:31,280
classe

995
00:48:31,280 --> 00:48:34,960
di complessità

996
00:48:36,520 --> 00:48:40,000
temporale. Poi abbiamo anche le classi

997
00:48:40,000 --> 00:48:42,480
temporale, le classi di complessità

998
00:48:42,480 --> 00:48:44,079
spaziale, ma questa è una cosa che

999
00:48:44,079 --> 00:48:47,880
vedremo più in là, ok?

1000
00:48:47,880 --> 00:48:50,720
Sia tdn

1001
00:48:50,720 --> 00:48:54,920
una time function,

1002
00:48:57,440 --> 00:48:59,920
ok?

1003
00:48:59,960 --> 00:49:02,000
denotiamo

1004
00:49:02,000 --> 00:49:04,720
d time

1005
00:49:04,720 --> 00:49:08,280
di fn

1006
00:49:09,559 --> 00:49:11,480
l'insieme

1007
00:49:11,480 --> 00:49:16,079
di tutti i linguaggi L

1008
00:49:16,079 --> 00:49:20,359
tali per cui esiste una macchina di

1009
00:49:20,359 --> 00:49:24,640
touring deterministica

1010
00:49:25,680 --> 00:49:29,880
e questo è importante, eh

1011
00:49:30,359 --> 00:49:34,760
che decide

1012
00:49:35,319 --> 00:49:40,720
TDN. Ok, qua ho scritto unaità. Oplà,

1013
00:49:40,720 --> 00:49:42,920
questo è ttdn.

1014
00:49:42,920 --> 00:49:45,119
Ok.

1015
00:49:45,119 --> 00:49:49,960
Yes. L. Ok. di time di tdn, dove tdn è

1016
00:49:49,960 --> 00:49:53,359
una time function, è l'insieme di tutti

1017
00:49:53,359 --> 00:49:56,880
i linguaggi tali per cui esiste una

1018
00:49:56,880 --> 00:50:00,720
macchina di Turing M deterministica,

1019
00:50:00,720 --> 00:50:05,200
quindi guardate qua, de deterministica

1020
00:50:05,200 --> 00:50:07,720
D time. Ok? Ecco per cui usiamo questa

1021
00:50:07,720 --> 00:50:12,960
notazione che decide L

1022
00:50:12,960 --> 00:50:15,680
in tempo

1023
00:50:15,680 --> 00:50:19,559
big o di TDN.

1024
00:50:19,559 --> 00:50:23,200
Ok? Quindi questa è definizione di

1025
00:50:23,200 --> 00:50:26,200
classe di complessità temporale.

1026
00:50:26,200 --> 00:50:29,119
D time di TDN è l'insieme di tutti i

1027
00:50:29,119 --> 00:50:31,400
linguaggi L tali per cui abbiamo una

1028
00:50:31,400 --> 00:50:34,359
macchina o un algoritmo a questo punto

1029
00:50:34,359 --> 00:50:37,599
deterministico, questo è importante, che

1030
00:50:37,599 --> 00:50:41,040
decide il linguaggio L in tempo big o di

1031
00:50:41,040 --> 00:50:42,880
tdn.

1032
00:50:42,880 --> 00:50:45,880
Chiaro?

1033
00:50:46,640 --> 00:50:49,280
Definiamo a questo punto formalmente la

1034
00:50:49,280 --> 00:50:52,000
classe che sicuramente vi avranno

1035
00:50:52,000 --> 00:50:54,920
menzionato un numero infinito di volte

1036
00:50:54,920 --> 00:50:57,599
che è la classe P.

1037
00:50:57,599 --> 00:51:00,319
Polynomial time.

1038
00:51:00,319 --> 00:51:01,920
P

1039
00:51:01,920 --> 00:51:04,599
è la classe

1040
00:51:04,599 --> 00:51:09,000
ottenuta tramite l'unione per C mag> 1

1041
00:51:09,000 --> 00:51:11,760
di d time

1042
00:51:11,760 --> 00:51:14,920
di n^ c.

1043
00:51:14,920 --> 00:51:17,119
Ok?

1044
00:51:17,119 --> 00:51:19,280
Quindi questa è la definizione formale

1045
00:51:19,280 --> 00:51:22,400
della classe P polynomial time che

1046
00:51:22,400 --> 00:51:25,240
contiene tutti i linguaggi

1047
00:51:25,240 --> 00:51:28,359
che possono essere decisi

1048
00:51:28,359 --> 00:51:32,280
da una macchina di Turing deterministica

1049
00:51:32,280 --> 00:51:34,200
in tempo polinomiale per un certo

1050
00:51:34,200 --> 00:51:36,000
esponente fissato. Noi non sappiamo

1051
00:51:36,000 --> 00:51:37,720
quale sia questo esponente, basta che è

1052
00:51:37,720 --> 00:51:42,760
fissato. Deve essere un polinomio. Ok?

1053
00:51:43,280 --> 00:51:46,280
Adesso

1054
00:51:48,839 --> 00:51:51,839
m

1055
00:51:55,040 --> 00:51:58,240
ordinare un array

1056
00:51:58,240 --> 00:52:01,640
sta in P.

1057
00:52:03,760 --> 00:52:05,920
Sì.

1058
00:52:05,920 --> 00:52:10,520
Ordinare un'arresta in P.

1059
00:52:11,000 --> 00:52:12,920
Sì.

1060
00:52:12,920 --> 00:52:14,720
No,

1061
00:52:14,720 --> 00:52:16,559
e questo è un errore comune che lo

1062
00:52:16,559 --> 00:52:18,599
correggiamo fin dall'inizio così non ci

1063
00:52:18,599 --> 00:52:21,200
caschiamo.

1064
00:52:21,200 --> 00:52:25,000
Ordinare un array non è un problema di

1065
00:52:25,000 --> 00:52:27,720
decisione.

1066
00:52:27,720 --> 00:52:31,839
Dime contiene problemi di decisione.

1067
00:52:31,839 --> 00:52:33,240
Questo è un errore proprio, lo leggete

1068
00:52:33,240 --> 00:52:35,720
pure sui paper. Vengono pubblicate da

1069
00:52:35,720 --> 00:52:37,400
gente che non si occupa di complessità

1070
00:52:37,400 --> 00:52:41,240
strutturale e infila in Ped NP. problemi

1071
00:52:41,240 --> 00:52:44,040
non di decisione. No, questi queste

1072
00:52:44,040 --> 00:52:46,680
classi contengono solo problemi di

1073
00:52:46,680 --> 00:52:48,400
decisione.

1074
00:52:48,400 --> 00:52:52,520
Sommare due numeri appartiene a P?

1075
00:52:52,520 --> 00:52:55,079
No, perché non è un problema di

1076
00:52:55,079 --> 00:52:59,680
decisione. Ok? Quindi P contiene solo

1077
00:52:59,680 --> 00:53:03,359
problemi di decisione.

1078
00:53:03,359 --> 00:53:05,640
P polynomial time è la classe dei

1079
00:53:05,640 --> 00:53:08,480
problemi di decisione che possono essere

1080
00:53:08,480 --> 00:53:10,400
decisi da macchine di touring

1081
00:53:10,400 --> 00:53:14,480
deterministiche in tempo polinomiale.

1082
00:53:14,480 --> 00:53:18,160
Ok? Quindi per quello che avevamo detto

1083
00:53:18,160 --> 00:53:19,760
prima,

1084
00:53:19,760 --> 00:53:22,400
dentro P ci stanno quelli che per noi

1085
00:53:22,400 --> 00:53:24,680
sono i linguaggi trattabili, ok? Quindi

1086
00:53:24,680 --> 00:53:27,599
quello che sta dentro P noi sono i

1087
00:53:27,599 --> 00:53:31,720
problemi facili. Quello che sarà fuori P

1088
00:53:31,720 --> 00:53:34,720
ma dentro R sono i problemi per noi

1089
00:53:34,720 --> 00:53:38,240
difficili. Ok? Per definizione andiamo a

1090
00:53:38,240 --> 00:53:40,520
guardare un po' un paio di esempi di

1091
00:53:40,520 --> 00:53:44,480
problemi che si trovano in P.

1092
00:53:44,480 --> 00:53:47,480
Richbility.

1093
00:53:49,720 --> 00:53:54,680
Ok. raggiungibilità su un grafo.

1094
00:53:54,680 --> 00:53:57,119
Quindi che cos'è rbility? Dato un grafo

1095
00:53:57,119 --> 00:53:58,920
diretto,

1096
00:53:58,920 --> 00:54:03,040
una sorgente e una destinazione,

1097
00:54:03,040 --> 00:54:07,520
vogliamo stabilire se esiste un percorso

1098
00:54:07,520 --> 00:54:10,640
dal nodo sorgente al nodo destinazione.

1099
00:54:10,640 --> 00:54:13,280
Ok? Questo è un problema di di

1100
00:54:13,280 --> 00:54:15,880
decisione?

1101
00:54:15,880 --> 00:54:19,280
Sì, perché la domanda è dato un grafo,

1102
00:54:19,280 --> 00:54:22,000
dato ST, è vero, no, che da S riusciamo

1103
00:54:22,000 --> 00:54:24,960
a raggiungere T dentro G? Come lo

1104
00:54:24,960 --> 00:54:29,520
possiamo caratterizzare come linguaggio?

1105
00:54:29,520 --> 00:54:32,520
Rachability

1106
00:54:32,680 --> 00:54:37,640
è l'insieme delle triple grafo ST, tali

1107
00:54:37,640 --> 00:54:39,960
per cui

1108
00:54:39,960 --> 00:54:44,960
G. Ok, scriviamo meglio.

1109
00:54:45,680 --> 00:54:50,559
G è un directo

1110
00:54:50,559 --> 00:54:53,559
diretto.

1111
00:54:55,440 --> 00:54:58,400
S e T sono

1112
00:54:58,400 --> 00:55:00,040
nodi

1113
00:55:00,040 --> 00:55:02,760
in G

1114
00:55:02,760 --> 00:55:05,760
esiste

1115
00:55:06,040 --> 00:55:09,319
un percorso

1116
00:55:09,960 --> 00:55:13,319
da S a T

1117
00:55:13,319 --> 00:55:15,240
G.

1118
00:55:15,240 --> 00:55:17,280
Ok? Cioè, quindi è la definizione del

1119
00:55:17,280 --> 00:55:18,720
nostro linguaggio. Ovviamente una

1120
00:55:18,720 --> 00:55:20,280
macchina di Turing per essere in grado

1121
00:55:20,280 --> 00:55:22,240
di decidere questo linguaggio deve

1122
00:55:22,240 --> 00:55:24,000
sostanzialmente essere in grado di

1123
00:55:24,000 --> 00:55:26,039
stabilire se c'è un percorso da ST

1124
00:55:26,039 --> 00:55:27,880
dentro G, ok? Anzi, essere in grado di

1125
00:55:27,880 --> 00:55:29,039
risolvere il problema della

1126
00:55:29,039 --> 00:55:32,039
raggiungibilità.

1127
00:55:32,160 --> 00:55:37,599
Questo problema è in P o non è in P?

1128
00:55:37,599 --> 00:55:41,440
Perché l'ho aggiunto qua?

1129
00:55:43,240 --> 00:55:47,160
Eh,
sì. Ve lo ricordate un algoritmo che

1130
00:55:47,160 --> 00:55:50,480
risolve questo algoritmo in polinomial

1131
00:55:50,480 --> 00:55:55,760
time? Già extra.
Già extra. Ok. Eh, chi

1132
00:55:55,760 --> 00:55:57,799
viene da matematica ha mai sentito

1133
00:55:57,799 --> 00:56:00,559
questa cosa qua?

1134
00:56:00,559 --> 00:56:03,520
Fatevi guardare negli occhi. No, ok, lo

1135
00:56:03,520 --> 00:56:05,280
spieghiamo.

1136
00:56:05,280 --> 00:56:06,920
Allora,

1137
00:56:06,920 --> 00:56:09,680
la metafora, no, come lo spiegavo in

1138
00:56:09,680 --> 00:56:11,720
Inghilterra, noi abbiamo questo grafo,

1139
00:56:11,720 --> 00:56:15,240
supponiamo che siamo S e T e vogliamo

1140
00:56:15,240 --> 00:56:18,799
stabilire se è possibile andare da S

1141
00:56:18,799 --> 00:56:20,920
verso T. Ok? I dettagli di questo

1142
00:56:20,920 --> 00:56:23,039
algoritmo in pseudocodice stanno sugli

1143
00:56:23,039 --> 00:56:24,880
appunti di Calautti. Voi andate là, ve

1144
00:56:24,880 --> 00:56:27,400
li leggete, noi ci limitiamo a un

1145
00:56:27,400 --> 00:56:30,599
escorsous veloce. Come funziona? Allora,

1146
00:56:30,599 --> 00:56:35,839
sostanzialmente funziona in questo modo.

1147
00:56:35,839 --> 00:56:40,160
Ad alto livello. Partiamo da S,

1148
00:56:40,160 --> 00:56:43,160
ok?

1149
00:56:43,160 --> 00:56:46,000
Lo buttiamo in un sacco

1150
00:56:46,000 --> 00:56:48,720
che è il sacco delle cose che stiamo

1151
00:56:48,720 --> 00:56:50,599
raggiungendo. Apriamo il sacco, vediamo

1152
00:56:50,599 --> 00:56:54,039
che c'è. Tiriamo fuori S. Ok.

1153
00:56:54,039 --> 00:56:57,079
S avrà dei nodi adiacenti, cioè da S

1154
00:56:57,079 --> 00:56:59,200
possiamo raggiungere due nodi. In questo

1155
00:56:59,200 --> 00:57:01,680
esempio specifico possiamo raggiungere

1156
00:57:01,680 --> 00:57:04,039
questo qua e questo qua. Chiamiamoli che

1157
00:57:04,039 --> 00:57:05,960
ne so A e B.

1158
00:57:05,960 --> 00:57:08,520
Quello che si fa è che si parte da si

1159
00:57:08,520 --> 00:57:10,680
vede chi sono gli adiacenti, li

1160
00:57:10,680 --> 00:57:14,280
prendiamo, li infiliamo in questo sacco,

1161
00:57:14,280 --> 00:57:16,520
dopodiché riprendiamo il sacco, lo

1162
00:57:16,520 --> 00:57:18,760
apriamo, tiriamo fuori un nodo e

1163
00:57:18,760 --> 00:57:21,960
facciamo la stessa cosa. Tipo supponiamo

1164
00:57:21,960 --> 00:57:24,440
che dal sacco abbiamo tirato fuori A.

1165
00:57:24,440 --> 00:57:27,400
Dove posso andare con A? Posso andare su

1166
00:57:27,400 --> 00:57:29,200
B.

1167
00:57:29,200 --> 00:57:31,319
Prendo B, lo butto dentro. Poi si deve

1168
00:57:31,319 --> 00:57:33,680
stare attenti, questo magari lo vedete

1169
00:57:33,680 --> 00:57:36,280
nel dettaglio dell'algoritmo, è che non

1170
00:57:36,280 --> 00:57:38,280
devo ciclare più volte sulle stesse

1171
00:57:38,280 --> 00:57:40,480
cose, senò iniziamo a luppare. Ok?

1172
00:57:40,480 --> 00:57:43,480
Quindi lo becco là, non aggiunto niente

1173
00:57:43,480 --> 00:57:46,000
al sacco, tiro fuori dal sacco, ci sta

1174
00:57:46,000 --> 00:57:50,000
B. Dove posso andare con B? Posso andare

1175
00:57:50,000 --> 00:57:52,680
in T. Prendo T, lo metto nel sacco,

1176
00:57:52,680 --> 00:57:54,480
riapro il sacco, tiro fuori quello che

1177
00:57:54,480 --> 00:57:57,119
c'è dentro. T e dove volevo arrivare?

1178
00:57:57,119 --> 00:57:58,799
Rispondo di sì. Quindi l'idea

1179
00:57:58,799 --> 00:58:00,599
sostanzialmente di questo algoritmo è

1180
00:58:00,599 --> 00:58:03,720
che io prendo un nodo, mi controllo chi

1181
00:58:03,720 --> 00:58:06,400
sono gli adiacenti, me li metto in un

1182
00:58:06,400 --> 00:58:09,599
insieme, in un sacco, in una busta, ok?

1183
00:58:09,599 --> 00:58:12,319
Dove c'è tutta questa roba e quelli sono

1184
00:58:12,319 --> 00:58:14,319
i nodi che ho raggiunto fino a quel

1185
00:58:14,319 --> 00:58:16,319
momento. Quando apro il sacco, tiro

1186
00:58:16,319 --> 00:58:18,280
fuori i nodi e cerco di capire da lì

1187
00:58:18,280 --> 00:58:20,760
dove posso arrivare. A poco a poco,

1188
00:58:20,760 --> 00:58:23,599
livello per livello, riuscirò a vedere

1189
00:58:23,599 --> 00:58:29,280
se da S riesco ad arrivare a T. Ok?

1190
00:58:29,319 --> 00:58:31,880
Di quanti passi necessitiamo per fare

1191
00:58:31,880 --> 00:58:35,200
questa cosa?

1192
00:58:36,920 --> 00:58:38,960
Raffli, eh?

1193
00:58:38,960 --> 00:58:44,160
N + n
eh un po' di più

1194
00:58:45,280 --> 00:58:48,359
al quadrato se non f
Sì, è n qu più o

1195
00:58:48,359 --> 00:58:52,240
meno, perché per ogni nodo male che ci

1196
00:58:52,240 --> 00:58:53,920
va riusciamo a raggiungere tutti gli

1197
00:58:53,920 --> 00:58:55,280
altri. Ovvio che se riuscissimo a

1198
00:58:55,280 --> 00:58:56,480
raggiungere tutti gli altri poi

1199
00:58:56,480 --> 00:58:58,839
sarebbero direttamente a T. Però un

1200
00:58:58,839 --> 00:59:02,039
bound molto lasque. Prendo un nodo,

1201
00:59:02,039 --> 00:59:05,200
tutti gli altri li devo mettere in n

1202
00:59:05,200 --> 00:59:07,280
busta, poi qui tiro fuori dalla busta,

1203
00:59:07,280 --> 00:59:08,920
magari riesco a raggiungere tutti

1204
00:59:08,920 --> 00:59:11,799
nuovamente e quindi devo fare n volte

1205
00:59:11,799 --> 00:59:14,440
questo processo che mi costa n, quindi

1206
00:59:14,440 --> 00:59:18,319
ruffly questo approccio ci costa n². Di

1207
00:59:18,319 --> 00:59:21,400
conseguenza il problema, poiché ammetto

1208
00:59:21,400 --> 00:59:23,359
un algoritmo polinomiale, è un problema

1209
00:59:23,359 --> 00:59:28,960
che sta in pi perché è un problema che

1210
00:59:28,960 --> 00:59:33,119
eh è un problema è un algoritmo che

1211
00:59:33,119 --> 00:59:34,520
chiede tempo polinomiale ed è un

1212
00:59:34,520 --> 00:59:36,640
problema di inisione. Ok?

1213
00:59:36,640 --> 00:59:38,280
Un altro

1214
00:59:38,280 --> 00:59:41,280
primes,

1215
00:59:42,960 --> 00:59:45,720
l'insieme degli interi n rappresentati

1216
00:59:45,720 --> 00:59:47,440
in binario

1217
00:59:47,440 --> 00:59:52,680
tali che n è un numero

1218
00:59:52,680 --> 00:59:55,680
primo.

1219
00:59:57,720 --> 00:59:59,119
Ok.

1220
00:59:59,119 --> 01:00:01,880
Test standard di primari ci serve in una

1221
01:00:01,880 --> 01:00:03,640
marea di applicazioni, soprattutto di

1222
01:00:03,640 --> 01:00:06,319
tipo crittografico. Dato un intero

1223
01:00:06,319 --> 01:00:08,839
rappresentato il binario, noi dobbiamo

1224
01:00:08,839 --> 01:00:11,079
stabilire se quell'intero è un numero

1225
01:00:11,079 --> 01:00:15,079
primo o no. Ok?

1226
01:00:15,079 --> 01:00:17,280
Chiaro?

1227
01:00:17,280 --> 01:00:19,799
Qual è un algoritmo naif per risolvere

1228
01:00:19,799 --> 01:00:22,640
questo problema?

1229
01:00:22,640 --> 01:00:26,559
Il criello di
Il crivello di eratostene

1230
01:00:26,559 --> 01:00:28,440
oppure

1231
01:00:28,440 --> 01:00:30,160
crivello di eratostene occupa una marea

1232
01:00:30,160 --> 01:00:33,359
di spazio, però vabbè. Oppure Sì, una

1233
01:00:33,359 --> 01:00:38,559
cosa che possiamo fare è cicliamo. Sì,

1234
01:00:38,680 --> 01:00:40,520
più che listarli. Sì, si può fare anche

1235
01:00:40,520 --> 01:00:43,400
quello, no? testare.
Ah, testare. Ok,

1236
01:00:43,400 --> 01:00:44,880
quello che possiamo fare è che lo

1237
01:00:44,880 --> 01:00:46,839
iniziamo a dividere per due, lo iniziamo

1238
01:00:46,839 --> 01:00:50,680
a dividere per 3. Ok? Quindi, preso n,

1239
01:00:50,680 --> 01:00:53,039
lo dividiamo prima per 2, poi per 3, poi

1240
01:00:53,039 --> 01:00:56,200
per 4, poi per 5, bla bla bla bla, fino

1241
01:00:56,200 --> 01:00:58,799
a n - 1. Ok? In realtà non abbiamo

1242
01:00:58,799 --> 01:01:00,839
necessità di arrivare a n - 1, basta

1243
01:01:00,839 --> 01:01:03,079
arrivare alla radice n, però non è che

1244
01:01:03,079 --> 01:01:08,000
ci risolve tanto la questione. Ok?

1245
01:01:08,000 --> 01:01:11,880
Quante divisioni facciamo?

1246
01:01:12,880 --> 01:01:15,880
Ruffle,

1247
01:01:16,000 --> 01:01:21,280
supponiamo di arrivare a N - 1. Big O di

1248
01:01:23,160 --> 01:01:27,480
eh Nig O di N. Sì, big o di N.

1249
01:01:27,480 --> 01:01:33,079
Divisioni. Ok. Ogni divisione ci costa

1250
01:01:36,079 --> 01:01:38,240
polinomial. Ogni divisione ci costa, no?

1251
01:01:38,240 --> 01:01:41,480
Polinomiale, eh, costante è nel mondo

1252
01:01:41,480 --> 01:01:43,240
delle super macchine. Una macchina di

1253
01:01:43,240 --> 01:01:45,240
touring, dividere ci mette un pochino.

1254
01:01:45,240 --> 01:01:48,720
Ok? Quindi il costo reale di dividere

1255
01:01:48,720 --> 01:01:51,839
due numeri è polinomial per a meno che

1256
01:01:51,839 --> 01:01:53,720
sì, la questione è che se poi dobbiamo

1257
01:01:53,720 --> 01:01:55,520
dividere i numeri più grossi ci servono

1258
01:01:55,520 --> 01:01:57,279
circuiti più grandi. Nel momento in cui

1259
01:01:57,279 --> 01:01:59,039
il circuito è a taglia limitata, noi

1260
01:01:59,039 --> 01:02:00,720
dobbiamo iniziare a fare più operazioni,

1261
01:02:00,720 --> 01:02:02,520
però si fa in tempo polinomiale, eh

1262
01:02:02,520 --> 01:02:05,559
nella taglia degli input. Quindi abbiamo

1263
01:02:05,559 --> 01:02:09,799
big OD n divisioni

1264
01:02:11,359 --> 01:02:13,359
ognuna

1265
01:02:13,359 --> 01:02:15,920
che costa

1266
01:02:15,920 --> 01:02:18,920
polinomiale.

1267
01:02:19,520 --> 01:02:23,160
Ok? Questa complessità è polinomiale o

1268
01:02:23,160 --> 01:02:26,160
no?

1269
01:02:28,000 --> 01:02:31,000
Mh.

1270
01:02:37,680 --> 01:02:40,000
Attenzione,

1271
01:02:40,000 --> 01:02:43,000
attenzione,

1272
01:02:46,279 --> 01:02:48,839
è polinomiale in cosa? Cioè il running

1273
01:02:48,839 --> 01:02:52,240
time degli algoritmi è valutato in base

1274
01:02:52,240 --> 01:02:55,240
alla,

1275
01:02:55,480 --> 01:03:00,760
guardate la definizione T di

1276
01:03:00,760 --> 01:03:04,000
T diav

1277
01:03:04,799 --> 01:03:08,520
eh la taglia dell'input. Ok. Questo

1278
01:03:08,520 --> 01:03:10,240
numero di divisioni è la taglia

1279
01:03:10,240 --> 01:03:14,799
dell'input o il valore dell'input?

1280
01:03:15,279 --> 01:03:17,079
Mh.

1281
01:03:17,079 --> 01:03:20,200
E il valore dell'input, ok? E il valore

1282
01:03:20,200 --> 01:03:22,480
dell'input è polinomiale nella sua

1283
01:03:22,480 --> 01:03:24,160
taglia?

1284
01:03:24,160 --> 01:03:27,240
No, è esponenziale.

1285
01:03:27,240 --> 01:03:30,400
Attenzione, guys, eh, questo algoritmo è

1286
01:03:30,400 --> 01:03:32,279
lentissimo. Questo algoritmo è

1287
01:03:32,279 --> 01:03:34,279
esponenziale perché il numero di

1288
01:03:34,279 --> 01:03:37,760
divisioni che facciamo è pari al valore

1289
01:03:37,760 --> 01:03:40,039
del numero in input,

1290
01:03:40,039 --> 01:03:42,640
ma la taglia in cui scriviamo il valore

1291
01:03:42,640 --> 01:03:45,559
in input che è rappresentato in binario,

1292
01:03:45,559 --> 01:03:49,359
quello è logaritmico, cioè

1293
01:03:49,359 --> 01:03:52,839
n il suo valore

1294
01:03:52,839 --> 01:03:57,160
è proporzionale al logaritmico al

1295
01:03:57,160 --> 01:03:59,920
logaritmo in base 2 della taglia di

1296
01:03:59,920 --> 01:04:04,000
rappresentare Eh, quindi se noi vogliamo

1297
01:04:04,000 --> 01:04:06,480
dire quante divisioni facciamo rispetto

1298
01:04:06,480 --> 01:04:08,240
alla taglia dell'input e quelle sono

1299
01:04:08,240 --> 01:04:10,359
esponenziali, questo algoritmo è

1300
01:04:10,359 --> 01:04:11,960
lentissimo

1301
01:04:11,960 --> 01:04:13,640
e senò avremmo risolto. C'era bisogno

1302
01:04:13,640 --> 01:04:15,880
dell'algoritmo di Binner Rabbin se

1303
01:04:15,880 --> 01:04:17,640
avevamo un algoritmo lineare che ci

1304
01:04:17,640 --> 01:04:21,000
risolveva il test di primari. Ok? Quindi

1305
01:04:21,000 --> 01:04:22,839
questo algoritmo è lento, questo

1306
01:04:22,839 --> 01:04:26,880
algoritmo prende tempo esponenziale, ok?

1307
01:04:26,880 --> 01:04:28,960
tutti. Questa è una gran fregatura, eh,

1308
01:04:28,960 --> 01:04:30,680
su questi si deve stare molto attento.

1309
01:04:30,680 --> 01:04:35,440
Per esempio, contare da 1 a n è un

1310
01:04:35,440 --> 01:04:38,960
algoritmo lineare?

1311
01:04:42,279 --> 01:04:46,400
No,
no, contare non è lineare.

1312
01:04:46,400 --> 01:04:49,200
Contare è esponenziale nella daglia

1313
01:04:49,200 --> 01:04:50,440
dell'input, a meno che non

1314
01:04:50,440 --> 01:04:53,760
rappresentiamo in un a l'input. Se

1315
01:04:53,760 --> 01:04:55,760
l'input è rappresentato in un ario,

1316
01:04:55,760 --> 01:04:59,359
allora contare prende tempo lineare.

1317
01:04:59,359 --> 01:05:01,440
Ma se l'input è rappresentato in

1318
01:05:01,440 --> 01:05:04,440
binario, quello prende tempo

1319
01:05:04,440 --> 01:05:06,680
esponenziale. Eh, attenzione,

1320
01:05:06,680 --> 01:05:10,640
attenzione.
Sì,
quindi, scusi, e dei

1321
01:05:10,640 --> 01:05:14,559
primes sarebbe o di 2 elevato alla

1322
01:05:14,559 --> 01:05:19,039
grandezza del
Sì, sarebbe questo. big o

1323
01:05:19,039 --> 01:05:25,240
di 2^ n alla taglia di n per un una cosa

1324
01:05:25,240 --> 01:05:27,799
di questo tipo N^ K per una certa

1325
01:05:27,799 --> 01:05:29,799
costante che quello è quanto ci costa

1326
01:05:29,799 --> 01:05:31,880
fare la divisione, ok? quello è la

1327
01:05:31,880 --> 01:05:34,400
complessità di quell'algoritmo. Eh,

1328
01:05:34,400 --> 01:05:36,599
attenzione a questo perché questa è una

1329
01:05:36,599 --> 01:05:39,359
cosa su cui si casca facilmente. La

1330
01:05:39,359 --> 01:05:41,000
complessità, il running time degli

1331
01:05:41,000 --> 01:05:42,480
algoritmi e delle macchine di touring è

1332
01:05:42,480 --> 01:05:44,400
sempre valutato rispetto alla taglia

1333
01:05:44,400 --> 01:05:46,960
dell'input, non al suo valore. Adesso,

1334
01:05:46,960 --> 01:05:49,079
fin quando abbiamo liste array, allora

1335
01:05:49,079 --> 01:05:50,760
la cosa è facile perché quelli occupano

1336
01:05:50,760 --> 01:05:53,480
spazi in memoria. Il problema è quando

1337
01:05:53,480 --> 01:05:55,039
abbiamo

1338
01:05:55,039 --> 01:05:56,960
numeri rappresentati in binario che

1339
01:05:56,960 --> 01:05:59,599
quelli sono compatti, cioè in poco

1340
01:05:59,599 --> 01:06:01,599
spazio riusciamo a rappresentare numeri

1341
01:06:01,599 --> 01:06:04,079
grossi e se dobbiamo iniziare a contare

1342
01:06:04,079 --> 01:06:06,319
o fare cose di quel tipo, il tempo che

1343
01:06:06,319 --> 01:06:09,599
ci serve è esponenziale, non è lineare.

1344
01:06:09,599 --> 01:06:11,480
Ok? Quindi questa è una cosa su cui si

1345
01:06:11,480 --> 01:06:14,200
deve stare attenti.

1346
01:06:14,200 --> 01:06:16,880
Detto ciò, in realtà il problema primes

1347
01:06:16,880 --> 01:06:19,720
è un problema polinomiale.

1348
01:06:19,720 --> 01:06:21,480
È un problema polinomiale è stato posto

1349
01:06:21,480 --> 01:06:25,839
in P agli inizi dell'anno 2000

1350
01:06:25,839 --> 01:06:29,880
e se non vado errato la complessità al

1351
01:06:29,880 --> 01:06:33,079
momento è big o di n^ s. Ok? È un

1352
01:06:33,079 --> 01:06:34,960
algoritmo che non usa nessuno perché è

1353
01:06:34,960 --> 01:06:37,640
talmente lento che preferiamo Miller

1354
01:06:37,640 --> 01:06:40,960
Rabin che essendo randomizzato però

1355
01:06:40,960 --> 01:06:43,440
possiamo comunque abbassare la il tasso

1356
01:06:43,440 --> 01:06:46,319
di errori a piacimento, ok? Cioè, quindi

1357
01:06:46,319 --> 01:06:48,599
esiste un algoritmo deterministico che

1358
01:06:48,599 --> 01:06:51,039
risponde a primes in tempo polinomiale,

1359
01:06:51,039 --> 01:06:53,079
ma è un algoritmo catastroficamente

1360
01:06:53,079 --> 01:06:55,799
lento e complicato.

1361
01:06:55,799 --> 01:06:59,640
Fu la mia tesina del terzo anno, primes

1362
01:06:59,640 --> 01:07:03,839
in P. Ok?

1363
01:07:06,640 --> 01:07:10,079
Alright, vediamo adesso un'altra classe.

1364
01:07:10,079 --> 01:07:12,359
Inverto la spiegazione perché mi piace

1365
01:07:12,359 --> 01:07:14,079
più l'idea.

1366
01:07:14,079 --> 01:07:18,960
Ehm, un altro paio di problemi. Ok.

1367
01:07:18,960 --> 01:07:24,240
Il problema SAT della soddisfacilità

1368
01:07:24,960 --> 01:07:28,400
c'è dispità

1369
01:07:29,799 --> 01:07:33,319
di formule

1370
01:07:33,319 --> 01:07:36,160
buleane.

1371
01:07:36,160 --> 01:07:38,760
Lo definiamo ora perché lo vedremo una

1372
01:07:38,760 --> 01:07:40,680
marea di volte durante il resto del

1373
01:07:40,680 --> 01:07:42,760
corso. Ok?

1374
01:07:42,760 --> 01:07:46,960
Allora, noi ci interesseremo di formule

1375
01:07:46,960 --> 01:07:50,960
in forma normale congiuntiva. CNF

1376
01:07:50,960 --> 01:07:53,359
adesso vi dico che cos'è. Sono formule

1377
01:07:53,359 --> 01:07:58,279
buleane che hanno una forma particolare.

1378
01:07:58,279 --> 01:08:00,640
Sono formule

1379
01:08:00,640 --> 01:08:04,760
che sono date dalla congiunzione

1380
01:08:04,760 --> 01:08:09,480
di un numero finito di clausole C1 CN,

1381
01:08:09,480 --> 01:08:15,799
cioè quindi questi C1 C2 bla bla bla C

1382
01:08:15,799 --> 01:08:17,440
sono

1383
01:08:17,440 --> 01:08:20,239
dei pezzetti di sottoformule

1384
01:08:20,239 --> 01:08:24,199
che noi chiamiamo clausole, ok?

1385
01:08:24,199 --> 01:08:30,279
Quindi è C1, and C2, and C3 and C4 bla

1386
01:08:30,279 --> 01:08:32,319
bla.

1387
01:08:32,319 --> 01:08:35,359
Ognuna di queste clausole C con I, ad

1388
01:08:35,359 --> 01:08:39,000
esempio, ha questa forma qua

1389
01:08:39,000 --> 01:08:44,480
L1 or L2 or L3

1390
01:08:44,480 --> 01:08:49,679
or L4 bla bla. Cioè una clausola

1391
01:08:49,679 --> 01:08:51,480
è

1392
01:08:51,480 --> 01:08:54,279
la disgiunzione

1393
01:08:54,279 --> 01:08:59,560
di uno o più letterali.

1394
01:08:59,560 --> 01:09:02,719
Ripeto, le formule in forma normale

1395
01:09:02,719 --> 01:09:05,880
congiuntiva sono formule buleane che

1396
01:09:05,880 --> 01:09:07,600
hanno una struttura particolare, non

1397
01:09:07,600 --> 01:09:10,159
sono formule qualsiasi, sono formule che

1398
01:09:10,159 --> 01:09:12,400
hanno una certa forma, sono

1399
01:09:12,400 --> 01:09:15,239
caratterizzate dalla congiunzione di

1400
01:09:15,239 --> 01:09:18,719
sottoformule C1, C2, C3, bla bla che noi

1401
01:09:18,719 --> 01:09:21,520
chiamiamo clausole. Queste clausole non

1402
01:09:21,520 --> 01:09:23,880
è che sono formule a caso, hanno una

1403
01:09:23,880 --> 01:09:26,560
forma particolare pure loro, sono la

1404
01:09:26,560 --> 01:09:28,359
disgiunzione

1405
01:09:28,359 --> 01:09:31,920
di uno o più letterali, si chiamano L1,

1406
01:09:31,920 --> 01:09:35,279
L2, L3, eccetera. Che cos'è un

1407
01:09:35,279 --> 01:09:38,679
letterale? Un letterale

1408
01:09:38,679 --> 01:09:43,000
LJ cos'è? È una variabile buleana oppure

1409
01:09:43,000 --> 01:09:46,359
il suo negato.

1410
01:09:47,560 --> 01:09:51,960
Ok? Quindi una formula CNF,

1411
01:09:51,960 --> 01:09:55,199
ad esempio, può essere questa qua.

1412
01:09:55,199 --> 01:10:04,400
X1 or X2 or not X3 and not X2 or X4

1413
01:10:04,400 --> 01:10:10,679
and not X3 or X5 or not X6. Voilà. Ok?

1414
01:10:10,679 --> 01:10:13,600
Questa è una formula in CNF. Come vedete

1415
01:10:13,600 --> 01:10:16,000
ha una struttura particolare. Abbiamo le

1416
01:10:16,000 --> 01:10:19,040
clausole che sono in congiunzione fra di

1417
01:10:19,040 --> 01:10:21,120
loro

1418
01:10:21,120 --> 01:10:24,440
e ogni clausola è una disgiunzione di

1419
01:10:24,440 --> 01:10:26,560
letterali dove un letterale è o una

1420
01:10:26,560 --> 01:10:29,199
variabile buleana o il suo negato. Ok?

1421
01:10:29,199 --> 01:10:31,920
Quindi hanno questa forma, non altra

1422
01:10:31,920 --> 01:10:33,440
forma.

1423
01:10:33,440 --> 01:10:36,440
Il problema della soddisfacilità

1424
01:10:36,440 --> 01:10:40,360
è sostanzialmente questo qua.

1425
01:10:40,360 --> 01:10:42,120
Zatto

1426
01:10:42,120 --> 01:10:46,159
è l'insieme delle formule F

1427
01:10:46,159 --> 01:10:53,239
tale che fai è in CNF

1428
01:10:54,360 --> 01:10:59,880
e fai è soddisfacile.

1429
01:11:01,760 --> 01:11:05,040
Quand'è che una formula è soddisfacbile?

1430
01:11:05,040 --> 01:11:07,440
Quando esiste

1431
01:11:07,440 --> 01:11:11,320
un assegnamento di verità

1432
01:11:11,320 --> 01:11:13,760
per le sue variabili che rende la

1433
01:11:13,760 --> 01:11:17,120
formula vera. Quindi in questo caso, se

1434
01:11:17,120 --> 01:11:20,600
noi diamo x1

1435
01:11:20,600 --> 01:11:27,480
vero, x2 falso e x5 vero, soddisfacciamo

1436
01:11:27,480 --> 01:11:30,000
la formula f. Ok?

1437
01:11:30,000 --> 01:11:32,480
Quindi il problema della

1438
01:11:32,480 --> 01:11:35,199
soddisfaccibilità

1439
01:11:35,199 --> 01:11:39,000
di una formula buleana di questa forma,

1440
01:11:39,000 --> 01:11:43,159
ok? E questo, dato una formula garantita

1441
01:11:43,159 --> 01:11:46,320
ad avere questa formula qua, decidere se

1442
01:11:46,320 --> 01:11:48,480
esiste un assegnamento di verità per le

1443
01:11:48,480 --> 01:11:50,480
variabili buuleane, che significa

1444
01:11:50,480 --> 01:11:52,520
decidiamo se dare vero o falso alle

1445
01:11:52,520 --> 01:11:56,040
variabili buuleane. Quindi decidere se

1446
01:11:56,040 --> 01:11:59,159
esiste un assegnamento di verità che

1447
01:11:59,159 --> 01:12:01,239
renda la formula

1448
01:12:01,239 --> 01:12:04,600
vera. Ok? Questo è il problema della

1449
01:12:04,600 --> 01:12:08,760
soddisfacibilità che chiamiamo SAD.

1450
01:12:08,760 --> 01:12:12,159
Ok? Supponiamo che qualcuno ci dia un

1451
01:12:12,159 --> 01:12:14,760
assegnamento di verità per le variabili.

1452
01:12:14,760 --> 01:12:16,480
Ok?

1453
01:12:16,480 --> 01:12:19,560
Quanto tempo ci mettiamo

1454
01:12:19,560 --> 01:12:22,239
a stabilire se quell'assegnamento

1455
01:12:22,239 --> 01:12:26,600
soddisfa o meno la formula?

1456
01:12:32,440 --> 01:12:35,159
Costante. Attenzione, abbiamo la formula

1457
01:12:35,159 --> 01:12:38,639
in input che ha la sua lunghezza. Ok?

1458
01:12:38,639 --> 01:12:40,560
Provarlo o testarlo?
No, no, no, no.

1459
01:12:40,560 --> 01:12:43,840
Testarlo.
Tempo lineare.
Come?
Il tempo

1460
01:12:43,840 --> 01:12:45,440
lineare.

1461
01:12:45,440 --> 01:12:47,880
Tempo lineare o polinomiale. Ok. Quindi

1462
01:12:47,880 --> 01:12:50,960
qualcuno ci dà un assegnamento.

1463
01:12:50,960 --> 01:12:53,040
Nel momento abbia in cui abbiamo un

1464
01:12:53,040 --> 01:12:55,120
assegnamento in mano, in tempo

1465
01:12:55,120 --> 01:12:56,760
polinomiale noi siamo in grado di

1466
01:12:56,760 --> 01:12:58,679
stabilire se la formula è soddisfatta o

1467
01:12:58,679 --> 01:13:00,719
meno. Perché? Semplicemente noi dobbiamo

1468
01:13:00,719 --> 01:13:03,760
andare a guardare tutte le clausole e

1469
01:13:03,760 --> 01:13:07,080
vedere se almeno uno dei suoi letterali

1470
01:13:07,080 --> 01:13:08,960
è soddisfatto dall'assegnamento. Quindi

1471
01:13:08,960 --> 01:13:11,120
non è che chissà che cosa dobbiamo fare,

1472
01:13:11,120 --> 01:13:13,880
poiché la formula quella forma molto

1473
01:13:13,880 --> 01:13:16,679
particolare, noi clausola per clausola

1474
01:13:16,679 --> 01:13:18,920
andiamo a vedere se uno dei letterali

1475
01:13:18,920 --> 01:13:21,199
viene valutato o vero dall'assegnamento

1476
01:13:21,199 --> 01:13:24,880
che qualcuno ci ha dato. Ok? Chiaro?

1477
01:13:24,880 --> 01:13:27,159
Quindi,

1478
01:13:27,159 --> 01:13:30,120
nel momento in cui noi avessimo un

1479
01:13:30,120 --> 01:13:33,400
assegnamento di verità, testare se

1480
01:13:33,400 --> 01:13:35,280
soddisfa o meno una formula ci costa

1481
01:13:35,280 --> 01:13:39,199
tempo polinomiale. Ok? Ma quanti sono i

1482
01:13:39,199 --> 01:13:41,320
i possibili

1483
01:13:41,320 --> 01:13:43,719
assegnamenti

1484
01:13:43,719 --> 01:13:47,040
buleani per le nostre variabili?

1485
01:13:47,040 --> 01:13:51,239
2^ n. Ok? Quindi testare tutti i

1486
01:13:51,239 --> 01:13:54,280
possibili assegnamenti buleani per

1487
01:13:54,280 --> 01:13:57,520
vedere se ne esiste uno che soddisfa la

1488
01:13:57,520 --> 01:14:01,840
formula. Quanto ci costa?

1489
01:14:03,760 --> 01:14:07,560
Ci costa qualcosa tipo big o di 2^ n

1490
01:14:07,560 --> 01:14:10,400
dove n sono il numero di variabile per

1491
01:14:10,400 --> 01:14:13,199
qualcosa che è polinomiale nella taglia

1492
01:14:13,199 --> 01:14:14,960
della rappresentazione della formula.

1493
01:14:14,960 --> 01:14:18,040
Ok? No, non entriamo nel dettaglio. Ok?

1494
01:14:18,040 --> 01:14:22,159
Quindi questo algoritmo che testa,

1495
01:14:22,159 --> 01:14:24,440
no,

1496
01:14:24,440 --> 01:14:28,000
che testa se una formula è soddisfacbile

1497
01:14:28,000 --> 01:14:33,000
o meno, ci impiega exponential time. Ok?

1498
01:14:33,000 --> 01:14:35,040
Da ciò noi non siamo in grado di

1499
01:14:35,040 --> 01:14:38,639
concludere che

1500
01:14:38,639 --> 01:14:41,040
SAT sia in P, ma non lo possiamo

1501
01:14:41,040 --> 01:14:43,159
escludere. Semplicemente sappiamo che

1502
01:14:43,159 --> 01:14:45,639
questo algoritmo non lo colloca in P,

1503
01:14:45,639 --> 01:14:47,960
ok? Perché questo algoritmo ci mette

1504
01:14:47,960 --> 01:14:49,600
troppo tempo. Vi ricordo che i problemi

1505
01:14:49,600 --> 01:14:51,040
in P sono due problemi per i quali

1506
01:14:51,040 --> 01:14:53,360
esiste un algoritmo che li risolve in

1507
01:14:53,360 --> 01:14:55,639
polinomial time. Prendiamo questo

1508
01:14:55,639 --> 01:14:57,760
problema e lo mettiamo da parte. Ne

1509
01:14:57,760 --> 01:15:00,000
guardiamo un altro e poi facciamo delle

1510
01:15:00,000 --> 01:15:04,400
considerazioni su entrambi.

1511
01:15:05,080 --> 01:15:08,159
Independent set.

1512
01:15:08,159 --> 01:15:09,800
Questo è un altro problema che vedremo

1513
01:15:09,800 --> 01:15:13,320
spesso. Independent.

1514
01:15:13,600 --> 01:15:16,080
Sapete cos'è un independent set? Avete

1515
01:15:16,080 --> 01:15:19,000
mai sentito?

1516
01:15:19,000 --> 01:15:21,320
Ok. Un independent set è questa cosa

1517
01:15:21,320 --> 01:15:24,239
qua. Dato un grafo. Noi siamo

1518
01:15:24,239 --> 01:15:26,800
appassionati di grafi e ne abbiamo

1519
01:15:26,800 --> 01:15:29,199
sempre tanti. Ok.

1520
01:15:29,199 --> 01:15:32,360
dato un grafo,

1521
01:15:32,360 --> 01:15:35,840
un independent set di un grafo,

1522
01:15:35,840 --> 01:15:40,159
in questo caso non diretto, è un insieme

1523
01:15:40,159 --> 01:15:42,560
di nodi

1524
01:15:42,560 --> 01:15:46,320
che non sono agganciati in alcun modo,

1525
01:15:46,320 --> 01:15:49,000
ok? Quindi

1526
01:15:49,000 --> 01:15:58,639
S, vediamo, chiamiamo A B C D E F.

1527
01:15:58,679 --> 01:16:02,480
Per esempio, l'insieme

1528
01:16:02,520 --> 01:16:05,520
A

1529
01:16:05,679 --> 01:16:07,960
B C D, questo è che non si capisce

1530
01:16:07,960 --> 01:16:12,639
niente. A E D

1531
01:16:12,639 --> 01:16:15,520
è un independent set perché fra nessuna

1532
01:16:15,520 --> 01:16:17,120
delle,

1533
01:16:17,120 --> 01:16:20,880
cioè se prendiamo a coppie i nodi di S,

1534
01:16:20,880 --> 01:16:23,320
nessuna di queste coppie è agganciata in

1535
01:16:23,320 --> 01:16:25,199
maniera diretta. Ok? Quindi

1536
01:16:25,199 --> 01:16:28,960
un'indipendenza set è un insieme di nodi

1537
01:16:28,960 --> 01:16:33,480
che sta all'interno di un grafo che ha

1538
01:16:33,480 --> 01:16:36,000
la proprietà che

1539
01:16:36,000 --> 01:16:38,239
presi a coppie questi nodi non hanno un

1540
01:16:38,239 --> 01:16:40,960
arco che li congiunge, ok?

1541
01:16:40,960 --> 01:16:43,920
Quindi A per esempio è sganciato da E, A

1542
01:16:43,920 --> 01:16:47,120
è sganciato da D, D è sganciato da E.

1543
01:16:47,120 --> 01:16:49,600
Ragazzi, qua mi sto riferendo a un arco

1544
01:16:49,600 --> 01:16:52,560
diretto, non se c'è un percorso, eh,

1545
01:16:52,560 --> 01:16:56,520
quindi un independent set. è un grafo

1546
01:16:56,520 --> 01:17:00,159
tale per cui

1547
01:17:00,159 --> 01:17:02,120
eh

1548
01:17:02,120 --> 01:17:04,920
tale per cui un insieme di nodi tale per

1549
01:17:04,920 --> 01:17:08,199
cui questi sono sganciati a coppie. Ok?

1550
01:17:08,199 --> 01:17:11,000
Date un grafo.

1551
01:17:11,000 --> 01:17:12,760
Esiste un indipendent set di questo

1552
01:17:12,760 --> 01:17:14,280
grafo

1553
01:17:14,280 --> 01:17:17,480
in genere?

1554
01:17:18,719 --> 01:17:20,239
Mh.

1555
01:17:20,239 --> 01:17:23,120
Sì. Cioè, quindi cercare indipendenti

1556
01:17:23,120 --> 01:17:25,679
set piccoli è un problema estremamente

1557
01:17:25,679 --> 01:17:27,679
facile, quindi è un problema che non ci

1558
01:17:27,679 --> 01:17:28,920
interessa la definizione

1559
01:17:28,920 --> 01:17:31,040
dell'indipendent set, quindi la diamo

1560
01:17:31,040 --> 01:17:32,560
differente.

1561
01:17:32,560 --> 01:17:36,159
Independent set è l'insieme delle coppie

1562
01:17:36,159 --> 01:17:40,120
grafo numero intero k tale per cui

1563
01:17:40,120 --> 01:17:42,840
esiste

1564
01:17:42,840 --> 01:17:47,760
un independent set di taglia

1565
01:17:47,760 --> 01:17:50,760
K.

1566
01:17:50,960 --> 01:17:52,880
in G.

1567
01:17:52,880 --> 01:17:55,880
Ok?

1568
01:17:56,400 --> 01:17:58,320
Questo è il problema dell'indipendenzet

1569
01:17:58,320 --> 01:18:00,560
che fra l'altro ci permette di ottenere

1570
01:18:00,560 --> 01:18:03,440
un problema di decisione. Ok? Quindi

1571
01:18:03,440 --> 01:18:05,239
questa è una variante decisionale del

1572
01:18:05,239 --> 01:18:08,080
problema in cui abbiamo dato un dato un

1573
01:18:08,080 --> 01:18:11,440
grafo e un numero K5. È vero, no? che

1574
01:18:11,440 --> 01:18:13,320
esiste un indipenden set di taglia 5

1575
01:18:13,320 --> 01:18:14,960
dentro questo grafo. Ecco, questo è un

1576
01:18:14,960 --> 01:18:17,199
problema più interessante rispetto a

1577
01:18:17,199 --> 01:18:18,560
dire dato un grafo, esiste un

1578
01:18:18,560 --> 01:18:21,400
independent set, è un problema trivial

1579
01:18:21,400 --> 01:18:23,280
perché la risposta è sempre sì.

1580
01:18:23,280 --> 01:18:26,800
L'insieme vuoto è un indipendent set del

1581
01:18:26,800 --> 01:18:28,719
grafo, sempre. Ok? Quindi quando abbiamo

1582
01:18:28,719 --> 01:18:30,600
un vincolo sulla cardinalità

1583
01:18:30,600 --> 01:18:32,239
dell'indipendenza set, allora la cosa

1584
01:18:32,239 --> 01:18:36,000
diventa un po' più interessante. Ok?

1585
01:18:36,000 --> 01:18:39,080
Supponiamo che qualcuno ci dia un

1586
01:18:39,080 --> 01:18:41,480
insieme S.

1587
01:18:41,480 --> 01:18:44,239
Quanto tempo ci mettiamo a stabilire che

1588
01:18:44,239 --> 01:18:48,719
quell'insieme S è o no un'indipendet?

1589
01:18:48,719 --> 01:18:54,320
Si può fare una BFS su nodo? Forse
eh

1590
01:18:54,320 --> 01:18:57,719
cos'è una BFS? Si.
Eh, ricerca.
Ah, ok.

1591
01:18:57,719 --> 01:19:00,199
Bread first. Ah, ok, ok, ok. La cosa è

1592
01:19:00,199 --> 01:19:02,960
ancora più semplice, cioè ci danno un

1593
01:19:02,960 --> 01:19:05,239
insieme, noi dobbiamo stabilire se

1594
01:19:05,239 --> 01:19:09,719
quello è un indipendenzetto o meno.
Sì.

1595
01:19:09,719 --> 01:19:13,800
Sì. Ah, io cè eh
cioè se n è il numero

1596
01:19:13,800 --> 01:19:17,760
di nodi del grafo, sarà tipo n rentale.

1597
01:19:17,760 --> 01:19:20,520
Sì,
sì, è è poco, è polinomiale. Cioè

1598
01:19:20,520 --> 01:19:23,480
noi per ogni nodo dobbiamo vedere se in

1599
01:19:23,480 --> 01:19:26,360
quell'ess che ci danno per caso dentro s

1600
01:19:26,360 --> 01:19:28,480
ci sta roba che è attaccata a quel nodo.

1601
01:19:28,480 --> 01:19:30,600
Lo facciamo per tutte le coppie. Le

1602
01:19:30,600 --> 01:19:32,679
coppie sono quadratiche, quindi in tempo

1603
01:19:32,679 --> 01:19:34,600
quadratico noi questa cosa siamo in

1604
01:19:34,600 --> 01:19:36,920
grado di farla. Ok?

1605
01:19:36,920 --> 01:19:40,400
Ma quanti sono i possibili sotto i

1606
01:19:40,400 --> 01:19:42,760
possibili

1607
01:19:42,760 --> 01:19:47,199
indipendentet di taglia K?

1608
01:19:48,080 --> 01:19:51,080
N

1609
01:19:51,239 --> 01:19:56,199
Sì, sì, sì, sì, sì. Sono N su K. Ok.

1610
01:19:56,199 --> 01:20:00,679
Abbiamo necessità di eh cercare robe più

1611
01:20:00,679 --> 01:20:04,159
grandi? No, perché il problema ci chiede

1612
01:20:04,159 --> 01:20:05,800
semplicemente se esiste un indipenden

1613
01:20:05,800 --> 01:20:08,239
set di taglia almeno K. Quindi, nel

1614
01:20:08,239 --> 01:20:10,120
momento in cui ne troviamo uno di taglia

1615
01:20:10,120 --> 01:20:11,880
K, non c'è bisogno di andare a cercare

1616
01:20:11,880 --> 01:20:14,600
indipendetti di taglia K + 1. Ok? Ci

1617
01:20:14,600 --> 01:20:17,639
fermiamo là. Quindi noi dovremmo

1618
01:20:17,639 --> 01:20:19,400
generare

1619
01:20:19,400 --> 01:20:21,480
n

1620
01:20:21,480 --> 01:20:24,840
N su k insiemi e poi avere un costo di

1621
01:20:24,840 --> 01:20:27,639
tipo quadratico. Ok? Questo qua è

1622
01:20:27,639 --> 01:20:29,600
nuovamente esponenziale, quindi questo

1623
01:20:29,600 --> 01:20:34,159
algoritmo è esponenziale. Ok?

1624
01:20:34,159 --> 01:20:35,679
Però

1625
01:20:35,679 --> 01:20:38,560
e qui ci introduciamo il concetto

1626
01:20:38,560 --> 01:20:41,520
interessante di oggi.

1627
01:20:41,520 --> 01:20:46,400
Questo problemi SAT e independent set

1628
01:20:46,400 --> 01:20:48,600
abbiamo visto che hanno algoritmi che

1629
01:20:48,600 --> 01:20:50,880
rannano in tempo esponenziale,

1630
01:20:50,880 --> 01:20:54,120
però perché stiamo escludendo finora di

1631
01:20:54,120 --> 01:20:56,960
utilizzare macchine non deterministiche?

1632
01:20:56,960 --> 01:20:58,520
Se avessimo macchine non

1633
01:20:58,520 --> 01:21:00,440
deterministiche, noi potremmo andare

1634
01:21:00,440 --> 01:21:05,159
molto più velocemente. Ok? Perché qual è

1635
01:21:05,159 --> 01:21:06,880
l'intuizione,

1636
01:21:06,880 --> 01:21:09,560
per esempio, su independent set? Una

1637
01:21:09,560 --> 01:21:12,560
macchina non deterministica, invece di

1638
01:21:12,560 --> 01:21:14,719
provare tutti i possibili sottoinsiemi

1639
01:21:14,719 --> 01:21:17,520
di taglia K per vedere se c'è un

1640
01:21:17,520 --> 01:21:20,520
indipendent set di taglia K, quello che

1641
01:21:20,520 --> 01:21:23,280
può fare è gessarlo un indipendent set

1642
01:21:23,280 --> 01:21:26,600
di taglia K. C'è

1643
01:21:26,600 --> 01:21:28,440
in maniera similare, pure sulla

1644
01:21:28,440 --> 01:21:30,199
soddisfacilità, una macchina non

1645
01:21:30,199 --> 01:21:32,159
deterministica può gessare

1646
01:21:32,159 --> 01:21:34,920
l'assegnamento di verità che soddisfa la

1647
01:21:34,920 --> 01:21:37,400
formula se uno c'è. Praticamente il

1648
01:21:37,400 --> 01:21:39,480
lavoro che può fare la macchina non

1649
01:21:39,480 --> 01:21:41,280
deterministica, supponiamo che questa

1650
01:21:41,280 --> 01:21:45,360
sia la configurazione iniziale ID0.

1651
01:21:45,360 --> 01:21:48,040
Per esempio, su independent set che deve

1652
01:21:48,040 --> 01:21:49,800
fare la macchina? deve fare una cosa

1653
01:21:49,800 --> 01:21:52,800
molto semplice. Preso ogni nodo, deve

1654
01:21:52,800 --> 01:21:55,560
stabilire lo pigliamo, non lo pigliamo.

1655
01:21:55,560 --> 01:21:59,360
Ok? Quindi c'ha un branching factor di 2

1656
01:21:59,360 --> 01:22:01,760
in cui da un lato dice il nodo lo

1657
01:22:01,760 --> 01:22:04,679
prendo, dall'altro il nodo non lo prendo

1658
01:22:04,679 --> 01:22:07,639
per il primo nodo. Poi avremo un'altra

1659
01:22:07,639 --> 01:22:10,400
cosa così in cui sul secondo nodo decido

1660
01:22:10,400 --> 01:22:13,199
se lo prendo o non lo prendo. Dall'altro

1661
01:22:13,199 --> 01:22:15,560
lato se il secondo nodo lo prendo o non

1662
01:22:15,560 --> 01:22:20,320
lo prendo e lo possiamo fare per tutti i

1663
01:22:20,320 --> 01:22:24,000
nodi. Ok?

1664
01:22:26,719 --> 01:22:29,560
per arrivare a delle configurazioni nel

1665
01:22:29,560 --> 01:22:32,760
quale la macchina ha deciso per tutti i

1666
01:22:32,760 --> 01:22:34,280
nodi

1667
01:22:34,280 --> 01:22:37,960
se li prende o meno. Ok? E quindi è una

1668
01:22:37,960 --> 01:22:40,199
cosa che la macchina, un attimo, vi

1669
01:22:40,199 --> 01:22:42,480
ricordate che avevamo fatto l'avevamo

1670
01:22:42,480 --> 01:22:45,000
fatto apposta quell'esercizio, quella

1671
01:22:45,000 --> 01:22:46,639
quella macchina che era in grado di

1672
01:22:46,639 --> 01:22:49,920
trovare le stringhe che si replicavano,

1673
01:22:49,920 --> 01:22:52,880
però non lo selezionava da nastro, lo

1674
01:22:52,880 --> 01:22:56,120
sputava sul nastro all'inizio. quel

1675
01:22:56,120 --> 01:22:57,760
trucchetto ve l'avevo fatto apposta

1676
01:22:57,760 --> 01:22:59,719
perché mi serviva qua. Cioè questa

1677
01:22:59,719 --> 01:23:02,159
macchina inuring o questo algoritmo nel

1678
01:23:02,159 --> 01:23:03,719
momento in cui trova deve trovare un

1679
01:23:03,719 --> 01:23:06,120
indipendent set sul grafo G, quello che

1680
01:23:06,120 --> 01:23:08,960
fa è sputa sul nastro questa cosa. Il

1681
01:23:08,960 --> 01:23:10,719
primo nodo non lo prendo, il secondo

1682
01:23:10,719 --> 01:23:12,920
nodo sì, il terzo sì, il quarto pure, il

1683
01:23:12,920 --> 01:23:14,600
quinto no, il sesto non mi piace, il

1684
01:23:14,600 --> 01:23:16,719
settimo sì, l'ottavo no. Ok? Cioè,

1685
01:23:16,719 --> 01:23:18,800
quindi la macchina all'inizio che fa?

1686
01:23:18,800 --> 01:23:20,760
Non deterministicamente

1687
01:23:20,760 --> 01:23:23,639
sceglie per ogni nodo se lo prende o non

1688
01:23:23,639 --> 01:23:26,040
lo prende. Ok? E questa è la fase non

1689
01:23:26,040 --> 01:23:28,960
deterministica di Gess in cui sta

1690
01:23:28,960 --> 01:23:31,440
gessando l'indipendent

1691
01:23:31,440 --> 01:23:33,199
candidato.

1692
01:23:33,199 --> 01:23:35,080
È chiaro?

1693
01:23:35,080 --> 01:23:37,159
una domanda che non ho capito bene, nel

1694
01:23:37,159 --> 01:23:40,480
senso noi eh, anzi lei ha detto che la

1695
01:23:40,480 --> 01:23:42,159
macchina

1696
01:23:42,159 --> 01:23:44,840
lei intende che costruisce l'albero di

1697
01:23:44,840 --> 01:23:46,800
espansione delle mosse oppure dato

1698
01:23:46,800 --> 01:23:48,840
l'albero di espansione

1699
01:23:48,840 --> 01:23:52,400
tenere la le diciamo il percorso

1700
01:23:52,400 --> 01:23:54,639
ottimale per giungere alla conclusione?

1701
01:23:54,639 --> 01:23:58,400
La macchina non fa né l'uno né l'altro.

1702
01:23:58,400 --> 01:24:01,120
La macchina per la definizione di

1703
01:24:01,120 --> 01:24:03,280
accettazione di computazione non

1704
01:24:03,280 --> 01:24:05,600
deterministica è la macchina accetta il

1705
01:24:05,600 --> 01:24:07,560
proprio input se esiste un modo per

1706
01:24:07,560 --> 01:24:10,040
accettare. Quindi se fra tutti quei

1707
01:24:10,040 --> 01:24:12,239
branch del possibile modo per la

1708
01:24:12,239 --> 01:24:13,960
macchina di dire questo nodo sì, questo

1709
01:24:13,960 --> 01:24:16,239
nodo no, questo nodo no, questo nodo sì,

1710
01:24:16,239 --> 01:24:18,199
se fra tutte quelle possibilità ce n'è

1711
01:24:18,199 --> 01:24:20,360
una che porterebbe la macchina a

1712
01:24:20,360 --> 01:24:21,920
rispondere sì sul proprio input, la

1713
01:24:21,920 --> 01:24:24,199
macchina dice di sì. Cioè, non è che

1714
01:24:24,199 --> 01:24:26,199
fisicamente espande il proprio albero di

1715
01:24:26,199 --> 01:24:29,360
computazione perché la macchina la

1716
01:24:29,360 --> 01:24:32,199
macchina non esiste. E la definizione,

1717
01:24:32,199 --> 01:24:34,040
ritorniamo a quella a quel problema

1718
01:24:34,040 --> 01:24:35,960
filosofico iniziale di quando guardavamo

1719
01:24:35,960 --> 01:24:38,159
alle macchine non deterministiche. La

1720
01:24:38,159 --> 01:24:40,880
macchina se ha un modo, ovviamente non è

1721
01:24:40,880 --> 01:24:42,639
finito, è là c'è tutta la parte di

1722
01:24:42,639 --> 01:24:44,199
cerchio che dobbiamo aggiungere. Lì

1723
01:24:44,199 --> 01:24:46,119
manca ancora.

1724
01:24:46,119 --> 01:24:48,000
La macchina

1725
01:24:48,000 --> 01:24:50,239
tenta, la macchina scrive queste cose

1726
01:24:50,239 --> 01:24:52,080
sul nastro. Fra tutte le cose che la

1727
01:24:52,080 --> 01:24:54,440
macchina può scrivere, se ce n'è una che

1728
01:24:54,440 --> 01:24:58,400
è un indipendent set la becca, diciamo.

1729
01:24:58,400 --> 01:25:00,239
Però di fatto non è che è veramente in

1730
01:25:00,239 --> 01:25:04,199
grado di di indovinarla. La macchina

1731
01:25:04,199 --> 01:25:06,440
tra le sue strade c'ha quella che la

1732
01:25:06,440 --> 01:25:08,320
porta a dire di sì.

1733
01:25:08,320 --> 01:25:10,400
Cioè, allora, ho capito quello che dice

1734
01:25:10,400 --> 01:25:13,159
lei, però non capisco, pur essendo

1735
01:25:13,159 --> 01:25:15,280
comunque una rappresentazione teorica,

1736
01:25:15,280 --> 01:25:18,719
cioè non esiste, eh la persona che

1737
01:25:18,719 --> 01:25:21,400
effettivamente va a calcolare un il

1738
01:25:21,400 --> 01:25:23,800
costo di una macchina determinista, cioè

1739
01:25:23,800 --> 01:25:25,560
non va a creare comunque un qualcosa,

1740
01:25:25,560 --> 01:25:27,239
non va a creare l'insieme delle

1741
01:25:27,239 --> 01:25:29,960
soluzioni per giungere al costo in sé e

1742
01:25:29,960 --> 01:25:32,080
a running time, il running time di una

1743
01:25:32,080 --> 01:25:34,199
macchina non deterministica è il running

1744
01:25:34,199 --> 01:25:36,679
time del branch più lungo, quindi quanto

1745
01:25:36,679 --> 01:25:40,760
ci costa ci costa gessare, cioè buttare

1746
01:25:40,760 --> 01:25:43,679
sul nastro la decisione sino per ogni

1747
01:25:43,679 --> 01:25:46,040
nodo e quello è OD N, ad esempio.

1748
01:25:46,040 --> 01:25:48,400
Dopodiché c'è tutta la fase di check che

1749
01:25:48,400 --> 01:25:51,040
sarà quadratico per stabilire se la cosa

1750
01:25:51,040 --> 01:25:53,199
che è stata ghessata è in effetti

1751
01:25:53,199 --> 01:25:56,040
un'indipendenza o meno. Però, cioè

1752
01:25:56,040 --> 01:26:00,040
questa è la cosa, la la persona che va a

1753
01:26:00,040 --> 01:26:01,800
verificare la macchina, il presupposto

1754
01:26:01,800 --> 01:26:03,440
linguistico di questa frase è che noi

1755
01:26:03,440 --> 01:26:05,280
abbiamo la macchina, la macchina non

1756
01:26:05,280 --> 01:26:08,760
c'è. Cioè, quindi chiedersi che genere

1757
01:26:08,760 --> 01:26:10,800
di passi faccia la macchina durante

1758
01:26:10,800 --> 01:26:12,800
questo tipo di computazione è qualcosa

1759
01:26:12,800 --> 01:26:15,760
di cuorbiante.

1760
01:26:15,760 --> 01:26:18,040
A noi ci torna comodo nel momento in cui

1761
01:26:18,040 --> 01:26:20,280
lo pensiamo dire "Ok, questa macchina è

1762
01:26:20,280 --> 01:26:23,679
indovina", ma non è così, è per noi una

1763
01:26:23,679 --> 01:26:28,880
metafora.
Ok, grazie.
Ok, leiamo

1764
01:26:28,880 --> 01:26:32,199
sul sul
Ok, quindi la macchina che può

1765
01:26:32,199 --> 01:26:35,560
fare per ogni nodo. Sì, questo mi piace.

1766
01:26:35,560 --> 01:26:37,199
Questo no, questo lo piglio, questo lo

1767
01:26:37,199 --> 01:26:38,600
escludo, quest'altro lo escludo. E

1768
01:26:38,600 --> 01:26:41,000
insomma arriva a questo livello della

1769
01:26:41,000 --> 01:26:42,840
computazione nel quale la macchina avrà

1770
01:26:42,840 --> 01:26:44,679
scritto sul nastro per ogni nodo se lo

1771
01:26:44,679 --> 01:26:48,199
prende o meno. Dopodiché qui c'è tutta

1772
01:26:48,199 --> 01:26:50,239
la fase di jack che è deterministica,

1773
01:26:50,239 --> 01:26:53,400
quindi sono delle liste, no?

1774
01:26:53,400 --> 01:26:55,760
In cui la macchina che fa?

1775
01:26:55,760 --> 01:26:59,080
Uno, verifica che due cose deve

1776
01:26:59,080 --> 01:27:00,679
verificare.

1777
01:27:00,679 --> 01:27:03,560
Uno, verifica che il numero dei nodi

1778
01:27:03,560 --> 01:27:07,400
scelti sia al-men K, perché la macchina

1779
01:27:07,400 --> 01:27:09,400
la sta buttando a caso, eh, quella parte

1780
01:27:09,400 --> 01:27:11,080
iniziale la macchina non sta facendo

1781
01:27:11,080 --> 01:27:13,880
niente, scrive cose sul nastro, eh,

1782
01:27:13,880 --> 01:27:17,840
quindi come facciamo ad accettare uno?

1783
01:27:17,840 --> 01:27:19,679
Il numero totale dei nodi su cui abbiamo

1784
01:27:19,679 --> 01:27:23,159
deciso di prenderli è almeno K.

1785
01:27:23,159 --> 01:27:25,199
E poi nella fase nella seconda fase di

1786
01:27:25,199 --> 01:27:27,239
check dobbiamo verificare che quello che

1787
01:27:27,239 --> 01:27:29,080
abbiamo scelto di prendere costituisce

1788
01:27:29,080 --> 01:27:32,199
un indipendente. Ok?
Io dentro posso

1789
01:27:32,199 --> 01:27:34,280
mettere anche nodi effettivamente

1790
01:27:34,280 --> 01:27:36,320
collegati, però devo controllare se
Sì,

1791
01:27:36,320 --> 01:27:39,239
quei branch branch relativi a scelte non

1792
01:27:39,239 --> 01:27:42,560
sensate terminano in una configurazione

1793
01:27:42,560 --> 01:27:44,760
non accettate, quindi vanno a sbattere

1794
01:27:44,760 --> 01:27:46,920
contro un muro. Ok? L'importante è che

1795
01:27:46,920 --> 01:27:50,280
noi qua nel check ci saranno alcuni

1796
01:27:50,280 --> 01:27:51,840
branch

1797
01:27:51,840 --> 01:27:54,000
rifiutano, altri che accettano, altri

1798
01:27:54,000 --> 01:27:56,560
che rifiutano. Ok? E se c'è un modo per

1799
01:27:56,560 --> 01:27:58,080
la macchina di accettare il proprio

1800
01:27:58,080 --> 01:28:00,400
input, la macchina dice di sì. Quanto

1801
01:28:00,400 --> 01:28:04,400
tempo ci mette la macchina,

1802
01:28:06,040 --> 01:28:07,639
Rffley?

1803
01:28:07,639 --> 01:28:09,400
Tempo lineare.
Ci mette un tempo

1804
01:28:09,400 --> 01:28:11,600
polinomiale, ok? Ci mette tempo lineare

1805
01:28:11,600 --> 01:28:13,320
a fare il guess e poi ci mette tempo

1806
01:28:13,320 --> 01:28:17,280
quadratico a fare questo check, ok?

1807
01:28:17,280 --> 01:28:20,400
Similmente per SAT.

1808
01:28:20,400 --> 01:28:22,119
Una macchina non deterministica può fare

1809
01:28:22,119 --> 01:28:24,960
una cosa simile a per SAT. Gessa in

1810
01:28:24,960 --> 01:28:27,360
tempo lineare un assegnamento di verità

1811
01:28:27,360 --> 01:28:30,320
per le variabili, dopodiché verifica che

1812
01:28:30,320 --> 01:28:32,280
quello che ha ghessato stia

1813
01:28:32,280 --> 01:28:34,320
effettivamente soddisfacendo la formula.

1814
01:28:34,320 --> 01:28:37,400
Quanto tempo ci mettiamo? polinomiale.

1815
01:28:37,400 --> 01:28:39,560
Allora, questi problemi sono

1816
01:28:39,560 --> 01:28:42,159
interessanti perché perché ci

1817
01:28:42,159 --> 01:28:45,360
selezionano, ci identificano

1818
01:28:45,360 --> 01:28:48,000
una classe di complessità importante che

1819
01:28:48,000 --> 01:28:50,440
è la classe dei problemi

1820
01:28:50,440 --> 01:28:52,679
risolvibili in tempo polinomiale non

1821
01:28:52,679 --> 01:28:55,760
deterministico. Ok? Quindi definiamo,

1822
01:28:55,760 --> 01:28:57,560
questi sono gli ultimi minuti, ci siamo

1823
01:28:57,560 --> 01:29:00,560
quasi.

1824
01:29:00,560 --> 01:29:07,000
Sia tn una time function.

1825
01:29:09,520 --> 01:29:15,119
La classe di complessità n time di TD n

1826
01:29:15,119 --> 01:29:19,920
è l'insieme di tutti i linguaggi L

1827
01:29:19,920 --> 01:29:23,800
tali per cui esiste una macchina M non

1828
01:29:23,800 --> 01:29:26,679
deterministica

1829
01:29:26,679 --> 01:29:31,159
che decide

1830
01:29:31,440 --> 01:29:34,840
L in tempo.

1831
01:29:36,000 --> 01:29:38,960
o di TDN.

1832
01:29:38,960 --> 01:29:42,760
Chiaro? Quindi N time, a differenza di

1833
01:29:42,760 --> 01:29:44,480
Dime,

1834
01:29:44,480 --> 01:29:47,360
è l'insieme dei linguaggi che possono

1835
01:29:47,360 --> 01:29:51,159
essere decisi da macchine di touring non

1836
01:29:51,159 --> 01:29:54,719
deterministiche. Ecco perché usiamo N

1837
01:29:54,719 --> 01:29:57,239
all'inizio, da macchine di Touring non

1838
01:29:57,239 --> 01:30:02,239
deterministiche in tempo bit o BTDN.

1839
01:30:02,239 --> 01:30:03,960
molto simile alla definizione

1840
01:30:03,960 --> 01:30:06,679
precedente, possiamo definire la classe

1841
01:30:06,679 --> 01:30:10,320
NP, che sicuramente avrete già sentito.

1842
01:30:10,320 --> 01:30:14,480
La classe NP è semplicemente l'unione su

1843
01:30:14,480 --> 01:30:20,520
tutti gli core 1 di cosa? Di n

1844
01:30:20,520 --> 01:30:24,080
c eh di n^ c.

1845
01:30:24,080 --> 01:30:29,199
Ok? Questa è la classe np.

1846
01:30:29,199 --> 01:30:30,920
NP

1847
01:30:30,920 --> 01:30:34,080
non sta per non polinomia, quello è un

1848
01:30:34,080 --> 01:30:37,920
errore. NP sta per non deterministic

1849
01:30:37,920 --> 01:30:40,880
polinomial perché i problemi che stanno

1850
01:30:40,880 --> 01:30:43,880
in NP, come vedremo poi la prossima

1851
01:30:43,880 --> 01:30:47,159
volta, non è che lo sappiamo se siano o

1852
01:30:47,159 --> 01:30:49,719
meno polinomiali.

1853
01:30:49,719 --> 01:30:51,840
Non abbiamo algoritmi polinomiali, ma al

1854
01:30:51,840 --> 01:30:53,440
momento non possiamo nemmeno escluderlo,

1855
01:30:53,440 --> 01:30:54,920
ok? Quello questo è lo stato delle

1856
01:30:54,920 --> 01:30:58,480
conoscenze attuali. Quindi NP sta per

1857
01:30:58,480 --> 01:31:03,199
non deterministic polynomial time. Ok? E

1858
01:31:03,199 --> 01:31:06,400
il problemi SAT e Independence Set è

1859
01:31:06,400 --> 01:31:08,360
tutta una pletora di problemi

1860
01:31:08,360 --> 01:31:10,280
interessantissimi.

1861
01:31:10,280 --> 01:31:14,199
Napsac, Beaming, Hamiltonian Cycle, bla

1862
01:31:14,199 --> 01:31:17,639
bla bla, sono tutti problemi che stanno

1863
01:31:17,639 --> 01:31:22,239
dentro la classe NP. Ok?

1864
01:31:22,239 --> 01:31:25,520
E con questo chiudiamo per oggi.

1865
01:31:25,520 --> 01:31:28,080
Grazie mille.

1866
01:31:28,080 --> 01:31:31,040
Ok,

1867
01:31:31,040 --> 01:31:34,040
fatto.

1868
01:31:39,270 --> 01:31:42,369
[Musica]

1869
01:31:46,239 --> 01:31:47,639
Quindi la classe MP esiste

1870
01:31:47,639 --> 01:31:49,119
sostanzialmente perché non abbiamo

1871
01:31:49,119 --> 01:31:50,520
trovato un modo migliore per

1872
01:31:50,520 --> 01:31:51,760
rappresontare la macchina non

1873
01:31:51,760 --> 01:31:54,760
deterministica.

1874
01:31:55,360 --> 01:31:58,440
Es esattamente.

1875
01:32:05,080 --> 01:32:08,520
Ho una vaga idea delle date fissare,

1876
01:32:08,520 --> 01:32:11,790
però è tipo magorale,

1877
01:32:11,790 --> 01:32:14,960
[Musica]

1878
01:32:16,600 --> 01:32:19,719
ma se c'è l'orale sarà

1879
01:32:19,719 --> 01:32:21,239
orale

1880
01:32:21,239 --> 01:32:24,679
se può darsi che

1881
01:32:24,679 --> 01:32:27,679
Ok.

1882
01:32:33,440 --> 01:32:36,490
[Musica]

1883
01:32:43,239 --> 01:32:46,679
Dove sta lauzia?

1884
01:32:47,220 --> 01:32:52,199
[Musica]

1885
01:32:52,199 --> 01:32:56,159
Niente, la pennzut

1886
01:32:56,880 --> 01:32:58,080
non hanno ancora definito, se non

1887
01:32:58,080 --> 01:33:00,000
sbaglio, se ci sarà un orale, un

1888
01:33:00,000 --> 01:33:02,600
scritto.
Allora, ci sarà sicuramente lo

1889
01:33:02,600 --> 01:33:04,560
scritto, però è una cosa che stabilisco

1890
01:33:04,560 --> 01:33:07,360
in queste settimane, però
occhio e croce

1891
01:33:07,360 --> 01:33:09,760
sicuramente c'è uno scritto l'orale, se

1892
01:33:09,760 --> 01:33:13,560
c'è sarà opzionale. Sarà opzionale. No,

1893
01:33:13,560 --> 01:33:16,199
le dimostrazioni saranno pure ceste. Sì,

1894
01:33:16,199 --> 01:33:21,239
sì, sì, sì. Però l'orale se non un filo

1895
01:33:22,400 --> 01:33:24,480
no era per capire se era molto teorico,

1896
01:33:24,480 --> 01:33:28,159
quindi dimostrare teorico, cioè che sia

1897
01:33:28,159 --> 01:33:31,000
scritto che sia ci sarà probabilmente

1898
01:33:31,000 --> 01:33:32,920
una macchina di touring da scrivere,

1899
01:33:32,920 --> 01:33:35,800
però il resto sarà dimostrare che è bla.

1900
01:33:35,800 --> 01:33:38,440
dimostrare che è quindi sì, sia lo

1901
01:33:38,440 --> 01:33:41,639
scritto che l'orane saranno molto a

1902
01:33:41,639 --> 01:33:45,040
parte un esercizio

1903
01:33:46,119 --> 01:33:48,520
anche a lei.

1904
01:34:05,119 --> 01:34:09,639
Questo l'avevo stoppato. No, no.