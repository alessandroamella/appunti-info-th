1
00:00:02,760 --> 00:00:06,040
[Musica]

2
00:00:23,550 --> 00:00:26,690
[Musica]

3
00:00:32,500 --> 00:00:35,570
[Musica]

4
00:00:50,079 --> 00:00:53,559
Ok. Eh,

5
00:00:53,559 --> 00:00:56,079
oggi continuiamo con Space Complexity

6
00:00:56,079 --> 00:00:58,600
che abbiamo iniziato ieri.

7
00:00:58,600 --> 00:01:00,079
Vediamo un altro po' di classi, poi

8
00:01:00,079 --> 00:01:02,719
chiudiamo su questo. Settimana prossima

9
00:01:02,719 --> 00:01:06,280
faremo macchine con oracoli,

10
00:01:06,280 --> 00:01:09,159
functional problems e chiudiamo. Poi

11
00:01:09,159 --> 00:01:12,320
facciamo il mock exam l'ultimo giorno.

12
00:01:12,320 --> 00:01:15,159
Ok.

13
00:01:15,159 --> 00:01:19,240
Ah, alright.

14
00:01:19,400 --> 00:01:20,920
Ok. Quindi, che abbiamo fatto ieri? Ieri

15
00:01:20,920 --> 00:01:24,280
abbiamo introdotto questo concetto di

16
00:01:24,280 --> 00:01:26,720
space complexity,

17
00:01:26,720 --> 00:01:29,880
spaceed complexity classes

18
00:01:29,880 --> 00:01:33,240
e abbiamo definito dispace, nespace e

19
00:01:33,240 --> 00:01:36,360
così via. Dopodiché ci siamo focalizzati

20
00:01:36,360 --> 00:01:38,640
su long space, non deterministic long

21
00:01:38,640 --> 00:01:41,960
space. Abbiamo visto un paio di eh

22
00:01:41,960 --> 00:01:45,240
abbiamo visto un paio di

23
00:01:45,240 --> 00:01:47,360
problemi.

24
00:01:47,360 --> 00:01:49,310
Questo prende

25
00:01:49,310 --> 00:01:52,000
[Musica]

26
00:01:52,000 --> 00:01:54,840
Abbiamo visto un paio di problemi. Ehm

27
00:01:54,840 --> 00:01:55,960
l'ultimo che abbiamo visto è

28
00:01:55,960 --> 00:01:58,680
Richability. abbiamo visto essere non

29
00:01:58,680 --> 00:02:03,079
deterministic log space completo

30
00:02:03,200 --> 00:02:06,159
e siccome c'è quel risultato che abbiamo

31
00:02:06,159 --> 00:02:07,840
solamente accennato, non abbiamo

32
00:02:07,840 --> 00:02:10,080
dimostrato, ma la dimostrazione non è

33
00:02:10,080 --> 00:02:12,319
molto differente da quella similare su P

34
00:02:12,319 --> 00:02:15,280
versus NP, abbiamo che se o è un

35
00:02:15,280 --> 00:02:17,840
qualsiasi problema non deterministic log

36
00:02:17,840 --> 00:02:20,239
space completo

37
00:02:20,239 --> 00:02:23,160
fosse il log space deterministico,

38
00:02:23,160 --> 00:02:27,400
allora L sarebbe uguale ML. Ok?

39
00:02:27,400 --> 00:02:29,599
Quindi per questa ragione noi non

40
00:02:29,599 --> 00:02:34,040
riteniamo che ritability sia in L, cioè

41
00:02:34,040 --> 00:02:36,560
non riteniamo che sia possibile decidere

42
00:02:36,560 --> 00:02:39,800
ritability in spazio logaritmico

43
00:02:39,800 --> 00:02:42,800
deterministico. Ok? Però quello che

44
00:02:42,800 --> 00:02:46,000
vedremo ora

45
00:02:46,000 --> 00:02:48,720
è un risultato interessante riguardo la

46
00:02:48,720 --> 00:02:51,840
complessità di Richanisce

47
00:02:51,840 --> 00:02:55,599
fornirà il un passo intermedio per il

48
00:02:55,599 --> 00:02:58,040
teorema di Sadic che vediamo vediamo più

49
00:02:58,040 --> 00:03:00,080
tardi. Ok?

50
00:03:00,080 --> 00:03:03,360
Allora, sebbene noi non siamo in grado

51
00:03:03,360 --> 00:03:08,799
di dimostrare che richility

52
00:03:09,599 --> 00:03:14,200
appartenga a L, che vi ricordo L è D

53
00:03:14,200 --> 00:03:17,080
space

54
00:03:17,080 --> 00:03:20,319
di log n.

55
00:03:20,319 --> 00:03:21,799
Quello che siamo però in grado di

56
00:03:21,799 --> 00:03:23,720
dimostrare

57
00:03:23,720 --> 00:03:28,120
è che rich ability

58
00:03:28,680 --> 00:03:33,040
appartiene a dispace

59
00:03:33,720 --> 00:03:36,280
log square n.

60
00:03:36,280 --> 00:03:40,080
Ok? Log square intendo che è questa cosa

61
00:03:40,080 --> 00:03:45,840
qua, eh? log n quad.

62
00:03:45,840 --> 00:03:48,280
Quello è polilogaritmico,

63
00:03:48,280 --> 00:03:50,439
quindi noi siamo in grado di dimostrare

64
00:03:50,439 --> 00:03:54,840
che utility sta là dentro. L'algoritmo

65
00:03:54,840 --> 00:03:56,799
che dobbiamo tirar fuori è un algoritmo

66
00:03:56,799 --> 00:03:58,879
un po' trucchiettoso,

67
00:03:58,879 --> 00:04:01,439
e ci permette di, appunto, dimostrare

68
00:04:01,439 --> 00:04:03,599
questa cosa qua. Adesso noi vediamo

69
00:04:03,599 --> 00:04:07,920
com'è possibile collocare abbild

70
00:04:07,920 --> 00:04:12,079
square log squared. Ehm,

71
00:04:12,079 --> 00:04:14,480
e questo qua poi sarà in realtà un pezzo

72
00:04:14,480 --> 00:04:16,519
di una costruzione che ci serve per

73
00:04:16,519 --> 00:04:18,479
dimostrare poi un risultato abbastanza

74
00:04:18,479 --> 00:04:21,120
generale sulle classi di complessità

75
00:04:21,120 --> 00:04:24,400
spaziali. Ok,

76
00:04:24,400 --> 00:04:27,400
allora

77
00:04:28,160 --> 00:04:33,759
focalizziamoci su un esempio.

78
00:04:37,220 --> 00:04:40,269
[Musica]

79
00:04:45,600 --> 00:04:52,320
Ok. 1 2 3 4 e 5.

80
00:04:52,320 --> 00:04:56,840
Supponiamo che vogliamo andare da S a T.

81
00:04:56,840 --> 00:04:58,560
Ok? Quindi abbiamo un'istanza di

82
00:04:58,560 --> 00:05:00,800
ricability in cui c'è quel grafo

83
00:05:00,800 --> 00:05:02,520
orientato.

84
00:05:02,520 --> 00:05:05,320
Il nodo sorgente è il nodo due, il nodo

85
00:05:05,320 --> 00:05:08,680
destinazione è il nodo numero 5. Ok?

86
00:05:08,680 --> 00:05:10,320
Questa qui è un'istanza sì o un'istanza

87
00:05:10,320 --> 00:05:13,120
no? Del problema? È un'istanza sì. Ok?

88
00:05:13,120 --> 00:05:17,080
perché ci sta un ci sta un un pass e in

89
00:05:17,080 --> 00:05:22,280
particolare avremo che S poi andiamo

90
00:05:22,280 --> 00:05:25,280
sul nodo 1, poi andiamo sul nodo 4, sul

91
00:05:25,280 --> 00:05:28,400
nodo 3 e poi andiamo su T. Ok? Questo è

92
00:05:28,400 --> 00:05:32,120
il path all'interno

93
00:05:32,120 --> 00:05:34,600
di questo

94
00:05:34,600 --> 00:05:37,280
di questo grafo. Allora, il trucco per

95
00:05:37,280 --> 00:05:40,800
riuscire a risolverlo in spazio log

96
00:05:40,800 --> 00:05:43,479
square

97
00:05:43,479 --> 00:05:46,199
log square n

98
00:05:46,199 --> 00:05:49,039
praticamente fare una ricerca binaria,

99
00:05:49,039 --> 00:05:51,280
fare una specie di ricerca binaria.

100
00:05:51,280 --> 00:05:53,720
Questo è il trucco per riuscire a

101
00:05:53,720 --> 00:05:55,720
ottenere questo risultato. E allora è

102
00:05:55,720 --> 00:05:58,039
sostanzialmente questo. L'osservazione

103
00:05:58,039 --> 00:06:02,840
che facciamo è se esiste un pat per

104
00:06:02,840 --> 00:06:04,600
andare

105
00:06:04,600 --> 00:06:08,000
da S a t,

106
00:06:08,000 --> 00:06:12,039
allora deve esistere un nodo intermedio,

107
00:06:12,039 --> 00:06:16,639
tipo il 4 in questo esempio e ci deve

108
00:06:16,639 --> 00:06:20,000
stare un path che va da s a 4 e da 4 a

109
00:06:20,000 --> 00:06:23,960
t. Ok? Quindi la questione è che noi

110
00:06:23,960 --> 00:06:25,800
sostanzialmente

111
00:06:25,800 --> 00:06:29,919
possiamo andare a da un lato potremmo

112
00:06:29,919 --> 00:06:33,960
gessarlo questo modo intermedio,

113
00:06:33,960 --> 00:06:37,080
però visto che siamo in un dominio di

114
00:06:37,080 --> 00:06:39,080
spazio invitato, potremmo provare a

115
00:06:39,080 --> 00:06:41,520
usare lo spazio e riusarlo, no? Ci

116
00:06:41,520 --> 00:06:44,720
proviamo tutti questi U, tanto noi li

117
00:06:44,720 --> 00:06:47,599
scriviamo là in mezzo, li riscriviamo

118
00:06:47,599 --> 00:06:51,160
sempre e quindi non stiamo abbessando,

119
00:06:51,160 --> 00:06:53,840
li proviamo e manteniamo l'utilizzo

120
00:06:53,840 --> 00:06:55,639
dello spazio. Ok? Quindi l'idea

121
00:06:55,639 --> 00:06:58,639
sostanzialmente è questa. Se io voglio

122
00:06:58,639 --> 00:07:03,440
sapere se ci sta un puff dal nodo S al

123
00:07:03,440 --> 00:07:07,479
nodo T, allora io basto che basta che io

124
00:07:07,479 --> 00:07:10,280
verifichi l'esistenza

125
00:07:10,280 --> 00:07:12,479
di un nodo

126
00:07:12,479 --> 00:07:15,199
a metà strada che possiamo chiamare U e

127
00:07:15,199 --> 00:07:19,520
poi verificare che ci sia un

128
00:07:19,520 --> 00:07:23,120
percorso da S verso U e poi da U verso

129
00:07:23,120 --> 00:07:27,840
S. Ok? Quindi questo approccio è di tipo

130
00:07:27,840 --> 00:07:30,440
ricorsivo, quindi noi ci inventiamo un

131
00:07:30,440 --> 00:07:33,120
algoritmo ricorsivo che sfrutta

132
00:07:33,120 --> 00:07:36,160
esattamente questo principio. Se io

133
00:07:36,160 --> 00:07:41,599
voglio andare da S a tono

134
00:07:41,599 --> 00:07:43,840
tre casi, sostanzialmente,

135
00:07:43,840 --> 00:07:46,919
due casi base, abbastanza facile e un

136
00:07:46,919 --> 00:07:50,360
caso dove applichiamo la ricorsione.

137
00:07:50,360 --> 00:07:53,000
casi base sono s = t e allora

138
00:07:53,000 --> 00:07:56,240
rispondiamo di sì. L'altro caso è

139
00:07:56,240 --> 00:08:00,680
tcessivo di S e allora rispondiamo sì.

140
00:08:00,680 --> 00:08:03,759
Se invece questo non accade, allora

141
00:08:03,759 --> 00:08:06,000
proviamo sostanzialmente

142
00:08:06,000 --> 00:08:10,680
tutti le U per vedere se ci sta un puff

143
00:08:10,680 --> 00:08:13,800
da s a U che da U verso t. Ok? Questo è

144
00:08:13,800 --> 00:08:15,560
intuitivamente

145
00:08:15,560 --> 00:08:17,479
la l'approccio che utilizzeremo per

146
00:08:17,479 --> 00:08:21,360
risolvere questo problema. Spazio C. Sì.

147
00:08:21,360 --> 00:08:24,840
Allora, definiamo

148
00:08:24,840 --> 00:08:29,599
questo algoritmo che chiamiamo

149
00:08:31,240 --> 00:08:32,880
exists

150
00:08:32,880 --> 00:08:35,880
pat

151
00:08:36,159 --> 00:08:41,039
che prende quattro argomenti G, S, T e

152
00:08:41,039 --> 00:08:42,919
K.

153
00:08:42,919 --> 00:08:45,160
E questo algoritmo

154
00:08:45,160 --> 00:08:49,640
risponde vero?

155
00:08:50,399 --> 00:08:54,600
Se in G

156
00:08:54,600 --> 00:08:56,440
es

157
00:08:56,440 --> 00:08:58,880
un percorso

158
00:08:58,880 --> 00:09:05,000
da S a t di lunghezza al + K. Ok? Quindi

159
00:09:05,000 --> 00:09:09,720
questo è quello che noi facciamo in

160
00:09:09,720 --> 00:09:11,600
questo vogliamo risolvere con questo

161
00:09:11,600 --> 00:09:14,200
algoritmo. Ok? Son quattro parametri

162
00:09:14,200 --> 00:09:16,240
GSTK.

163
00:09:16,240 --> 00:09:19,839
È vero, no? che esiste un puff da S a T

164
00:09:19,839 --> 00:09:23,800
dentro G di lunghezza K. Poi ovviamente

165
00:09:23,800 --> 00:09:26,839
se noi chiamiamo exists

166
00:09:26,839 --> 00:09:28,839
puff

167
00:09:28,839 --> 00:09:34,320
Gst T e o A qu sono gli archi, allora

168
00:09:34,320 --> 00:09:36,480
ovviamente questo algoritmo risolverebbe

169
00:09:36,480 --> 00:09:39,240
il problema della rechability, ok? Se

170
00:09:39,240 --> 00:09:41,760
noi gli diamo come vincolo di numero di

171
00:09:41,760 --> 00:09:43,560
nodi tutti i nodi disponibili sul

172
00:09:43,560 --> 00:09:47,399
grafico, ok?

173
00:09:48,160 --> 00:09:50,120
Allora,

174
00:09:50,120 --> 00:09:51,800
dobbiamo semplicemente trascrivere

175
00:09:51,800 --> 00:09:54,240
quello che ci siamo detti prima.

176
00:09:54,240 --> 00:09:59,240
Quindi caso uno, primo caso base, se K è

177
00:09:59,240 --> 00:10:02,240
0,

178
00:10:05,760 --> 00:10:08,760
allora

179
00:10:12,880 --> 00:10:16,600
se S è T

180
00:10:16,600 --> 00:10:19,600
accettiamo,

181
00:10:20,120 --> 00:10:22,360
altrimenti

182
00:10:22,360 --> 00:10:25,920
rifiutiamo. Ok.

183
00:10:27,310 --> 00:10:30,350
[Musica]

184
00:10:33,560 --> 00:10:39,320
Altro caso, se K è esattamente 1,

185
00:10:39,320 --> 00:10:43,000
allora se ST

186
00:10:43,000 --> 00:10:45,959
appartiene all'insieme degli archi, qui

187
00:10:45,959 --> 00:10:49,399
abbiamo che G è la coppia VA,

188
00:10:49,399 --> 00:10:51,680
dove V sono i vertici e A sono gli

189
00:10:51,680 --> 00:10:53,560
archi.

190
00:10:53,560 --> 00:11:01,360
Se ST è un arco in G, allora accettiamo,

191
00:11:01,760 --> 00:11:06,079
altrimenti rifiutiamo.

192
00:11:06,079 --> 00:11:08,360
Ok, finora ci siamo occupati dei casi

193
00:11:08,360 --> 00:11:12,399
base della ricorsione.

194
00:11:12,519 --> 00:11:15,279
Manca l'ultimo pezzo, il verificare

195
00:11:15,279 --> 00:11:17,959
l'esistenza di questo U intermedio.

196
00:11:17,959 --> 00:11:20,920
Allora, facciamo così. for

197
00:11:20,920 --> 00:11:26,320
each you from the

198
00:11:26,320 --> 00:11:29,279
if e qui facciamo le chiamate ricorsive

199
00:11:29,279 --> 00:11:32,560
if exists puff

200
00:11:32,560 --> 00:11:39,160
dove in g da s a u con al più k mezzi

201
00:11:39,160 --> 00:11:41,200
nodi

202
00:11:41,200 --> 00:11:43,399
and

203
00:11:43,399 --> 00:11:45,360
exists

204
00:11:45,360 --> 00:11:47,880
path

205
00:11:47,880 --> 00:11:52,120
from G eh no,

206
00:11:52,120 --> 00:11:58,839
from U to T con al più KZ

207
00:11:58,839 --> 00:12:04,160
nodi. Allora, accettiamo.

208
00:12:08,160 --> 00:12:10,760
Se nessuna di questa cosa funziona,

209
00:12:10,760 --> 00:12:13,760
rifiutiamo.

210
00:12:15,880 --> 00:12:18,839
Vedete tutto l'algoritmo? Yes. Qua

211
00:12:18,839 --> 00:12:23,240
c'entra tutto. Ok. Allora, di nuovo

212
00:12:23,240 --> 00:12:25,600
questo algoritmo che fa? Se noi abbiamo

213
00:12:25,600 --> 00:12:28,600
K0 verifichiamo che sorgente e

214
00:12:28,600 --> 00:12:30,760
destinazione siano lo stesso. Se sì

215
00:12:30,760 --> 00:12:33,519
accettiamo, senò rifiutiamo. Se possiamo

216
00:12:33,519 --> 00:12:36,560
fare al più un salto verifichiamo che T

217
00:12:36,560 --> 00:12:38,839
sia un successivo di Ss. Se questo è il

218
00:12:38,839 --> 00:12:41,480
caso accettiamo, senò lo rifiutiamo. Se

219
00:12:41,480 --> 00:12:43,399
non siamo in nessuno di questi due casi,

220
00:12:43,399 --> 00:12:46,160
quindi k è più grosso, noi verifichiamo

221
00:12:46,160 --> 00:12:49,360
l'esistenza di un nodo intermedio e lo

222
00:12:49,360 --> 00:12:51,560
facciamo con un for. Eh, quindi non lo

223
00:12:51,560 --> 00:12:54,199
stiamo li stiamo provando tutti.

224
00:12:54,199 --> 00:12:56,440
Facciamo delle chiamate ricorsive e ci

225
00:12:56,440 --> 00:12:58,800
chiediamo, ma è vero che esiste un

226
00:12:58,800 --> 00:13:03,360
percorso da S a U di lunghezza al + k/2

227
00:13:03,360 --> 00:13:06,639
e un percorso da U verso t di lunghezza

228
00:13:06,639 --> 00:13:10,399
al + k/2? Se sì accettiamo. Se per

229
00:13:10,399 --> 00:13:12,199
nessuna di queste U riusciamo ad

230
00:13:12,199 --> 00:13:14,560
accettare allora rifiutiamo. Percorso,

231
00:13:14,560 --> 00:13:17,360
non ce ne sta. Ok? Quindi questo

232
00:13:17,360 --> 00:13:21,240
algoritmo ci risolve il nostro

233
00:13:21,240 --> 00:13:24,040
il nostro problema, ok?

234
00:13:24,040 --> 00:13:26,440
Dobbiamo considerare, voi l'avete

235
00:13:26,440 --> 00:13:28,760
trascritto perché mi serve spazio qua,

236
00:13:28,760 --> 00:13:30,800
dobbiamo considerare qual è la

237
00:13:30,800 --> 00:13:32,680
complessità spaziale di questo

238
00:13:32,680 --> 00:13:35,120
algoritmo. Ok? Quindi vediamo quanta

239
00:13:35,120 --> 00:13:40,240
memoria questo algoritmo necessiti.

240
00:13:40,240 --> 00:13:43,079
Per il momento ignoriamo le chiamate

241
00:13:43,079 --> 00:13:45,839
ricorsive, andiamo a guardare il resto.

242
00:13:45,839 --> 00:13:47,600
Ok?

243
00:13:47,600 --> 00:13:49,480
Allora,

244
00:13:49,480 --> 00:13:53,639
per guardare il resto sostanzialmente

245
00:13:53,639 --> 00:13:57,079
che ci serve a noi? Ci serve

246
00:13:57,079 --> 00:14:00,839
dello spazio in memoria

247
00:14:00,839 --> 00:14:03,800
per riuscire a

248
00:14:03,800 --> 00:14:06,360
sapere chi sono S e T, perché noi

249
00:14:06,360 --> 00:14:08,560
facciamo questi test, ok? Quindi sono o

250
00:14:08,560 --> 00:14:11,440
dei puntatori verso il nastro di input

251
00:14:11,440 --> 00:14:14,560
dove appaiono S e T nella descrizione

252
00:14:14,560 --> 00:14:17,519
del grafo,

253
00:14:17,519 --> 00:14:19,639
oppure, come dicevamo ieri, può essere

254
00:14:19,639 --> 00:14:23,160
un ID, un ID di taglia logaritmica. Ok?

255
00:14:23,160 --> 00:14:25,160
Quindi

256
00:14:25,160 --> 00:14:27,120
a noi serve

257
00:14:27,120 --> 00:14:30,320
due, potremmo dire registri di taglia

258
00:14:30,320 --> 00:14:33,639
logaritmica, due due spazietti di taglia

259
00:14:33,639 --> 00:14:35,920
logaritmica su worktape, uno per

260
00:14:35,920 --> 00:14:38,399
registrare S, l'altro per registrare t,

261
00:14:38,399 --> 00:14:40,360
che ci servono sia per questo test che

262
00:14:40,360 --> 00:14:43,920
per questo test. Dopodiché ci serve un

263
00:14:43,920 --> 00:14:47,920
altro spazio di taglia logaritmica per

264
00:14:47,920 --> 00:14:51,320
tenere tracce di chi è l' corrente. Ok?

265
00:14:51,320 --> 00:14:55,440
Questo qua. Quindi, se noi al momento

266
00:14:55,440 --> 00:14:57,320
ignoriamo la parte delle chiamate

267
00:14:57,320 --> 00:15:00,279
logaritmiche a noi servono tre

268
00:15:00,279 --> 00:15:02,720
pezzettini,

269
00:15:02,720 --> 00:15:05,040
le chiamate ricorsive, scusate. A noi

270
00:15:05,040 --> 00:15:06,920
servono tre pezzettini di taglia

271
00:15:06,920 --> 00:15:10,800
logaritmica. Ok? Quindi, a parte quello,

272
00:15:10,800 --> 00:15:15,839
noi abbiamo che per memorizzare

273
00:15:19,320 --> 00:15:26,160
S t e u serve spazio o di log n. Ok?

274
00:15:26,160 --> 00:15:28,680
Notate che u

275
00:15:28,680 --> 00:15:31,480
noi lo riscriviamo, cioè non è che noi

276
00:15:31,480 --> 00:15:33,759
iniziamo a scriverlo sul nastro, è il

277
00:15:33,759 --> 00:15:36,160
primo U, è il secondo U è il terzo U e

278
00:15:36,160 --> 00:15:40,560
così via. Noi u lo scriviamo sul nastro

279
00:15:40,560 --> 00:15:43,680
e poi lo ci riscriviamo sopra, quindi

280
00:15:43,680 --> 00:15:47,240
risparmiamo spazio. Ok? Quindi se noi

281
00:15:47,240 --> 00:15:50,120
ignoriamo le chiamate ricorsive

282
00:15:50,120 --> 00:15:53,880
per una sola call a noi serve spazio

283
00:15:53,880 --> 00:15:56,279
logaritmico. Ok? Quello che noi ci

284
00:15:56,279 --> 00:15:58,199
dobbiamo chiedere adesso è siccome

285
00:15:58,199 --> 00:16:01,160
questo algoritmo è ricorsivo e quindi su

286
00:16:01,160 --> 00:16:04,000
stack andiamo a mettere tutte le

287
00:16:04,000 --> 00:16:07,199
chiamate eccetera, lo spazio occupato

288
00:16:07,199 --> 00:16:10,199
durante l'esecuzione è dato da quante

289
00:16:10,199 --> 00:16:12,399
chiamate facciamo

290
00:16:12,399 --> 00:16:14,959
per lo spazio di ognuna di queste

291
00:16:14,959 --> 00:16:17,759
chiamate, ok? Quindi sull'altezza

292
00:16:17,759 --> 00:16:20,839
massima dello ste noi lì potremo capire

293
00:16:20,839 --> 00:16:22,680
quanto spazio staremo occupando in

294
00:16:22,680 --> 00:16:25,440
memoria. Ok? Chiaro? Quindi ci dobbiamo

295
00:16:25,440 --> 00:16:27,240
occupare di questa cosa. Andiamo a

296
00:16:27,240 --> 00:16:29,000
vedere

297
00:16:29,000 --> 00:16:31,240
l'albero della computazione ricorsiva

298
00:16:31,240 --> 00:16:34,480
per questo per questo

299
00:16:34,480 --> 00:16:36,399
algoritmo.

300
00:16:36,399 --> 00:16:41,880
Supponiamo di avere exists path.

301
00:16:44,920 --> 00:16:47,759
Qui abbiamo GST.

302
00:16:47,759 --> 00:16:49,959
La chiamata iniziale è proprio sul

303
00:16:49,959 --> 00:16:52,120
numero degli archi. Ok? In questo modo

304
00:16:52,120 --> 00:16:54,880
abbiamo è la primissima chiamata GST,

305
00:16:54,880 --> 00:16:58,440
numero degli archi.

306
00:16:58,639 --> 00:17:01,639
Allora,

307
00:17:02,240 --> 00:17:05,120
nella prima chiamata noi genereremo due

308
00:17:05,120 --> 00:17:08,039
chiamate ricorsive,

309
00:17:08,039 --> 00:17:12,839
ok? Per ogni U genereremo delle chiamate

310
00:17:12,839 --> 00:17:14,360
ricorsive.

311
00:17:14,360 --> 00:17:16,919
Adesso andiamo a guardare questa cosa

312
00:17:16,919 --> 00:17:18,919
nello specifico.

313
00:17:18,919 --> 00:17:21,679
Nel momento in cui andiamo a testare le

314
00:17:21,679 --> 00:17:23,559
U diverse,

315
00:17:23,559 --> 00:17:25,760
tutte queste chiamate ricorsive stanno

316
00:17:25,760 --> 00:17:30,000
in memoria allo stesso momento

317
00:17:31,919 --> 00:17:34,240
sulla primissima la primissima chiamata

318
00:17:34,240 --> 00:17:37,559
di exist, no? Cioè c'è un for. Noi

319
00:17:37,559 --> 00:17:40,360
questi U li consideriamo uno per volta.

320
00:17:40,360 --> 00:17:43,400
Quindi, preso un u, facciamo due

321
00:17:43,400 --> 00:17:46,840
chiamate ricorsive.

322
00:17:52,600 --> 00:17:55,600
Allegria.

323
00:17:57,919 --> 00:18:00,159
Exist path.

324
00:18:00,159 --> 00:18:03,640
Andiamo da GSU

325
00:18:05,559 --> 00:18:07,799
a mezzi

326
00:18:07,799 --> 00:18:12,440
e l'altra è existat

327
00:18:14,320 --> 00:18:17,200
Gut.

328
00:18:17,200 --> 00:18:19,880
A mezzi, ok? Spazio là non ce n'è. A

329
00:18:19,880 --> 00:18:22,880
mezzi c'è scritto là. Ok. Sì,

330
00:18:22,880 --> 00:18:25,200
potremmoare una chiamata come per

331
00:18:25,200 --> 00:18:27,720
esempio quella di sinistra prima.

332
00:18:27,720 --> 00:18:29,640
Esattamente. Questa è l'osservazione che

333
00:18:29,640 --> 00:18:32,159
facciamo, cioè le due chiamate parall le

334
00:18:32,159 --> 00:18:33,919
due chiamate per uno mica vengono

335
00:18:33,919 --> 00:18:35,799
eseguite in parallelo, facciamo prima

336
00:18:35,799 --> 00:18:38,120
uno e poi l'altro. Di conseguenza, noi

337
00:18:38,120 --> 00:18:42,200
esploreremmo prima questa parte qua, poi

338
00:18:42,200 --> 00:18:44,640
lui genererebbe altre due chiamate

339
00:18:44,640 --> 00:18:47,919
ricorsive e questo qua ne genera altre

340
00:18:47,919 --> 00:18:51,640
due e così via. Ma noi di questi

341
00:18:51,640 --> 00:18:54,840
chiamate ricorsive, quando si forca ne

342
00:18:54,840 --> 00:18:56,720
abbiamo sempre uno in memoria. Non ne

343
00:18:56,720 --> 00:18:59,520
facciamo due contemporaneamente. Quando

344
00:18:59,520 --> 00:19:02,039
ritorniamo dalla chiamata ricorsiva e

345
00:19:02,039 --> 00:19:05,440
quello ci ha detto sì, va bene, a quel

346
00:19:05,440 --> 00:19:07,720
punto facciamo partire l'altra. Ok?

347
00:19:07,720 --> 00:19:09,840
Quindi ci sarà a un certo punto qui

348
00:19:09,840 --> 00:19:13,000
arriviamo all'ultimo passaggio in cui

349
00:19:13,000 --> 00:19:16,960
questo è caso base

350
00:19:16,960 --> 00:19:20,520
e quest'altro è un caso base e quindi

351
00:19:20,520 --> 00:19:23,720
noi avremo per esempio questo path di

352
00:19:23,720 --> 00:19:26,640
chiamate ricorsive in memoria oppure

353
00:19:26,640 --> 00:19:29,120
questo qua. Ma non li avremo tutti

354
00:19:29,120 --> 00:19:33,200
assieme, ne avremo uno per volta,
come

355
00:19:33,200 --> 00:19:35,480
un attraversamento in profondità. è come

356
00:19:35,480 --> 00:19:37,280
un attraversamento in profondità, però

357
00:19:37,280 --> 00:19:40,840
delle chiamate ricorsive. Ok? È chiaro

358
00:19:40,840 --> 00:19:42,919
questo? Questo è è la parte importante

359
00:19:42,919 --> 00:19:45,280
di questa di questo ragionamento, cioè

360
00:19:45,280 --> 00:19:48,400
che noi questo albero di computazione di

361
00:19:48,400 --> 00:19:51,000
questo algoritmo di ricorsivo non sarà

362
00:19:51,000 --> 00:19:52,799
mai

363
00:19:52,799 --> 00:19:55,960
tutto completo in memoria. In memoria

364
00:19:55,960 --> 00:19:59,080
abbiamo un solo branch. Ok? Questa è la

365
00:19:59,080 --> 00:20:01,520
parte fondamentale dell'osservazione.

366
00:20:01,520 --> 00:20:05,799
Ok. Adesso la nostra domanda. Noi

367
00:20:05,799 --> 00:20:07,960
sappiamo dall'analisi di prima che

368
00:20:07,960 --> 00:20:11,400
ognuno di questi

369
00:20:11,400 --> 00:20:13,760
luoghi di esecuzione, record di

370
00:20:13,760 --> 00:20:16,039
attivazione, cioè lo spazio di lavoro di

371
00:20:16,039 --> 00:20:17,919
qualsiasi di queste chiamate ricorsive,

372
00:20:17,919 --> 00:20:22,120
tipo questa qua, questa qua, questa qui,

373
00:20:22,120 --> 00:20:24,640
questa qui e così via, ognuno di loro

374
00:20:24,640 --> 00:20:27,720
prende spazio logaritmico. Ok? Adesso

375
00:20:27,720 --> 00:20:29,880
noi ci chiediamo,

376
00:20:29,880 --> 00:20:33,960
ma quanto è profondo questo albero?

377
00:20:33,960 --> 00:20:35,880
Perché quello ce lo dice, perché a

378
00:20:35,880 --> 00:20:38,200
questo punto è chiamata ricorsiva,

379
00:20:38,200 --> 00:20:40,240
chiamata ricorsiva, chiamata ricorsiva,

380
00:20:40,240 --> 00:20:42,320
spazio logaritmico. Altra richiamata

381
00:20:42,320 --> 00:20:44,400
chiamata ricorsiva, spazio logaritmico.

382
00:20:44,400 --> 00:20:47,640
Quindi avremo spazio logaritmico per il

383
00:20:47,640 --> 00:20:53,960
numero di chiamate su step. Quante sono?

384
00:20:54,760 --> 00:20:59,280
sono logaritmiche perché volta

385
00:20:59,280 --> 00:21:01,520
perché ogni volta dimezziamo K. Ok?

386
00:21:01,520 --> 00:21:04,320
Quello è il trucco. Siccome sto K noi lo

387
00:21:04,320 --> 00:21:05,880
andiamo a dimezzare ogni volta, ecco

388
00:21:05,880 --> 00:21:08,159
perché c'è il principio della ricerca

389
00:21:08,159 --> 00:21:11,919
binaria, noi dimezziamo ogni volta a

390
00:21:11,919 --> 00:21:15,080
quel K. Di conseguenza

391
00:21:15,080 --> 00:21:21,720
la profondità di questa cosa è log a.

392
00:21:24,799 --> 00:21:26,080
Ok?

393
00:21:26,080 --> 00:21:30,039
Quindi su step nella peggiore delle

394
00:21:30,039 --> 00:21:36,799
ipotesi avremo big o di log a chiamate

395
00:21:36,799 --> 00:21:40,559
ricorsive, ognuna delle quali richiede

396
00:21:40,559 --> 00:21:44,360
spazio logaritmico.

397
00:21:46,039 --> 00:21:49,000
Da ciò, qual è la complessità spaziale

398
00:21:49,000 --> 00:21:51,279
di questo algoritmo?

399
00:21:51,279 --> 00:21:56,880
è O log a

400
00:21:56,919 --> 00:22:02,679
O log N. E siccome A

401
00:22:02,679 --> 00:22:05,120
fa parte dell'input e quindi è lineare

402
00:22:05,120 --> 00:22:08,720
nell'input, avremo che questa cosa qui è

403
00:22:08,720 --> 00:22:13,279
O di log squ N.

404
00:22:13,279 --> 00:22:16,799
Quindi questo algoritmo

405
00:22:16,799 --> 00:22:18,640
ha

406
00:22:18,640 --> 00:22:20,919
uno spazio di esecuzione

407
00:22:20,919 --> 00:22:23,720
polilogaritmico, cioè al quadrato di un

408
00:22:23,720 --> 00:22:26,400
logaritmo.

409
00:22:26,400 --> 00:22:29,400
Ok?

410
00:22:37,000 --> 00:22:38,360
Chiaro per tutti come funziona questa

411
00:22:38,360 --> 00:22:41,400
cosa? Quindi noi abbiamo dimostrato che

412
00:22:41,400 --> 00:22:46,279
esiste una procedura

413
00:22:46,360 --> 00:22:49,840
che ci permette di

414
00:22:49,840 --> 00:22:52,679
eh decidere rich ability in spazio

415
00:22:52,679 --> 00:22:55,520
quadratico logaritmico. Ok? Dice "Ah,

416
00:22:55,520 --> 00:22:57,400
bello sto risultato, non ce ne facciamo

417
00:22:57,400 --> 00:23:00,000
niente". Sì, in effetti. Però in realtà

418
00:23:00,000 --> 00:23:02,720
questo costituisce la base di un teorema

419
00:23:02,720 --> 00:23:04,919
molto più importante che è un teorema

420
00:23:04,919 --> 00:23:06,919
che caratterizzi

421
00:23:06,919 --> 00:23:10,279
le classi di

422
00:23:10,279 --> 00:23:12,039
complessità

423
00:23:12,039 --> 00:23:13,919
di

424
00:23:13,919 --> 00:23:17,559
le classi di complessità spaziali, ok?

425
00:23:17,559 --> 00:23:23,159
Che è il teorema di Savic.

426
00:23:24,000 --> 00:23:27,799
Facciamo l'altra pagina.

427
00:23:38,080 --> 00:23:40,880
Allora, il teorema di Savic è un teorema

428
00:23:40,880 --> 00:23:43,600
abbastanza interessante

429
00:23:43,600 --> 00:23:46,440
perché ci permette di dare dei risultati

430
00:23:46,440 --> 00:23:49,480
che noi sulle classi temporali non siamo

431
00:23:49,480 --> 00:23:52,919
in grado di fare. sulle classi spaziali,

432
00:23:52,919 --> 00:23:55,400
probabilmente perché il riuso dello

433
00:23:55,400 --> 00:23:58,000
spazio ci permette di avere molta

434
00:23:58,000 --> 00:23:59,559
potenza,

435
00:23:59,559 --> 00:24:01,840
noi siamo in grado di dimostrare una

436
00:24:01,840 --> 00:24:06,760
cosa abbastanza interessante.

437
00:24:08,000 --> 00:24:11,279
Quello è definito dopo. Vabbò.

438
00:24:11,279 --> 00:24:13,200
Allora, il teorema di Savic ci dice

439
00:24:13,200 --> 00:24:17,200
questo: sia SN

440
00:24:17,200 --> 00:24:21,000
una space function,

441
00:24:21,640 --> 00:24:26,520
quindi sia Snale

442
00:24:33,159 --> 00:24:35,120
che

443
00:24:35,120 --> 00:24:37,799
SDN

444
00:24:37,799 --> 00:24:39,480
è

445
00:24:39,480 --> 00:24:43,919
big Omega di log n, cioè, quindi s n

446
00:24:43,919 --> 00:24:46,559
deve essere almeno logaritmica.

447
00:24:46,559 --> 00:24:49,000
Questa cosa, questo risultato non vale

448
00:24:49,000 --> 00:24:51,840
per space function che crescono meno di

449
00:24:51,840 --> 00:24:55,799
logaritmo. Ok?

450
00:24:58,600 --> 00:25:01,080
Allora,

451
00:25:01,080 --> 00:25:05,559
abbiamo che n space

452
00:25:06,799 --> 00:25:09,559
di SN

453
00:25:09,559 --> 00:25:13,360
è contenuto in d space

454
00:25:13,360 --> 00:25:16,840
di Sn².

455
00:25:17,960 --> 00:25:20,039
Ok? Allora, questo è un risultato

456
00:25:20,039 --> 00:25:22,080
interessante perché sostanzialmente ci

457
00:25:22,080 --> 00:25:25,080
dice che tutto quello che è possibile

458
00:25:25,080 --> 00:25:27,880
fare in spazio

459
00:25:27,880 --> 00:25:30,679
non deterministico

460
00:25:30,679 --> 00:25:32,880
per una certa funzione lo si può fare in

461
00:25:32,880 --> 00:25:34,840
spazio deterministico con quella

462
00:25:34,840 --> 00:25:36,720
funzione al quadrato. Ok? Quindi

463
00:25:36,720 --> 00:25:41,159
significa che riusciamo a differenza

464
00:25:41,159 --> 00:25:44,720
del gap per le classi temporali in cui

465
00:25:44,720 --> 00:25:47,000
per passare da non deterministico a

466
00:25:47,000 --> 00:25:48,919
deterministico abbiamo un salto di tipo

467
00:25:48,919 --> 00:25:50,440
esponenziale.

468
00:25:50,440 --> 00:25:54,200
Quando lavoriamo su classi spaziali il

469
00:25:54,200 --> 00:25:57,559
salto è solamente quadratico, ok? che è

470
00:25:57,559 --> 00:25:59,880
molto poco.

471
00:25:59,880 --> 00:26:04,559
Allora, diamo giusto uno sketch, una una

472
00:26:04,559 --> 00:26:06,360
bozza di dimostrazione non troppo

473
00:26:06,360 --> 00:26:09,720
precisa, giusto per dare un'intuizione

474
00:26:09,720 --> 00:26:12,039
di come di come si dimostri questo

475
00:26:12,039 --> 00:26:15,200
teorema. Allora, per dimostrare questo

476
00:26:15,200 --> 00:26:18,679
teorema noi dobbiamo sfruttare

477
00:26:18,679 --> 00:26:20,559
due elementi.

478
00:26:20,559 --> 00:26:23,480
La riduzione verso ritability che

479
00:26:23,480 --> 00:26:27,600
abbiamo visto ieri, almeno il concetto,

480
00:26:27,600 --> 00:26:30,360
cioè l'idea che avevamo utilizzato e

481
00:26:30,360 --> 00:26:32,919
l'algoritmo che abbiamo visto stamattina

482
00:26:32,919 --> 00:26:36,520
per la risoluzione in spazio log

483
00:26:36,520 --> 00:26:40,600
squarespace di ritability. Ok?

484
00:26:40,600 --> 00:26:43,600
Allora,

485
00:26:44,640 --> 00:26:47,520
dimostrazione

486
00:26:47,520 --> 00:26:52,000
sia L un linguaggio appartenente a

487
00:26:52,000 --> 00:26:56,039
Nspace SDN,

488
00:26:56,039 --> 00:27:00,279
quindi esiste

489
00:27:00,360 --> 00:27:04,240
una macchina

490
00:27:07,200 --> 00:27:12,240
M non deterministica,

491
00:27:12,600 --> 00:27:15,960
tale che il linguaggio di M è

492
00:27:15,960 --> 00:27:19,960
propriamente è proprio L

493
00:27:19,960 --> 00:27:23,120
e il suo

494
00:27:23,120 --> 00:27:26,640
running space

495
00:27:28,240 --> 00:27:31,320
è s.

496
00:27:31,320 --> 00:27:33,600
Ok?

497
00:27:33,600 --> 00:27:36,399
Allora, di questa macchina M non

498
00:27:36,399 --> 00:27:38,520
deterministica che riconosce il

499
00:27:38,520 --> 00:27:42,880
linguaggio L, noi possiamo andare ad

500
00:27:42,880 --> 00:27:46,640
analizzare il suo computation graph. Che

501
00:27:46,640 --> 00:27:48,640
cos'è il computation graph? È la cosa

502
00:27:48,640 --> 00:27:50,880
che abbiamo visto ieri quando

503
00:27:50,880 --> 00:27:53,120
ragionavamo su reachability. è

504
00:27:53,120 --> 00:27:54,679
sostanzialmente

505
00:27:54,679 --> 00:27:56,640
un grafo

506
00:27:56,640 --> 00:28:01,720
i cui nodi sono relativi ai vari stadi

507
00:28:01,720 --> 00:28:04,960
computazione della macchina e ci sta un

508
00:28:04,960 --> 00:28:09,320
arco che collega due nodi se un nodo è

509
00:28:09,320 --> 00:28:12,640
il successivo del precedente rispetto

510
00:28:12,640 --> 00:28:15,080
alla funzione di transizione di m. Ok?

511
00:28:15,080 --> 00:28:17,480
Computation graph è il concetto che

512
00:28:17,480 --> 00:28:19,880
abbiamo visto ieri quando ci siamo

513
00:28:19,880 --> 00:28:22,159
inventati la riduzione vernicability è

514
00:28:22,159 --> 00:28:26,120
quella cosa lì. Ok?

515
00:28:26,120 --> 00:28:30,159
Allora, l'idea di base

516
00:28:30,159 --> 00:28:35,760
per far vedere che L possa essere,

517
00:28:35,760 --> 00:28:39,159
sebbene sia riconoscibile in spazio non

518
00:28:39,159 --> 00:28:42,159
deterministico Sn per riconoscerlo in

519
00:28:42,159 --> 00:28:44,640
spazio deterministico

520
00:28:44,640 --> 00:28:46,360
Sn²,

521
00:28:46,360 --> 00:28:49,080
quello che noi facciamo è questo,

522
00:28:49,080 --> 00:28:51,760
l'intuizione

523
00:28:51,760 --> 00:28:54,320
proprio semplice. costruiamo il suo

524
00:28:54,320 --> 00:28:56,440
computation graph e per computation

525
00:28:56,440 --> 00:28:59,720
graph intendiamo quello di er. Dopodiché

526
00:28:59,720 --> 00:29:02,799
lanciamo l'algoritmo di ritability che

527
00:29:02,799 --> 00:29:05,399
abbiamo visto stamattina su quel grafo e

528
00:29:05,399 --> 00:29:07,640
a quel punto verifichiamo se esista un

529
00:29:07,640 --> 00:29:10,679
percorso dal dalla configurazione

530
00:29:10,679 --> 00:29:12,200
iniziale

531
00:29:12,200 --> 00:29:14,760
a quel nodo che chiamavamo ieri in

532
00:29:14,760 --> 00:29:18,519
vista. Ok? Tutto qua di nuovo. Quindi

533
00:29:18,519 --> 00:29:21,679
prendiamo questi due pezzi che abbiamo.

534
00:29:21,679 --> 00:29:25,840
La nozione di computation graph

535
00:29:25,840 --> 00:29:28,320
introdotta ieri è l'algoritmo che

536
00:29:28,320 --> 00:29:30,480
abbiamo visto stamattina che dimza i

537
00:29:30,480 --> 00:29:34,159
percorsi. Ok? costruiamo quello, ci

538
00:29:34,159 --> 00:29:37,679
lanciamo l'algoritmo sopra da S, che è

539
00:29:37,679 --> 00:29:40,080
la configurazione iniziale a Vistar, che

540
00:29:40,080 --> 00:29:42,760
era quel modo particolare in cui tutte

541
00:29:42,760 --> 00:29:44,480
le configurazioni accettanti

542
00:29:44,480 --> 00:29:46,760
concluiscono e ci chiediamo se esista

543
00:29:46,760 --> 00:29:50,480
questo percorso o meno. Ok?

544
00:29:50,480 --> 00:29:53,120
Per fare questo però ci dobbiamo

545
00:29:53,120 --> 00:29:56,600
chiedere quanto grosso sia questo grafo,

546
00:29:56,600 --> 00:29:58,679
ok? Perché adesso questo grafo lo

547
00:29:58,679 --> 00:30:00,760
dobbiamo proprio rappresentare prima di

548
00:30:00,760 --> 00:30:03,240
lanciarci sopra l'algoritmo che lo

549
00:30:03,240 --> 00:30:06,440
risolve che risolve il problema

550
00:30:06,440 --> 00:30:09,440
della

551
00:30:10,519 --> 00:30:12,600
richility.

552
00:30:12,600 --> 00:30:15,600
Ok?

553
00:30:15,600 --> 00:30:18,679
Allora, come dicevamo ieri,

554
00:30:18,679 --> 00:30:22,200
noi abbiamo che

555
00:30:22,200 --> 00:30:25,440
i nodi del computation graph possono

556
00:30:25,440 --> 00:30:28,480
essere distinti, non è necessario

557
00:30:28,480 --> 00:30:32,120
scrivere tutta la la configurazione come

558
00:30:32,120 --> 00:30:34,000
facevamo in passato. Quei nodi possono

559
00:30:34,000 --> 00:30:37,640
essere distinti guardando a quattro

560
00:30:37,640 --> 00:30:40,519
elementi. il contenuto del nastro di

561
00:30:40,519 --> 00:30:42,399
lavoro, perché sono le uniche cose che

562
00:30:42,399 --> 00:30:45,159
realmente cambiano. Il contenuto del

563
00:30:45,159 --> 00:30:47,960
nastro di lavoro, la posizione della

564
00:30:47,960 --> 00:30:49,840
testina sul nastro di input, la

565
00:30:49,840 --> 00:30:51,880
posizione della testina sul nastro di

566
00:30:51,880 --> 00:30:54,120
lavoro e lo stato corrente di

567
00:30:54,120 --> 00:30:56,960
computazione. Quindi noi avremo che una

568
00:30:56,960 --> 00:30:59,960
label

569
00:31:02,600 --> 00:31:06,279
avrà il work tape, una label per questi

570
00:31:06,279 --> 00:31:09,799
nodi del computation graph. Avrà un

571
00:31:09,799 --> 00:31:13,200
pezzo di label che è il contenuto del

572
00:31:13,200 --> 00:31:16,440
work tape. Poi abbiamo la posizione

573
00:31:16,440 --> 00:31:19,320
della testina sul nostro di input, la

574
00:31:19,320 --> 00:31:21,559
posizione della testina sul nastro di

575
00:31:21,559 --> 00:31:23,840
lavoro e

576
00:31:23,840 --> 00:31:25,840
un identificativo dello stato corrente.

577
00:31:25,840 --> 00:31:28,519
Ok? È la cosa che abbiamo visto ieri.

578
00:31:28,519 --> 00:31:31,519
Alri,

579
00:31:31,799 --> 00:31:34,360
adesso facciamo lo stesso ragionamento

580
00:31:34,360 --> 00:31:36,399
di ieri.

581
00:31:36,399 --> 00:31:39,120
Quanto è grande questa parte di questa

582
00:31:39,120 --> 00:31:41,000
label?

583
00:31:41,000 --> 00:31:47,600
Se la macchina M esegue in spazio SDN.

584
00:31:48,200 --> 00:31:52,159
Attenzione, eh no, no. Lo spazio usato

585
00:31:52,159 --> 00:31:57,639
da M di running space di M è SDN.
Sn
è

586
00:31:57,639 --> 00:32:01,960
SDN, quindi questo è big o dn. Ok?

587
00:32:01,960 --> 00:32:05,480
Perché lo spazio che noi diamo

588
00:32:05,480 --> 00:32:07,720
disponibile alla macchina M per eseguire

589
00:32:07,720 --> 00:32:10,519
è proprio SDN. Quindi su workape noi

590
00:32:10,519 --> 00:32:14,840
scriviamo bigo di SDN simboli. Ok?

591
00:32:14,840 --> 00:32:17,240
Quanto è grande

592
00:32:17,240 --> 00:32:20,279
il puntatore alla cella corrente sul

593
00:32:20,279 --> 00:32:23,720
nastro di input?

594
00:32:26,200 --> 00:32:29,080
Logaritmo di

595
00:32:29,080 --> 00:32:31,320
il nastro di input. Il n quanto è lungo

596
00:32:31,320 --> 00:32:33,320
l'input?

597
00:32:33,320 --> 00:32:37,840
N. Quindi i puntatori alle celle del

598
00:32:37,840 --> 00:32:41,039
nastro di input hanno taglia log

599
00:32:41,039 --> 00:32:46,799
logaritmo di n, quindi qua log n. Ok,

600
00:32:46,799 --> 00:32:52,080
prego.
Ma eh non potremmo scrivere H1

601
00:32:52,080 --> 00:32:54,919
come una codifica

602
00:32:54,919 --> 00:32:58,480
dell'alfabeto di
In che senso? Nel senso

603
00:32:58,480 --> 00:33:02,320
sarà capitol da N ai elementi n singoli.

604
00:33:02,320 --> 00:33:05,799
H1 sarà l'elemento

605
00:33:05,799 --> 00:33:07,639
uno di quei n sing simboli, quindi dovre

606
00:33:07,639 --> 00:33:11,600
essere scritto come,

607
00:33:11,720 --> 00:33:15,399
cioè lei vorrebbe che, se ho capito bene

608
00:33:15,399 --> 00:33:18,120
che l'alfabeto di nastro abbia tanti

609
00:33:18,120 --> 00:33:20,440
simboli quanto la lunghezza della

610
00:33:20,440 --> 00:33:22,840
stringa input. Ho capito bene?
No, forse

611
00:33:22,840 --> 00:33:26,080
non ho capito bene io come fatto questo?

612
00:33:26,080 --> 00:33:27,760
Allora,

613
00:33:27,760 --> 00:33:29,880
semplicemente questo. Noi abbiamo il

614
00:33:29,880 --> 00:33:34,559
nastro di input che ha, che ne so, 16

615
00:33:34,559 --> 00:33:38,080
celle. Sì, cioè la la stringa in input

616
00:33:38,080 --> 00:33:40,000
ha

617
00:33:40,000 --> 00:33:44,440
16 simboli, ok? Indicizzati 0 1 2 3 bla

618
00:33:44,440 --> 00:33:48,919
bla 15. Se io devo memorizzare

619
00:33:48,919 --> 00:33:52,120
dove si trovi la testina, allora a me

620
00:33:52,120 --> 00:33:54,080
serve indicarlo con un numero in

621
00:33:54,080 --> 00:33:56,399
posizione 10. Questo numero io lo posso

622
00:33:56,399 --> 00:34:00,000
scrivere in rappresentazione binaria e a

623
00:34:00,000 --> 00:34:02,679
quel punto a me servono logaritmo di n

624
00:34:02,679 --> 00:34:07,559
bit per dire la testina sta lì.

625
00:34:07,559 --> 00:34:11,679
Ok? Ma allora non potrei direttamente

626
00:34:11,679 --> 00:34:14,520
considerare la sti hola indirettamente

627
00:34:14,520 --> 00:34:18,679
il simbolo letto dalla testina?

628
00:34:18,919 --> 00:34:22,280
No, perché se lei ha un simbolo ripetuto

629
00:34:22,280 --> 00:34:24,919
in input, come fa a sapere a quale di

630
00:34:24,919 --> 00:34:28,679
quello ci stiamo riferendo?

631
00:34:28,879 --> 00:34:32,720
string copi cioè ci saranno tutti string

632
00:34:32,720 --> 00:34:35,320
lavoro perché il work tap sarà cambiato

633
00:34:35,320 --> 00:34:40,079
se la destin
ma se io ho contenuto di un

634
00:34:40,079 --> 00:34:43,159
work tape che è una certa cosa e dopo

635
00:34:43,159 --> 00:34:47,879
dico h simbolo stellina e input della

636
00:34:47,879 --> 00:34:50,079
stellina ce ne stavano cinque o se io

637
00:34:50,079 --> 00:34:52,240
come faccio a sapere dove si trova la

638
00:34:52,240 --> 00:34:54,879
testina? Cioè quello è il problema,

639
00:34:54,879 --> 00:34:56,960
perché io devo spostarmi, devo fare la

640
00:34:56,960 --> 00:34:59,280
foto di dove cosa sta facendo la

641
00:34:59,280 --> 00:35:01,720
macchina. Io posso pure dire "Ok, leggo

642
00:35:01,720 --> 00:35:03,839
la stellina". Però quando poi la

643
00:35:03,839 --> 00:35:05,560
funzione di transizione mi dice va a

644
00:35:05,560 --> 00:35:07,800
destra, magari una stellina c'ha la

645
00:35:07,800 --> 00:35:09,440
casetta, dopo un'altra stellina c'ha

646
00:35:09,440 --> 00:35:11,800
l'alberello e io come faccio a sapere la

647
00:35:11,800 --> 00:35:15,000
testina cosa leggerà dopo se non so dove

648
00:35:15,000 --> 00:35:17,440
sta la testina? Quindi io devo

649
00:35:17,440 --> 00:35:20,000
memorizzare la posizione, non solo il

650
00:35:20,000 --> 00:35:22,119
contenuto. Non è sufficiente quello per

651
00:35:22,119 --> 00:35:24,760
ricostruire il funzionamento della

652
00:35:24,760 --> 00:35:28,680
macchina. È più chiaro così? Nulla. Ok.

653
00:35:28,680 --> 00:35:30,880
Quindi in H1

654
00:35:30,880 --> 00:35:32,480
memorizziamo

655
00:35:32,480 --> 00:35:34,440
la posizione

656
00:35:34,440 --> 00:35:36,200
che è un numero, eh, non è che chissà

657
00:35:36,200 --> 00:35:38,560
che stiamo facendo. La testina sa in

658
00:35:38,560 --> 00:35:41,960
posizione 27. Ok? Dobbiamo fare la

659
00:35:41,960 --> 00:35:46,040
stessa cosa per H2. Quanto è grosso H2?

660
00:35:46,040 --> 00:35:51,599
log di s
è log s n

661
00:35:57,280 --> 00:36:00,440
e q

662
00:36:00,560 --> 00:36:05,760
è una costante, ok? Perché il numero dei

663
00:36:05,760 --> 00:36:11,640
degli stati non dipende da

664
00:36:13,640 --> 00:36:18,560
Ok? Non dipende da eh dalla lunghezza

665
00:36:18,560 --> 00:36:22,480
dell'input. Ok?

666
00:36:23,000 --> 00:36:24,680
Allora,

667
00:36:24,680 --> 00:36:27,680
poiché

668
00:36:27,839 --> 00:36:33,200
guardate qui c'è questo elemento qua

669
00:36:33,200 --> 00:36:35,640
che

670
00:36:35,640 --> 00:36:38,640
è l'unico che tra virgolette non dipende

671
00:36:38,640 --> 00:36:42,079
da SN. Ok? Siccome, e qui c'è

672
00:36:42,079 --> 00:36:43,920
l'osservazione,

673
00:36:43,920 --> 00:36:46,240
siccome

674
00:36:46,240 --> 00:36:49,280
S nendo

675
00:36:49,280 --> 00:36:53,880
essere almeno log n,

676
00:36:54,839 --> 00:36:58,400
tutta la label

677
00:36:59,960 --> 00:37:03,319
Sì, label

678
00:37:03,760 --> 00:37:06,760
richiede

679
00:37:07,880 --> 00:37:12,920
Big o D SDN. simboli.

680
00:37:13,839 --> 00:37:18,920
Sì, sì, sì, c'ha

681
00:37:18,920 --> 00:37:21,920
simboli.

682
00:37:23,480 --> 00:37:25,000
Ok,

683
00:37:25,000 --> 00:37:27,119
quindi noi abbiamo espresso un vincolo

684
00:37:27,119 --> 00:37:32,520
su Sn. Siccome Sn non è più piccolo di

685
00:37:32,520 --> 00:37:36,319
log n, allora non sarà mai questo il

686
00:37:36,319 --> 00:37:39,560
leading term. Da per questa ragione noi

687
00:37:39,560 --> 00:37:42,480
abbiamo che tutto lo spazio che ci serve

688
00:37:42,480 --> 00:37:46,280
per rappresentare

689
00:37:46,280 --> 00:37:48,640
questa label che poi utilizzeremo nei

690
00:37:48,640 --> 00:37:53,560
nodi del computation graph è big o ddn.

691
00:37:53,560 --> 00:37:56,560
Ok?

692
00:37:56,839 --> 00:37:59,480
Alright. A questo punto possiamo fare

693
00:37:59,480 --> 00:38:02,800
delle considerazioni sulla sul grafo,

694
00:38:02,800 --> 00:38:04,640
no? sul grafo, su questo computation

695
00:38:04,640 --> 00:38:06,599
graph che stiamo andando a costruire,

696
00:38:06,599 --> 00:38:08,599
perché come vi dicevo, il nostro

697
00:38:08,599 --> 00:38:11,160
obiettivo è

698
00:38:11,160 --> 00:38:13,200
scriviamo il computation graph in

699
00:38:13,200 --> 00:38:16,000
memoria, lanciamo l'algoritmo di

700
00:38:16,000 --> 00:38:18,240
ricability, diamo la risposta. Quello

701
00:38:18,240 --> 00:38:20,839
che noi ci stiamo chiedendo è quanto

702
00:38:20,839 --> 00:38:22,720
occupa in memoria tutta questa

703
00:38:22,720 --> 00:38:24,960
procedura. Quindi il primo pezzo che ci

704
00:38:24,960 --> 00:38:27,119
serve è stabilire, ma questo grafo

705
00:38:27,119 --> 00:38:30,160
quanto è grosso? Ok? Quindi noi abbiamo

706
00:38:30,160 --> 00:38:34,920
che questi sono gli identificativi dei

707
00:38:34,920 --> 00:38:38,160
nodi. Ok?

708
00:38:38,160 --> 00:38:41,720
Ci chiediamo quindi quanti sono i nodi

709
00:38:41,720 --> 00:38:45,560
di questo grafico. Allora, noi abbiamo

710
00:38:45,560 --> 00:38:48,599
che su work tape ci possono stare i vari

711
00:38:48,599 --> 00:38:51,240
simboli di nastro. Poi qua abbiamo la

712
00:38:51,240 --> 00:38:54,720
codifica binaria, binaria binaria. Però

713
00:38:54,720 --> 00:38:58,079
il tutto è bounded da cosa?

714
00:38:58,079 --> 00:39:00,800
dalla quantità di nodi che si possono

715
00:39:00,800 --> 00:39:03,680
generare se noi usassimo tutti i simboli

716
00:39:03,680 --> 00:39:05,920
di nastro in tutte le posizioni, ok?

717
00:39:05,920 --> 00:39:07,960
Quello è proprio al più e quello il

718
00:39:07,960 --> 00:39:11,440
numero, ok?

719
00:39:12,160 --> 00:39:15,040
Siano

720
00:39:15,040 --> 00:39:18,800
L I

721
00:39:19,880 --> 00:39:23,760
sia L. Scriviamo meglio.

722
00:39:23,760 --> 00:39:26,680
Facciamo proprio così. Sia l la

723
00:39:26,680 --> 00:39:30,800
cardinalità dell'alfabeto di nastro. Ok?

724
00:39:30,800 --> 00:39:34,839
Allora, il numero di nodi è big o di

725
00:39:34,839 --> 00:39:37,839
cosa?

726
00:39:44,119 --> 00:39:48,280
S
l elevato SN. Ragazzi, qua stiamo

727
00:39:48,280 --> 00:39:50,599
proprio togliendo costanti eccetera,

728
00:39:50,599 --> 00:39:52,599
facciamo proprio un'analisi raff, eh,

729
00:39:52,599 --> 00:39:57,880
quindi è big o d^ s n

730
00:39:57,880 --> 00:40:01,760
è il numero dei nodi

731
00:40:01,760 --> 00:40:03,960
di questo grafo G, di questo computation

732
00:40:03,960 --> 00:40:09,480
graph. Ok, so tantini, eh.

733
00:40:09,960 --> 00:40:11,720
Quando rappresentiamo il grafo, facciamo

734
00:40:11,720 --> 00:40:14,920
solo la lista dei nodi.

735
00:40:14,920 --> 00:40:16,960
Ci servono gli archi. Gli archi in linea

736
00:40:16,960 --> 00:40:19,200
di principio sono tutte le possibili

737
00:40:19,200 --> 00:40:20,960
coppie dei nodi. Posso essere proprio

738
00:40:20,960 --> 00:40:24,119
tante. Ok. Quanti sono gli archi? Big O

739
00:40:24,119 --> 00:40:27,319
di cosa?

740
00:40:34,119 --> 00:40:36,960
Attenzione, attenzione.

741
00:40:36,960 --> 00:40:40,079
Se abbiamo

742
00:40:40,240 --> 00:40:44,359
eh se abbiamo V nodi, no, un numero di

743
00:40:44,359 --> 00:40:46,079
S,

744
00:40:46,079 --> 00:40:50,160
eh abbiamo M nodi. Ok? Se abbiamo m

745
00:40:50,160 --> 00:40:52,880
nodi, quanti sono al massimo gli archi?

746
00:40:52,880 --> 00:40:55,839
Qu
m quato. Quindi se il numero dei nodi

747
00:40:55,839 --> 00:41:00,400
è big o di l^ s n, quanti potranno mai

748
00:41:00,400 --> 00:41:03,839
essere gli archi?

749
00:41:04,240 --> 00:41:07,560
quadrato
il quadrato di quello, quindi è

750
00:41:07,560 --> 00:41:13,079
L^ S n al quadrato

751
00:41:13,079 --> 00:41:17,800
che per la proprietà delle potenze è big

752
00:41:17,800 --> 00:41:25,240
o di L^ 2 * S n e questo è il numero di

753
00:41:25,240 --> 00:41:28,200
vertici

754
00:41:28,200 --> 00:41:33,280
è numero di
di di archi. Sì, sì, sì.

755
00:41:34,520 --> 00:41:37,319
numero di archi.

756
00:41:37,319 --> 00:41:39,920
Ok?

757
00:41:39,920 --> 00:41:45,079
Fra i due, chi è quello più grande?

758
00:41:45,079 --> 00:41:47,319
Il secondo. Quindi quello è leading

759
00:41:47,319 --> 00:41:50,640
term. Abbiamo che la taglia di questo

760
00:41:50,640 --> 00:41:56,520
computation graph è questa qui, è big o

761
00:41:56,520 --> 00:42:01,520
di l^ 2 * SN. Ok?

762
00:42:01,520 --> 00:42:04,920
Quindi, nel momento in cui facciamo

763
00:42:04,920 --> 00:42:08,000
avanzare questa procedura, noi abbiamo

764
00:42:08,000 --> 00:42:12,720
che generiamo il computation graph

765
00:42:12,720 --> 00:42:15,599
e occupiamo quello spazio. Dopodiché

766
00:42:15,599 --> 00:42:17,599
dobbiamo eseguire

767
00:42:17,599 --> 00:42:19,640
la procedura di Richability vista

768
00:42:19,640 --> 00:42:23,760
stamattina su quel grafo. Ricordo che la

769
00:42:23,760 --> 00:42:26,760
complessità

770
00:42:28,520 --> 00:42:30,040
complessità

771
00:42:30,040 --> 00:42:33,040
spaziale

772
00:42:34,200 --> 00:42:38,160
di Exist path

773
00:42:40,400 --> 00:42:43,400
existia

774
00:42:51,079 --> 00:42:54,160
del grafo.

775
00:42:54,160 --> 00:42:59,520
Ok, allora combiniamo le cose.

776
00:42:59,520 --> 00:43:02,680
Che cosa abbiamo? Abbiamo big o. Guardo

777
00:43:02,680 --> 00:43:04,880
gli appunti, non voglio scrivere una

778
00:43:04,880 --> 00:43:08,920
stupidaggine. Big O di

779
00:43:08,920 --> 00:43:11,920
log

780
00:43:14,200 --> 00:43:18,160
2 * SN

781
00:43:18,160 --> 00:43:21,160
quadrato.

782
00:43:23,599 --> 00:43:28,359
Questa cosa è big o

783
00:43:29,440 --> 00:43:37,640
di cosa? di 2 * s n * log

784
00:43:37,640 --> 00:43:40,800
al quadrato.

785
00:43:42,480 --> 00:43:45,400
Questa qui che cos'è?

786
00:43:45,400 --> 00:43:47,520
Una costante.
È una costante, quindi la

787
00:43:47,520 --> 00:43:49,599
possiamo buttare.

788
00:43:49,599 --> 00:43:52,079
Costante

789
00:43:52,079 --> 00:43:56,000
e anche questa è una costante e si può

790
00:43:56,000 --> 00:43:59,800
togliere. Quindi il tutto è big o di

791
00:43:59,800 --> 00:44:05,599
cosa? Di S n al quadrato.

792
00:44:05,960 --> 00:44:08,960
Chiaro?

793
00:44:10,680 --> 00:44:12,599
Vi ricordo che le costanti possono

794
00:44:12,599 --> 00:44:15,200
essere tolte dalle classi asintotiche,

795
00:44:15,200 --> 00:44:18,480
ok? Quindi 2 è una costante e la

796
00:44:18,480 --> 00:44:21,319
togliamo. Log in base 2 di L è una

797
00:44:21,319 --> 00:44:25,240
costante perché? Perché L è il numero di

798
00:44:25,240 --> 00:44:27,800
simboli dell'alfabeto di nastro, ma

799
00:44:27,800 --> 00:44:30,240
l'alfabeto di nastro è fissato, non è

800
00:44:30,240 --> 00:44:32,920
che cambia in base a quanto è grande la

801
00:44:32,920 --> 00:44:34,400
stringa, diciamo, "Ah, mi serve un

802
00:44:34,400 --> 00:44:36,079
simbolo in più, la stringa è troppo

803
00:44:36,079 --> 00:44:39,200
gross". Ok, quello è fissato. Quindi

804
00:44:39,200 --> 00:44:41,400
questi due li possiamo ignorare e il

805
00:44:41,400 --> 00:44:46,480
tutto è bigo d Sn al quadato. Ok? Qual è

806
00:44:46,480 --> 00:44:49,800
la conseguenza di questa cosa qua?

807
00:44:49,800 --> 00:44:52,920
Facciamo prima questo e poi

808
00:44:52,920 --> 00:44:56,079
facciamo pausa.

809
00:44:56,079 --> 00:44:58,319
Noto che

810
00:44:58,319 --> 00:45:00,240
finiamo prestissimo oggi, quindi avremmo

811
00:45:00,240 --> 00:45:02,680
il tempo di fare il questionario.

812
00:45:02,680 --> 00:45:07,200
Cercavo cercavo un giorno in cui ilceste

813
00:45:07,200 --> 00:45:08,640
perdere, ma non un questionario di

814
00:45:08,640 --> 00:45:14,480
esame, il questionario mio. Allora,

815
00:45:14,880 --> 00:45:17,520
possiamo quindi definire

816
00:45:17,520 --> 00:45:21,760
possiamo quindi definire P spazio e NP

817
00:45:21,760 --> 00:45:25,160
spazio, ok? Che sono l'equivalente di PD

818
00:45:25,160 --> 00:45:27,800
NP, invece di essere sul tempo possono

819
00:45:27,800 --> 00:45:33,920
essere sullo spazio. Ok? Secondo voi

820
00:45:34,040 --> 00:45:38,400
cosa sarà My Space?

821
00:45:39,920 --> 00:45:42,480
Ah, dove li ho?

822
00:45:42,480 --> 00:45:45,480
Qua.

823
00:45:50,079 --> 00:45:52,240
Come potremo definire la classe

824
00:45:52,240 --> 00:45:56,160
polynomial space?

825
00:46:00,319 --> 00:46:05,040
Me lo ricordate com'è definito P time?

826
00:46:05,359 --> 00:46:09,280
è l'unione per i c maggiore uguali di 1.

827
00:46:09,280 --> 00:46:17,319
Sì.
E di di time e sì di space di n^

828
00:46:17,319 --> 00:46:21,040
c.
Bravissimo. Ok. Questo è pi spazio.

829
00:46:21,040 --> 00:46:23,800
Che cos'è pi spazio? È l'insieme di

830
00:46:23,800 --> 00:46:25,880
tutti i linguaggi

831
00:46:25,880 --> 00:46:29,520
che possono essere decisi in spazio

832
00:46:29,520 --> 00:46:31,040
polinomiale

833
00:46:31,040 --> 00:46:33,400
da una macchina di Touring

834
00:46:33,400 --> 00:46:36,920
deterministica. spazio è una classe

835
00:46:36,920 --> 00:46:39,839
tostissima, eh, cioè mo adesso vedremo

836
00:46:39,839 --> 00:46:42,240
poi la relazione con le altre con le

837
00:46:42,240 --> 00:46:43,960
altre classi che abbiamo visto, ma un

838
00:46:43,960 --> 00:46:46,960
problema che sia uno dei problemi tosti

839
00:46:46,960 --> 00:46:49,079
di più spazio è un problema che richiede

840
00:46:49,079 --> 00:46:51,240
una quantità di tempo mostruosa per

841
00:46:51,240 --> 00:46:55,240
essere per essere risolto. Ok?

842
00:46:55,240 --> 00:46:58,800
ed n spazio.

843
00:47:08,040 --> 00:47:11,240
Esattamente l'unione su C che è maggiore

844
00:47:11,240 --> 00:47:14,440
di 1 di n space

845
00:47:14,440 --> 00:47:17,760
di n^ c.

846
00:47:17,760 --> 00:47:19,440
È chiaro?

847
00:47:19,440 --> 00:47:21,359
Ok.

848
00:47:21,359 --> 00:47:25,200
Guardate queste due definizioni.

849
00:47:25,200 --> 00:47:27,880
Guardate cosa possiamo dire della

850
00:47:27,880 --> 00:47:31,079
relazione di contenimento di questi due

851
00:47:31,079 --> 00:47:36,119
di queste due classe. Chi contiene chi?

852
00:47:36,119 --> 00:47:37,720
quella la più immediata, la più

853
00:47:37,720 --> 00:47:40,720
semplice.

854
00:47:42,000 --> 00:47:46,200
Sì, abbiamo che sicuramente pi spazio

855
00:47:46,200 --> 00:47:50,319
è contenuto in n spazio.

856
00:47:50,319 --> 00:47:53,319
Ok?

857
00:47:53,839 --> 00:47:55,599
Benissimo.

858
00:47:55,599 --> 00:47:58,119
Guardate il teorema di Savic che cosa ci

859
00:47:58,119 --> 00:48:00,640
dice?

860
00:48:00,640 --> 00:48:04,040
Che sono uguali.
Che sono uguali.

861
00:48:04,040 --> 00:48:07,359
Il teorema di Savic sostanzialmente ci

862
00:48:07,359 --> 00:48:11,480
dice che tutte le classi spaziali

863
00:48:11,480 --> 00:48:14,440
da pi spazio a salire perché la cosa non

864
00:48:14,440 --> 00:48:16,640
funziona sul log space perché quello

865
00:48:16,640 --> 00:48:18,800
sarebbe log space al quadrato. Ok?

866
00:48:18,800 --> 00:48:22,359
Quindi il teorema di Savic ci dice che

867
00:48:22,359 --> 00:48:26,200
tutte le classi di complessità spaziali

868
00:48:26,200 --> 00:48:29,880
da polinomial a salire la classe

869
00:48:29,880 --> 00:48:33,119
deterministica eguaglia la classe non

870
00:48:33,119 --> 00:48:34,680
deterministica.

871
00:48:34,680 --> 00:48:36,720
P spazio

872
00:48:36,720 --> 00:48:40,640
è uguale a NPA

873
00:48:40,640 --> 00:48:43,520
per il teorema di Savic.

874
00:48:43,520 --> 00:48:47,559
L'intuizione qual è? L'intuizione è che

875
00:48:47,559 --> 00:48:50,599
siccome abbiamo vincoli sullo spazio, ma

876
00:48:50,599 --> 00:48:53,280
non sul tempo, cioè il tempo una volta

877
00:48:53,280 --> 00:48:55,240
che lo usiamo il tempo è andato, non è

878
00:48:55,240 --> 00:48:57,839
che lo recuperiamo, lo spazio invece può

879
00:48:57,839 --> 00:49:01,559
essere riutilizzato. Ecco perché

880
00:49:01,559 --> 00:49:04,880
pi spazio è uguale a n spazio, perché

881
00:49:04,880 --> 00:49:07,720
noi praticamente una macchina a P spazio

882
00:49:07,720 --> 00:49:09,440
può simulare una macchina non

883
00:49:09,440 --> 00:49:11,960
deterministica, polynomial space,

884
00:49:11,960 --> 00:49:14,440
semplicemente riprovando, facendo le fa

885
00:49:14,440 --> 00:49:16,119
un tentativo, non è andata bene,

886
00:49:16,119 --> 00:49:18,200
riprovo, ma lo spazio chiuso è sempre lo

887
00:49:18,200 --> 00:49:20,240
stesso, è quella la ragione

888
00:49:20,240 --> 00:49:23,000
sostanzialmente. Ok?

889
00:49:23,000 --> 00:49:26,079
Questo fa sì che tutte le classi di

890
00:49:26,079 --> 00:49:29,119
complessità spaziale sopra si considera

891
00:49:29,119 --> 00:49:31,760
sempre la versione deterministica perché

892
00:49:31,760 --> 00:49:34,040
la versione non deterministica non ci dà

893
00:49:34,040 --> 00:49:36,680
nulla di più. Ok?

894
00:49:36,680 --> 00:49:39,799
Bene, con questo facciamo un po' di

895
00:49:39,799 --> 00:49:41,880
pausa,

896
00:49:41,880 --> 00:49:45,040
una decina di minuti.

897
00:49:45,040 --> 00:49:47,320
[Musica]