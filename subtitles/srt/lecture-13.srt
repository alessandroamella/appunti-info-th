1
00:00:01,599 --> 00:00:05,759
Come vi dicevo, oggi è una lezione molto

2
00:00:05,759 --> 00:00:08,200
importante, proprio molto importante,

3
00:00:08,200 --> 00:00:10,639
perché introdurremo

4
00:00:10,639 --> 00:00:13,160
il concetto di riduzione, che è un

5
00:00:13,160 --> 00:00:16,000
concetto che useremo per il resto del

6
00:00:16,000 --> 00:00:19,320
corso, ok? Quindi è una cosa che va

7
00:00:19,320 --> 00:00:21,119
proprio capita,

8
00:00:21,119 --> 00:00:23,119
quindi oggi ci prendiamo il tempo,

9
00:00:23,119 --> 00:00:25,680
facciamo le cose piano perché è una cosa

10
00:00:25,680 --> 00:00:27,800
che vi deve essere proprio cristal clear

11
00:00:27,800 --> 00:00:31,119
perché sennò diventa incase.

12
00:00:31,119 --> 00:00:33,000
Iniziamo con una metafora, con una

13
00:00:33,000 --> 00:00:34,480
storiella, una metafora. Vi faccio

14
00:00:34,480 --> 00:00:37,600
capire che si intende per riduzione, poi

15
00:00:37,600 --> 00:00:39,320
e poi la definiamo formalmente, poi

16
00:00:39,320 --> 00:00:42,239
laeremo un po' per un po' di teoremi,

17
00:00:42,239 --> 00:00:45,360
per un po' di teoremi e

18
00:00:45,360 --> 00:00:46,600
vediamo un po' come si fa. Poi

19
00:00:46,600 --> 00:00:49,000
ovviamente vedremo le esercizi, tutta

20
00:00:49,000 --> 00:00:50,879
una serie di cose, ma gran parte dei

21
00:00:50,879 --> 00:00:53,199
risultati che terremo da da qui al resto

22
00:00:53,199 --> 00:00:54,760
del corso si aggiungono tramite

23
00:00:54,760 --> 00:00:56,680
rifuzioni. Ok? Allora, perché

24
00:00:56,680 --> 00:01:00,480
introduciamo questo concetto? Perché

25
00:01:00,480 --> 00:01:02,840
avrete notato dalla lezione di ieri, la

26
00:01:02,840 --> 00:01:08,119
lezione di ieri com'era? Intrigata?

27
00:01:08,400 --> 00:01:10,759
Avete un glimpse di di come è stato

28
00:01:10,759 --> 00:01:13,759
organizzato. Ok? Allora, sostanzialmente

29
00:01:13,759 --> 00:01:16,880
noi abbiamo che per la definizione dei

30
00:01:16,880 --> 00:01:18,799
concetti di linguaggio ricorsivamente

31
00:01:18,799 --> 00:01:20,400
numerabile linguaggio ricorsivo, noi

32
00:01:20,400 --> 00:01:22,040
abbiamo che se dobbiamo mostrare che il

33
00:01:22,040 --> 00:01:24,439
linguaggio è in uno di quelli insieme

34
00:01:24,439 --> 00:01:26,439
dobbiamo mostrare un algoritmo, un

35
00:01:26,439 --> 00:01:28,799
algoritmo di R o un algoritmo di R,

36
00:01:28,799 --> 00:01:31,360
dipende da che mostrare. Se dobbiamo

37
00:01:31,360 --> 00:01:32,840
mostrare che invece un linguaggio non

38
00:01:32,840 --> 00:01:35,640
sta in quegli insiemi, quindi dobbiamo

39
00:01:35,640 --> 00:01:38,520
dire non esiste alcuna macchina che

40
00:01:38,520 --> 00:01:40,520
ecco, ovviamente noi possiamo andare là

41
00:01:40,520 --> 00:01:42,520
a contare dire questa no, questa no,

42
00:01:42,520 --> 00:01:45,719
questa no. Ci inventare altro. Allora,

43
00:01:45,719 --> 00:01:47,439
abbiamo fatto varie dimostrazioni ieri,

44
00:01:47,439 --> 00:01:48,840
ma avevamo tutte più o meno lo stesso

45
00:01:48,840 --> 00:01:51,560
flavor, quelle là in cui escludevano un

46
00:01:51,560 --> 00:01:53,640
linguaggio da una classe. Che che

47
00:01:53,640 --> 00:01:55,520
principio avevano? facevamo

48
00:01:55,520 --> 00:01:57,039
un'assunzione per assurdo, diceva

49
00:01:57,039 --> 00:01:58,640
supponiamo che questa cosa sia

50
00:01:58,640 --> 00:02:00,759
decidibile. Dopodiché costruivamo

51
00:02:00,759 --> 00:02:03,320
un'altra bella macchinina, infilavamo

52
00:02:03,320 --> 00:02:06,200
dentro questa macchinina la macchina

53
00:02:06,200 --> 00:02:08,800
assunta esistere e succedeva un casino.

54
00:02:08,800 --> 00:02:11,720
Ok? Quindi questo era in genere

55
00:02:11,720 --> 00:02:14,239
l'approccio che utilizzavamo per

56
00:02:14,239 --> 00:02:15,879
dimostrare che i linguaggi non stavano

57
00:02:15,879 --> 00:02:19,080
in R o non stavano in R. Ok?

58
00:02:19,080 --> 00:02:21,840
Questo qui erano delle istanziazioni,

59
00:02:21,840 --> 00:02:23,599
c'erano dei casi particolari di un

60
00:02:23,599 --> 00:02:26,080
principio molto più generale che diciamo

61
00:02:26,080 --> 00:02:27,800
stamattina che è il principio della

62
00:02:27,800 --> 00:02:30,959
riduzione fra linguaggi. Ok?

63
00:02:30,959 --> 00:02:33,000
E una volta che acquisiremo questo

64
00:02:33,000 --> 00:02:35,640
strumento, praticamente tutte le

65
00:02:35,640 --> 00:02:37,800
dimostrazioni in cui dovremo mostrare

66
00:02:37,800 --> 00:02:39,920
che un linguaggio non appartiene a una

67
00:02:39,920 --> 00:02:42,319
certa classe verranno fatte tramite

68
00:02:42,319 --> 00:02:44,879
riduzione perché è più facile. Ok?

69
00:02:44,879 --> 00:02:48,920
Allora, è più facile da un lato,

70
00:02:48,920 --> 00:02:50,800
non completamente. Ecco perché oggi

71
00:02:50,800 --> 00:02:54,000
andiamo piano e cerchiamo di capire che

72
00:02:54,000 --> 00:02:55,640
se sia un concetto chiaro per tutti.

73
00:02:55,640 --> 00:02:58,040
Perché il concetto di riduzione ho

74
00:02:58,040 --> 00:03:00,400
potuto vedere negli anni che è una cosa

75
00:03:00,400 --> 00:03:03,080
che è un po' più difficile da acquisire,

76
00:03:03,080 --> 00:03:06,319
ma non perché il concetto di riduzione

77
00:03:06,319 --> 00:03:09,120
sia intrinsicamente complicato, ma

78
00:03:09,120 --> 00:03:11,720
perché il concetto di riduzione è fatto

79
00:03:11,720 --> 00:03:13,959
di vari elementi, cioè per riuscire a

80
00:03:13,959 --> 00:03:16,920
utilizzarlo dobbiamo stare attenti a una

81
00:03:16,920 --> 00:03:19,080
serie di cose che diventa facile

82
00:03:19,080 --> 00:03:21,280
perdersi per strada. Tutto qua. Però se

83
00:03:21,280 --> 00:03:23,440
ci diamo una checklist le cose le

84
00:03:23,440 --> 00:03:25,599
dobbiamo vedere, ok? Quando si fa una

85
00:03:25,599 --> 00:03:27,319
riduzione dobbiamo controllare questo,

86
00:03:27,319 --> 00:03:29,000
questo, questo, questo e quest'altro.

87
00:03:29,000 --> 00:03:35,400
Allora, spero e immagino che sia che sia

88
00:03:35,400 --> 00:03:39,560
che sia fattibile, ok? È veramente

89
00:03:39,560 --> 00:03:42,959
comune, è veramente comune capirlo male,

90
00:03:42,959 --> 00:03:47,439
ok? Però cercheremo di di farlo. Eh,

91
00:03:47,439 --> 00:03:51,480
spesso nei nei nei nei compiti di esame

92
00:03:51,480 --> 00:03:54,000
vedo che le riduzioni sono fatte male.

93
00:03:54,000 --> 00:03:55,120
Ok?

94
00:03:55,120 --> 00:03:57,599
E perché? Perché è abbastanza naturale

95
00:03:57,599 --> 00:03:59,879
che uno non acchiappi alcuni elementi

96
00:03:59,879 --> 00:04:01,439
della riduzione. Io stesso quando ero

97
00:04:01,439 --> 00:04:03,319
uno studente di informatica teorica

98
00:04:03,319 --> 00:04:06,079
all'esame fa riduzione sbagliata.

99
00:04:06,079 --> 00:04:08,519
Professore, ma la riduzione qui? Ah, è

100
00:04:08,519 --> 00:04:11,519
giusto. Lì imparai, lì capì, no? Quando

101
00:04:11,519 --> 00:04:13,599
ero friggevo su quella sedia ho detto

102
00:04:13,599 --> 00:04:15,319
"Ah, la riduzione così si fa e che

103
00:04:15,319 --> 00:04:18,320
cavolo". A capirlo prima. Ok? Quindi

104
00:04:18,320 --> 00:04:20,880
cerchiamo di capire per bene assieme

105
00:04:20,880 --> 00:04:24,680
cos'è questo concetto. E

106
00:04:24,680 --> 00:04:26,759
per affrontarlo

107
00:04:26,759 --> 00:04:29,960
per affrontarlo partiamo da la prendiamo

108
00:04:29,960 --> 00:04:32,759
proprio alla larga, eh, partiamo da una

109
00:04:32,759 --> 00:04:34,639
storiella.

110
00:04:34,639 --> 00:04:36,880
Quando ero studente,

111
00:04:36,880 --> 00:04:38,400
a un certo punto stiamo facendo che era

112
00:04:38,400 --> 00:04:41,240
il terzo anno, mi pare, una serie di una

113
00:04:41,240 --> 00:04:45,080
serie di esami tra cui gesteva

114
00:04:45,080 --> 00:04:49,560
ah l'esame di web services. È un esame

115
00:04:49,560 --> 00:04:51,880
di algoritmica un po' avanzata, design

116
00:04:51,880 --> 00:04:54,360
patterns ste cose così, no? E per

117
00:04:54,360 --> 00:04:57,400
l'esame di eh web services loro volevano

118
00:04:57,400 --> 00:05:00,440
un progetto da annare su un server

119
00:05:00,440 --> 00:05:03,160
applicativo e ognuno si poteva scegliere

120
00:05:03,160 --> 00:05:05,639
che volevamo fare e io col mio team

121
00:05:05,639 --> 00:05:07,840
c'eravamo scelti di fare questa

122
00:05:07,840 --> 00:05:10,880
applicazione su web che era la gestione

123
00:05:10,880 --> 00:05:13,759
dei tornei di calcio di calcetto, ok?

124
00:05:13,759 --> 00:05:15,960
Quindi gli utenti si registravano a

125
00:05:15,960 --> 00:05:17,840
questo sito, potevano registrare se

126
00:05:17,840 --> 00:05:19,880
stessi, la propria squadra. Dopodiché

127
00:05:19,880 --> 00:05:22,240
una volta che erano

128
00:05:22,240 --> 00:05:25,039
iscritte le squadre al sistema, questo

129
00:05:25,039 --> 00:05:27,479
sistema doveva generare il calendario in

130
00:05:27,479 --> 00:05:29,520
maniera automatica. Ok? È chiaro per

131
00:05:29,520 --> 00:05:31,880
tutti il concetto del calendario di un

132
00:05:31,880 --> 00:05:35,240
torneo? Che cos'è? Ok, allora va bene,

133
00:05:35,240 --> 00:05:38,280
ci serve sto cavolo d'algoritmo, no?

134
00:05:38,280 --> 00:05:41,400
Ehm, pensa che ti ripensa e non ci

135
00:05:41,400 --> 00:05:43,680
tornava facile riuscire a generare sto

136
00:05:43,680 --> 00:05:45,759
cavolo di sto cavolo di calendario,

137
00:05:45,759 --> 00:05:48,199
perché il problema qual era? Avevamo

138
00:05:48,199 --> 00:05:51,680
difficoltà a infilare

139
00:05:51,680 --> 00:05:53,600
a essere sicuri che nella stessa

140
00:05:53,600 --> 00:05:55,680
giornata non finissero partite

141
00:05:55,680 --> 00:05:58,120
incompatibili, cioè che una stessa

142
00:05:58,120 --> 00:06:00,400
squadra non poteva giocare contro altre

143
00:06:00,400 --> 00:06:02,639
due squadre nella stessa giornata. Ok?

144
00:06:02,639 --> 00:06:04,720
Quindi l'algoritmo doveva tirare fuori

145
00:06:04,720 --> 00:06:07,680
questa riallocazione sottoinsiemi di

146
00:06:07,680 --> 00:06:09,639
tutte le possibili ripartite tale per

147
00:06:09,639 --> 00:06:12,400
cui questa partizione sostanzialmente

148
00:06:12,400 --> 00:06:14,280
fosse coerente

149
00:06:14,280 --> 00:06:16,960
e ci abbiamo provato per giorni e non ci

150
00:06:16,960 --> 00:06:18,560
riuscivamo, non riuscivamo a capire sta

151
00:06:18,560 --> 00:06:21,520
cosa. Si avvicinava il giorno dell'esame

152
00:06:21,520 --> 00:06:23,840
a noi sto pezzo di algoritmo ancora

153
00:06:23,840 --> 00:06:26,479
mancava. Detto come cavolo facciamo?

154
00:06:26,479 --> 00:06:28,960
Allora, a quel punto mi venne un'idea.

155
00:06:28,960 --> 00:06:31,919
Mi venne un'idea perché detto "Ok, ma se

156
00:06:31,919 --> 00:06:34,400
non ci riusciamo così possiamo provare

157
00:06:34,400 --> 00:06:36,280
ad attaccarlo

158
00:06:36,280 --> 00:06:38,919
da un'altra via". Ok? A quel tempo,

159
00:06:38,919 --> 00:06:40,840
quindi, stavamo seguendo il corso di

160
00:06:40,840 --> 00:06:42,880
design patterns ed algoritmica,

161
00:06:42,880 --> 00:06:45,000
eccetera, e stavamo guardando

162
00:06:45,000 --> 00:06:48,199
backtracking, queste cose qua, no?

163
00:06:48,199 --> 00:06:52,160
E proprio per quel corso

164
00:06:52,160 --> 00:06:54,680
avevamo sviluppato un algoritmo che era

165
00:06:54,680 --> 00:06:57,240
in grado di colorare

166
00:06:57,240 --> 00:06:58,960
chiaro? Sapete qual è il problema della

167
00:06:58,960 --> 00:07:01,479
colorazione di un grafo? Dato un grafo

168
00:07:01,479 --> 00:07:04,360
fatto di pallette e archi, noi vogliamo

169
00:07:04,360 --> 00:07:06,479
colorare i suoi nodi proprio con i

170
00:07:06,479 --> 00:07:09,720
colori, tale per cui non accade che due

171
00:07:09,720 --> 00:07:12,360
nodi agganciati da un arco abbiano lo

172
00:07:12,360 --> 00:07:15,560
stesso colore. Ok?

173
00:07:15,560 --> 00:07:17,759
Quindi avevo da un lato la generazione

174
00:07:17,759 --> 00:07:20,280
del torneo e non riuscivamo a tirare

175
00:07:20,280 --> 00:07:22,199
fuori sto coso, non funzionava.

176
00:07:22,199 --> 00:07:23,879
Dall'altro avevo un algoritmo che mi

177
00:07:23,879 --> 00:07:25,960
funzionava che era in grado di colorare

178
00:07:25,960 --> 00:07:30,639
grafici. Mi sono chiesto, ma posso

179
00:07:30,639 --> 00:07:33,639
convertire un'istanza della generazione

180
00:07:33,639 --> 00:07:37,080
del torneo in un grafo da colorare e poi

181
00:07:37,080 --> 00:07:39,440
mi sfrutto la colorazione. Cioè questa

182
00:07:39,440 --> 00:07:41,720
era l'idea. Detto, siccome l'algoritmo

183
00:07:41,720 --> 00:07:43,599
diretto ancora non riuscivamo a tirarlo

184
00:07:43,599 --> 00:07:46,560
fuori, poi dopo tanto tempo arrivando

185
00:07:46,560 --> 00:07:48,680
anche era fattibile la cosa, però lì per

186
00:07:48,680 --> 00:07:50,039
lì che non trovavamo una soluzione, ho

187
00:07:50,039 --> 00:07:52,560
detto "Ok, mi serve altro".

188
00:07:52,560 --> 00:07:55,720
mi serve altro. c'ho quest'algoritmo che

189
00:07:55,720 --> 00:07:57,919
è in grado di fare un problema

190
00:07:57,919 --> 00:08:00,000
completamente diverso, eh, cioè là era

191
00:08:00,000 --> 00:08:02,360
colorazione di un grafo da un lato,

192
00:08:02,360 --> 00:08:04,360
generazione delle giornate, il

193
00:08:04,360 --> 00:08:05,960
calendario dall'altro, cioè quindi erano

194
00:08:05,960 --> 00:08:08,800
due cose completamente separate. L'idea

195
00:08:08,800 --> 00:08:11,680
era posso trasformare le istanze di

196
00:08:11,680 --> 00:08:14,919
questo problema in quest'altro problema,

197
00:08:14,919 --> 00:08:17,240
così mi uso il mio algoritmo che mi

198
00:08:17,240 --> 00:08:20,319
colora grafi e la sua colorazione poi la

199
00:08:20,319 --> 00:08:23,800
prendo e la sputto per tirare fuori il

200
00:08:23,800 --> 00:08:26,440
calendario di

201
00:08:26,440 --> 00:08:29,240
un Ok? È chiaro il problema? Quindi, se

202
00:08:29,240 --> 00:08:31,960
vogliamo astrarci da questa situazione,

203
00:08:31,960 --> 00:08:34,000
adesso vedremo l'esempio specifico, però

204
00:08:34,000 --> 00:08:36,360
l'astrazione è questa. Noi abbiamo un

205
00:08:36,360 --> 00:08:38,719
problema di partenza

206
00:08:38,719 --> 00:08:43,399
A, lo chiamiamo L1 piccolo, come volete

207
00:08:43,399 --> 00:08:46,279
voi. Abbiamo un problema

208
00:08:46,279 --> 00:08:50,279
che vogliamo vogliamo risolvere, ma non

209
00:08:50,279 --> 00:08:53,519
lo vogliamo attaccare direttamente. Ok?

210
00:08:53,519 --> 00:08:56,880
Quindi abbiamo un problema di partenza,

211
00:08:56,880 --> 00:08:59,160
ok? Quindi iniziate a cogliere questo

212
00:08:59,160 --> 00:09:01,240
elemento. C'è un problema di partenza e

213
00:09:01,240 --> 00:09:03,399
un problema di arrivo nelle riduzioni.

214
00:09:03,399 --> 00:09:06,440
Le riduzioni non sono

215
00:09:06,440 --> 00:09:09,640
da simmetriche, ok? C'è un verso nelle

216
00:09:09,640 --> 00:09:12,240
riduzioni. Abbiamo un problema di

217
00:09:12,240 --> 00:09:17,680
partenza e un problema di arrivo.

218
00:09:17,680 --> 00:09:22,279
Lo scenario è questo: vogliamo risolvere

219
00:09:22,279 --> 00:09:27,160
le istanze del problema di partenza.

220
00:09:27,160 --> 00:09:31,120
utilizzando un algoritmo pronto, diciamo

221
00:09:31,120 --> 00:09:35,800
così, per il problema di arrivo.

222
00:09:35,800 --> 00:09:38,959
È chiaro? Cioè, quindi siamo la vogliamo

223
00:09:38,959 --> 00:09:42,000
inventarci come risolvere il problema di

224
00:09:42,000 --> 00:09:45,000
partenza.

225
00:09:45,000 --> 00:09:48,600
Cosa facciamo? ci andiamo a scegliere un

226
00:09:48,600 --> 00:09:52,399
problema di attivo, ad esempio, magari

227
00:09:52,399 --> 00:09:54,959
non troppo di simile,

228
00:09:54,959 --> 00:09:58,320
e trasformiamo le istanze del problema

229
00:09:58,320 --> 00:10:00,640
di partenza

230
00:10:00,640 --> 00:10:04,399
nel in istanze del problema di arrivo,

231
00:10:04,399 --> 00:10:07,839
tale per cui possiamo utilizzare un

232
00:10:07,839 --> 00:10:10,959
solutore del problema di arrivo, ci

233
00:10:10,959 --> 00:10:13,360
prendiamo la soluzione, la

234
00:10:13,360 --> 00:10:16,480
ritrasformiamo all'indietro e la usiamo

235
00:10:16,480 --> 00:10:18,399
come soluzione per l'istanza del

236
00:10:18,399 --> 00:10:21,120
problema di partenza. È chiaro? Quindi

237
00:10:21,120 --> 00:10:24,600
noi vogliamo risolvere un problema

238
00:10:24,600 --> 00:10:27,560
utilizzando una subrutine per un altro

239
00:10:27,560 --> 00:10:30,920
problema. Ok? Quindi la questione qui è

240
00:10:30,920 --> 00:10:33,560
come trasformiamo istanze da un problema

241
00:10:33,560 --> 00:10:36,760
dell'altro in maniera tale che le la

242
00:10:36,760 --> 00:10:39,920
soluzione della istanza del sul problema

243
00:10:39,920 --> 00:10:42,399
di arrivo possa essere ritrasformata

244
00:10:42,399 --> 00:10:44,200
all'indietro perché se ci dà una

245
00:10:44,200 --> 00:10:46,279
soluzione e non sappiamo che farci poi

246
00:10:46,279 --> 00:10:48,800
diventa un po' problematico. Ok? Piano

247
00:10:48,800 --> 00:10:51,839
per tutti? Quindi,

248
00:10:51,839 --> 00:10:54,279
intuitivamente iniziamo a introdurre un

249
00:10:54,279 --> 00:10:57,720
po' di elementi. Questa trasformazione,

250
00:10:57,720 --> 00:11:00,200
poi daremo definizioni precise, però

251
00:11:00,200 --> 00:11:03,600
iniziamo pezzettino a pezzettino. Questa

252
00:11:03,600 --> 00:11:05,600
trasformazione

253
00:11:05,600 --> 00:11:09,519
dal problema di partenza al problema di

254
00:11:09,519 --> 00:11:14,000
arrivo si chiama riduzione. Ok? è la

255
00:11:14,000 --> 00:11:15,920
riduzione,

256
00:11:15,920 --> 00:11:17,959
poi dovrà avere delle proprietà, adesso

257
00:11:17,959 --> 00:11:20,399
vediamo, eccetera, però intuitivamente

258
00:11:20,399 --> 00:11:22,680
che significa ridurre un problema a un

259
00:11:22,680 --> 00:11:26,279
altro? Significa trasformare le istanze

260
00:11:26,279 --> 00:11:28,639
del problema di partenza, quindi di

261
00:11:28,639 --> 00:11:31,720
nuovo sottolineiamo una riduzione a un

262
00:11:31,720 --> 00:11:33,920
problema da cui partiamo e un problema a

263
00:11:33,920 --> 00:11:37,480
cui arriviamo. Ok? Quindi, obiettivo di

264
00:11:37,480 --> 00:11:41,839
una riduzione qual è? è trasformare le

265
00:11:41,839 --> 00:11:45,480
istanze del problema di partenza

266
00:11:45,480 --> 00:11:48,040
in istanze di un problema di arrivo,

267
00:11:48,040 --> 00:11:51,320
tale per cui una chiamata ha un solutore

268
00:11:51,320 --> 00:11:53,600
di un problema di arrivo ci dà una

269
00:11:53,600 --> 00:11:56,600
soluzione che noi possiamo riutilizzare

270
00:11:56,600 --> 00:11:59,399
per le istanze del problema di partenza.

271
00:11:59,399 --> 00:12:00,680
Ok?

272
00:12:00,680 --> 00:12:02,880
Se lo lo scriviamo, facciamo uno

273
00:12:02,880 --> 00:12:05,880
schemino.

274
00:12:06,279 --> 00:12:09,000
Quindi abbiamo

275
00:12:09,000 --> 00:12:13,279
un problema di partenza A, un problema

276
00:12:13,279 --> 00:12:16,760
di arrivo B.

277
00:12:16,760 --> 00:12:19,519
Quello che noi ci vogliamo inventare è

278
00:12:19,519 --> 00:12:22,680
partendo da un'istanza X di A.

279
00:12:22,680 --> 00:12:24,399
Peristanza sappiamo che è un input,

280
00:12:24,399 --> 00:12:28,079
però, ok, una stringa, quello che è.

281
00:12:28,079 --> 00:12:31,240
Vogliamo trasformarla

282
00:12:31,240 --> 00:12:34,240
in uno in un'istanza y che si ottiene

283
00:12:34,240 --> 00:12:36,560
tramite l'applicazione di una funzione

284
00:12:36,560 --> 00:12:38,839
f(x),

285
00:12:38,839 --> 00:12:41,920
tale per cui

286
00:12:41,920 --> 00:12:44,440
possiamo ottenere una soluzione partendo

287
00:12:44,440 --> 00:12:48,680
da y e ritrasformandola indietro

288
00:12:48,680 --> 00:12:51,360
possiamo ottenere una soluzione per x.

289
00:12:51,360 --> 00:12:53,839
Ok? E questo è il giro che facciamo. No,

290
00:12:53,839 --> 00:12:56,959
adesso per voi che avete programmato è

291
00:12:56,959 --> 00:12:59,079
molto chiaro come stiamo facendo. Questo

292
00:12:59,079 --> 00:13:02,320
è un pezzettino di codice tale per cui

293
00:13:02,320 --> 00:13:06,920
vogliamo scrivere un solver per A

294
00:13:06,920 --> 00:13:13,199
e prende X che è un'istanza di A.

295
00:13:14,760 --> 00:13:19,880
Ok? Come funziona? Facciamo così,

296
00:13:19,880 --> 00:13:22,920
ci generiamo y è

297
00:13:22,920 --> 00:13:25,880
fx.

298
00:13:25,880 --> 00:13:29,839
Dopodiché prendiamo la soluzione y che

299
00:13:29,839 --> 00:13:32,519
si ottiene facendo solve

300
00:13:32,519 --> 00:13:35,600
di b

301
00:13:35,600 --> 00:13:38,320
e poi

302
00:13:38,320 --> 00:13:42,199
otteniamo otteniamo S con X che è uguale

303
00:13:42,199 --> 00:13:43,760
a

304
00:13:43,760 --> 00:13:47,040
chiamiamola così g

305
00:13:47,040 --> 00:13:49,600
s Y

306
00:13:49,600 --> 00:13:52,600
[Musica]

307
00:13:52,600 --> 00:13:55,920
dove G in qualche modo modo è legata

308
00:13:55,920 --> 00:13:58,320
all'inversa di f, non è proprio

309
00:13:58,320 --> 00:14:00,279
l'inversa perché stiamo trasformando

310
00:14:00,279 --> 00:14:02,120
soluzioni, non stiamo trasformando

311
00:14:02,120 --> 00:14:06,720
istanze e dopodiché facciamo return

312
00:14:06,720 --> 00:14:10,279
di sx. Ok? Cioè questo è quello che noi

313
00:14:10,279 --> 00:14:13,480
vogliamo fare. Vogliamo

314
00:14:13,480 --> 00:14:16,759
inventarci una funzione f tale che per

315
00:14:16,759 --> 00:14:19,320
cui questa soluzione, vedete voi se

316
00:14:19,320 --> 00:14:22,759
questa soluzione candidata qua ci torna,

317
00:14:22,759 --> 00:14:25,279
ok? Quindi questo pezzo di codice, il

318
00:14:25,279 --> 00:14:29,120
solvere per A, funziona quando? Quando

319
00:14:29,120 --> 00:14:32,079
questa f è sensata.

320
00:14:32,079 --> 00:14:35,000
È chiaro per tutti? Quindi vogliamo

321
00:14:35,000 --> 00:14:40,079
risolvere che cosa? Il problema A.

322
00:14:40,079 --> 00:14:42,880
Riceviamo in input una stringa per A, la

323
00:14:42,880 --> 00:14:45,560
trasformiamo in una stringa per B,

324
00:14:45,560 --> 00:14:48,079
chiamiamo come sabrutin un solutore per

325
00:14:48,079 --> 00:14:50,839
B. Otteniamo la soluzione. La soluzione

326
00:14:50,839 --> 00:14:53,279
la trasformiamo indietro.

327
00:14:53,279 --> 00:14:55,040
in maniera opportuna prendiamo sta

328
00:14:55,040 --> 00:14:58,199
soluzione e la restituiamo. Ok? Tutto

329
00:14:58,199 --> 00:15:04,639
ciò funziona se f make sense, ok? In

330
00:15:04,639 --> 00:15:08,440
tutta questa procedura f intuitivamente

331
00:15:08,440 --> 00:15:11,160
è la riduzione. Ok? Quindi la riduzione

332
00:15:11,160 --> 00:15:14,360
cos'è? è una trasformazione

333
00:15:14,360 --> 00:15:17,920
di stringhe verso stringhe in maniera

334
00:15:17,920 --> 00:15:20,480
tale che noi mappiamo istanze di un

335
00:15:20,480 --> 00:15:23,480
problema A su istanze di un problema B

336
00:15:23,480 --> 00:15:25,920
al punto tale che le soluzioni che

337
00:15:25,920 --> 00:15:28,160
otteniamo tramite un solutore per B

338
00:15:28,160 --> 00:15:31,040
possono essere riconvertite in soluzioni

339
00:15:31,040 --> 00:15:33,279
per l'estenza di partenza del problema

340
00:15:33,279 --> 00:15:36,040
per A. È chiaro? È chiaro? Quindi

341
00:15:36,040 --> 00:15:39,319
intuitivamente una riduzione che cos'è?

342
00:15:39,319 --> 00:15:43,199
Not che una riduzione è un verso

343
00:15:43,199 --> 00:15:46,680
che è questo qua. Vedete? In questa

344
00:15:46,680 --> 00:15:49,720
linea qui di codice risulta evidente che

345
00:15:49,720 --> 00:15:52,440
la riduzione è un verso. La funzione f

346
00:15:52,440 --> 00:15:55,639
prende istanze di A e sputa fuori

347
00:15:55,639 --> 00:15:58,360
istanze di B. Ok? Ecco perché parliamo

348
00:15:58,360 --> 00:16:00,240
di problema di partenza e problema di

349
00:16:00,240 --> 00:16:03,120
arrivo. Quindi, quando definiamo questa

350
00:16:03,120 --> 00:16:06,040
funzione qui che è la riduzione, noi

351
00:16:06,040 --> 00:16:08,000
dobbiamo stabilire qual è il suo input e

352
00:16:08,000 --> 00:16:11,360
qual è il suo output. Quindi che istanze

353
00:16:11,360 --> 00:16:12,880
di quale problema prende questa

354
00:16:12,880 --> 00:16:15,560
funzione, che istanze di quale problema

355
00:16:15,560 --> 00:16:19,120
sta restituendo questa funzione? Ok,

356
00:16:19,120 --> 00:16:25,160
chiaro per tutti lo scenario qua. Ok,

357
00:16:25,160 --> 00:16:28,120
facciamo l'esempino e poi formalizziamo

358
00:16:28,120 --> 00:16:30,240
un po' le cose. Ok, ritorniamo alla

359
00:16:30,240 --> 00:16:35,560
storiella. Quindi il nostro problema era

360
00:16:37,040 --> 00:16:39,240
che noi dovevamo risolvere il problema

361
00:16:39,240 --> 00:16:41,199
del calendario

362
00:16:41,199 --> 00:16:43,440
da un lato e dall'altro io sapevo

363
00:16:43,440 --> 00:16:46,600
risolvere la K colorabilità,

364
00:16:46,600 --> 00:16:49,240
cioè quindi mi serviva un algoritmo per

365
00:16:49,240 --> 00:16:51,440
il calendario,

366
00:16:51,440 --> 00:16:54,600
ci abbiamo provato per giorni e nulla di

367
00:16:54,600 --> 00:16:56,480
quello che provavamo funzionava.

368
00:16:56,480 --> 00:16:58,639
dall'altro lato avevo un algoritmo che

369
00:16:58,639 --> 00:17:00,680
era in grado di colorarmi grafici.

370
00:17:00,680 --> 00:17:03,079
Allora la mia idea è stata ma posso

371
00:17:03,079 --> 00:17:04,600
inventarmi

372
00:17:04,600 --> 00:17:09,480
una funzione f opportuna tale per cui io

373
00:17:09,480 --> 00:17:12,600
poi applico sta tecnica, cioè prendo le

374
00:17:12,600 --> 00:17:15,120
istanze del calendario, le trasformo in

375
00:17:15,120 --> 00:17:18,039
istanze di grafica colorare, faccio

376
00:17:18,039 --> 00:17:21,360
colorare il grafo al solutore del del

377
00:17:21,360 --> 00:17:24,319
Kcol, mi prendo la soluzione. Cos'è una

378
00:17:24,319 --> 00:17:26,559
soluzione? è un grafo colorato e da

379
00:17:26,559 --> 00:17:28,640
quella colorazione io mi tiro fuori qual

380
00:17:28,640 --> 00:17:31,400
è il calendario per il torneo. Ok?

381
00:17:31,400 --> 00:17:33,120
Questo è il principio, lo stiamo vedendo

382
00:17:33,120 --> 00:17:35,160
su questo esempio specifico proprio

383
00:17:35,160 --> 00:17:38,039
perché i due problemi sono molto diversi

384
00:17:38,039 --> 00:17:41,080
e viene più semplice capire partiamo da

385
00:17:41,080 --> 00:17:43,720
qui, arriviamo qui perché uno degli

386
00:17:43,720 --> 00:17:46,640
errori più comuni che si fanno quando si

387
00:17:46,640 --> 00:17:49,200
fanno le ritenzioni è non individuare

388
00:17:49,200 --> 00:17:50,679
correttamente chi è il problema di

389
00:17:50,679 --> 00:17:52,520
partenza e qual è il problema di arrivo.

390
00:17:52,520 --> 00:17:54,559
Ok? Quindi ora lo facciamo in questo

391
00:17:54,559 --> 00:17:58,600
modo che è molto distinto e così ce ne

392
00:17:58,600 --> 00:18:02,720
rendiamo conto. Ok?

393
00:18:04,240 --> 00:18:08,240
Poi definizione bla poi sì, ce la

394
00:18:08,240 --> 00:18:11,760
potremmo fare. Ok,

395
00:18:11,760 --> 00:18:14,200
supponiamo, ok? Supponiamo che abbiamo

396
00:18:14,200 --> 00:18:18,080
questo esempio specifico, ok?

397
00:18:18,080 --> 00:18:20,440
quattro squadre, Juventus, Milan,

398
00:18:20,440 --> 00:18:25,120
Bologna, Roma e noi vogliamo generare

399
00:18:25,120 --> 00:18:27,840
un torneo, il calendario di un torneo

400
00:18:27,840 --> 00:18:29,960
all'italiana, cioè che tutti giocano

401
00:18:29,960 --> 00:18:32,000
contro tutti. Ok? e facciamo solo il

402
00:18:32,000 --> 00:18:34,039
girone di andata perché poi il girone di

403
00:18:34,039 --> 00:18:37,400
ritorno è la stessa cosa. Quindi il

404
00:18:37,400 --> 00:18:39,760
nostro obiettivo è generare tutte le

405
00:18:39,760 --> 00:18:42,360
coppie possibili

406
00:18:42,360 --> 00:18:45,280
di queste squadre che sono le partite

407
00:18:45,280 --> 00:18:48,400
possibile e partizionare.

408
00:18:48,400 --> 00:18:50,360
Questa è sostanzialmente la generazione

409
00:18:50,360 --> 00:18:52,799
del torneo. Generiamo tutte le coppie

410
00:18:52,799 --> 00:18:56,120
possibili che quindi che cosa sono?

411
00:18:56,120 --> 00:18:58,679
Juventus- Milan, Juventus-Bologna,

412
00:18:58,679 --> 00:19:02,520
Juventus Roma, Milan, Bologna, Milan-

413
00:19:02,520 --> 00:19:07,320
Roma, Bologna Roma. Ok? Dopodiché l'idea

414
00:19:07,320 --> 00:19:10,480
è partizionare

415
00:19:10,480 --> 00:19:14,120
questo insieme in sottoinsiemi che ci

416
00:19:14,120 --> 00:19:16,200
dicono quali sono le partite che vanno

417
00:19:16,200 --> 00:19:18,840
giocate nella stessa giornata. Ok?

418
00:19:18,840 --> 00:19:21,159
Questa è la cosa. Quindi, come vi

419
00:19:21,159 --> 00:19:24,159
dicevo, questa roba a noi ci dava un po'

420
00:19:24,159 --> 00:19:28,440
di problemi. Ok?

421
00:19:31,440 --> 00:19:36,000
Allora, l'idea fu questa qua.

422
00:19:36,120 --> 00:19:37,919
Ragazzionai un po' così, ha detto "Ok,

423
00:19:37,919 --> 00:19:40,840
io mi devo partizionare con l'insieme di

424
00:19:40,840 --> 00:19:43,240
partite", no?

425
00:19:43,240 --> 00:19:46,080
E quello che so

426
00:19:46,080 --> 00:19:47,960
qua si lavora molto creativi e molto

427
00:19:47,960 --> 00:19:50,200
sostili. Quindi da un lato abbiamo la

428
00:19:50,200 --> 00:19:52,720
generazione del calendario in cui

429
00:19:52,720 --> 00:19:55,880
generiamo tutte le possibili coppie e

430
00:19:55,880 --> 00:19:58,120
questo insieme va partizionato in

431
00:19:58,120 --> 00:20:02,000
sottoinsiemi tale per cui una squadra

432
00:20:02,000 --> 00:20:05,360
non giochi più di una partita in uno di

433
00:20:05,360 --> 00:20:08,480
queste partizioni. Ok? Quindi da un lato

434
00:20:08,480 --> 00:20:11,919
mi devo fare gruppi.

435
00:20:11,919 --> 00:20:14,440
State attenti alle parole che usore, eh.

436
00:20:14,440 --> 00:20:17,520
Da un lato mi devo fare una serie di

437
00:20:17,520 --> 00:20:19,039
insiemi

438
00:20:19,039 --> 00:20:22,679
tale per cui le partite al proprio

439
00:20:22,679 --> 00:20:26,000
interno siano compatibili.

440
00:20:26,000 --> 00:20:28,240
Ok? Questo è quello che vogliamo

441
00:20:28,240 --> 00:20:29,919
ottenare per la generazione del

442
00:20:29,919 --> 00:20:32,000
calendario.

443
00:20:32,000 --> 00:20:35,919
Lato problema del calendario.

444
00:20:35,919 --> 00:20:38,440
Lato problema della colorazione di un

445
00:20:38,440 --> 00:20:41,559
grafo. Ok? Quindi noi ci andiamo per

446
00:20:41,559 --> 00:20:42,799
riuscire a capire perché il nostro

447
00:20:42,799 --> 00:20:44,640
obiettivo è inventarci con la funzione

448
00:20:44,640 --> 00:20:48,240
f, ok? Per riuscire a capire come f, per

449
00:20:48,240 --> 00:20:50,760
riuscire a inventarci f, eh, perché ce

450
00:20:50,760 --> 00:20:52,520
ne stanno tante, però per riuscircene a

451
00:20:52,520 --> 00:20:55,520
inventare una, come faccio io? Mi guardo

452
00:20:55,520 --> 00:20:58,120
le istanze del problema di partenza, le

453
00:20:58,120 --> 00:21:00,559
istanze del problema di arrivo, come

454
00:21:00,559 --> 00:21:02,600
sono fatte le soluzioni del problema di

455
00:21:02,600 --> 00:21:04,760
partenza, come sono fatte le soluzioni

456
00:21:04,760 --> 00:21:07,000
del problema di arrivo e cerco di capire

457
00:21:07,000 --> 00:21:09,280
se ci sta un mapping del problema di

458
00:21:09,280 --> 00:21:12,120
partenza sul problema di arrivo. E

459
00:21:12,120 --> 00:21:13,760
allora io vado proprio a guardare la

460
00:21:13,760 --> 00:21:16,600
struttura delle soluzioni, ok? Quindi

461
00:21:16,600 --> 00:21:18,360
cos'è una soluzione del problema del

462
00:21:18,360 --> 00:21:20,279
calendario? La soluzione, il problema

463
00:21:20,279 --> 00:21:22,919
del calendario è una partizione di

464
00:21:22,919 --> 00:21:25,880
quell'insi insieme di elementi tale per

465
00:21:25,880 --> 00:21:29,720
cui in ogni singola sottoinsieme, in

466
00:21:29,720 --> 00:21:32,919
ogni singola parte di questa partizione

467
00:21:32,919 --> 00:21:35,799
non accade che ci sono due partite

468
00:21:35,799 --> 00:21:37,320
incompatibili e due partite sono

469
00:21:37,320 --> 00:21:39,960
incompatibili se hanno una squadra in

470
00:21:39,960 --> 00:21:43,720
comune. Ok? È chiaro? Chiaro per tutti?

471
00:21:43,720 --> 00:21:46,120
Dall'altro lato che abbiamo il problema

472
00:21:46,120 --> 00:21:49,000
di colorare un grafo.

473
00:21:49,000 --> 00:21:51,799
Quindi abbiamo un grafo con i suoi nodi

474
00:21:51,799 --> 00:21:54,400
e i suoi archi e abbiamo un certo numero

475
00:21:54,400 --> 00:21:58,480
di colori. Ok?

476
00:21:58,919 --> 00:22:01,840
Cos'è una soluzione per il problema

477
00:22:01,840 --> 00:22:04,279
della colorabilità?

478
00:22:04,279 --> 00:22:06,960
è un assegnamento

479
00:22:06,960 --> 00:22:08,880
di colori

480
00:22:08,880 --> 00:22:12,039
ai nodi

481
00:22:12,039 --> 00:22:14,640
tale per cui

482
00:22:14,640 --> 00:22:18,559
non accade che cosa? Che i due nodi

483
00:22:18,559 --> 00:22:22,919
agganciati abbiano lo stesso colore. Ok?

484
00:22:22,919 --> 00:22:25,559
Quindi queste sono le soluzioni.

485
00:22:25,559 --> 00:22:27,480
Adesso giochiamo un pochino sulla

486
00:22:27,480 --> 00:22:29,880
struttura delle soluzioni perché

487
00:22:29,880 --> 00:22:31,960
cerchiamo di vedere se troviamo delle

488
00:22:31,960 --> 00:22:34,240
similitudini perché trovato quello la

489
00:22:34,240 --> 00:22:37,120
riduzione si fa. Eh,

490
00:22:37,120 --> 00:22:41,720
quindi da un lato dobbiamo generare

491
00:22:41,720 --> 00:22:45,840
insiemi di partite compatibili.

492
00:22:45,840 --> 00:22:50,000
Dall'altro dobbiamo generare colorazioni

493
00:22:50,000 --> 00:22:52,360
sensate.

494
00:22:52,360 --> 00:22:56,480
Da un lato abbiamo che le partite

495
00:22:56,480 --> 00:22:59,200
che finiscono nella stessa giornata non

496
00:22:59,200 --> 00:23:01,600
devono collidere.

497
00:23:01,600 --> 00:23:04,000
State attenti ora al passaggio.

498
00:23:04,000 --> 00:23:07,240
Dall'altro lato che cosa abbiamo?

499
00:23:07,240 --> 00:23:10,320
Dobbiamo avere una colorazione

500
00:23:10,320 --> 00:23:15,000
tale per cui nodi con lo stesso colore

501
00:23:15,000 --> 00:23:17,279
che proprietà hanno?

502
00:23:17,279 --> 00:23:19,520
Non sono agganciati.

503
00:23:19,520 --> 00:23:23,600
Quindi da un lato ci servono set di

504
00:23:23,600 --> 00:23:26,320
partite compatibili.

505
00:23:26,320 --> 00:23:30,279
Dall'altro vogliamo che col che nodi

506
00:23:30,279 --> 00:23:33,200
colorati allo stesso modo non siano

507
00:23:33,200 --> 00:23:37,279
collegati. Ok? Prendetevi una trentina

508
00:23:37,279 --> 00:23:39,840
di secondi per pensare come sfruttiamo

509
00:23:39,840 --> 00:23:43,039
sta faccenda.

510
00:23:52,760 --> 00:23:56,000
Sì,
io collegherei

511
00:23:56,000 --> 00:23:59,640
i nodi a distanza uno con le partite

512
00:23:59,640 --> 00:24:04,679
incompatibili. Ah
eh in modo tale che

513
00:24:04,679 --> 00:24:07,640
eh così cioè di conseguenza vengono

514
00:24:07,640 --> 00:24:09,640
colorate con diverse partite

515
00:24:09,640 --> 00:24:12,240
compatibili.
Esattamente. Questo era il

516
00:24:12,240 --> 00:24:14,720
trucco che mi sono inventato.

517
00:24:14,720 --> 00:24:16,559
Ok io non riesco a generare sto

518
00:24:16,559 --> 00:24:18,200
calendario, però un algoritmo che mi

519
00:24:18,200 --> 00:24:20,679
colora gratis. Come lo scrutto? In quel

520
00:24:20,679 --> 00:24:24,480
modo. Vediamo l'esempio e e poi

521
00:24:24,480 --> 00:24:27,120
iniziamo a formalizzare la nozione di

522
00:24:27,120 --> 00:24:29,720
riduzione. Ok?

523
00:24:29,720 --> 00:24:31,720
Quindi

524
00:24:31,720 --> 00:24:34,720
partito.

525
00:24:36,840 --> 00:24:40,120
Dov'è? Non ciamo tutto.

526
00:24:40,120 --> 00:24:43,120
Ok.

527
00:24:45,520 --> 00:24:47,520
Quindi, che cos'è un'istanza del

528
00:24:47,520 --> 00:24:50,039
problema del calendario?

529
00:24:50,039 --> 00:24:53,799
È un insieme e una lista di squadre. Che

530
00:24:53,799 --> 00:24:56,720
cos'è un'istanza del problema della

531
00:24:56,720 --> 00:25:00,520
Kollorabilità? è una coppia grafo

532
00:25:00,520 --> 00:25:02,240
K, che è il numero di colori che

533
00:25:02,240 --> 00:25:03,919
vogliamo usare per colorare il nostro

534
00:25:03,919 --> 00:25:07,320
grafo. Ok?

535
00:25:07,320 --> 00:25:09,520
Ci dobbiamo inventare questa funzione

536
00:25:09,520 --> 00:25:12,520
fasti

537
00:25:12,840 --> 00:25:15,600
una lista di partite

538
00:25:15,600 --> 00:25:19,360
in una coppia grafo colore. Ok? Questa è

539
00:25:19,360 --> 00:25:23,039
F. f una funzione stramba

540
00:25:23,039 --> 00:25:26,200
che prende in input

541
00:25:26,200 --> 00:25:29,880
una lista di squadre

542
00:25:29,880 --> 00:25:33,559
e tira fuori una coppia grafo numero di

543
00:25:33,559 --> 00:25:37,159
colori in maniera tale che quando

544
00:25:37,159 --> 00:25:41,200
coloriamo questo grafo specifico

545
00:25:41,200 --> 00:25:43,960
e con quel numero di colori specifico

546
00:25:43,960 --> 00:25:46,480
noi possiamo riconvertire all'indietro

547
00:25:46,480 --> 00:25:48,640
la soluzione per tirarci fuori il

548
00:25:48,640 --> 00:25:52,399
candal. Ok? Allora, l'idea è questa.

549
00:25:52,399 --> 00:25:55,880
Questo è l'input di f e questo è

550
00:25:55,880 --> 00:25:57,559
l'output

551
00:25:57,559 --> 00:26:01,760
f. Quindi questo va qua dentro e questa

552
00:26:01,760 --> 00:26:05,320
è l'uscita. Ok? Quindi in input f

553
00:26:05,320 --> 00:26:08,799
abbiamo una lista di squadre. In uscita

554
00:26:08,799 --> 00:26:11,760
di f ci sta un grafo e un numero di

555
00:26:11,760 --> 00:26:14,200
colori. Un grafo è fatto di nodi e

556
00:26:14,200 --> 00:26:20,159
vertice. Ok? Come funziona f?

557
00:26:20,159 --> 00:26:26,000
F prende in input la lista delle squadre

558
00:26:26,000 --> 00:26:31,480
e genera un grafo con tanti nodi quanti

559
00:26:31,480 --> 00:26:35,240
sono tutte le possibili partite. Ok?

560
00:26:35,240 --> 00:26:39,640
Quindi f prende in input questa lista

561
00:26:39,640 --> 00:26:44,760
qui, inizia a costruire un grafo

562
00:26:44,760 --> 00:26:48,440
che è fatto di noi in vertici in Sì.

563
00:26:48,440 --> 00:26:50,720
vertici anche

564
00:26:50,720 --> 00:26:53,720
i vertici di questo grafo tutte le

565
00:26:53,720 --> 00:26:56,240
possibili coppie di squadre che

566
00:26:56,240 --> 00:26:58,200
sostanzialmente per noi sarebbero le

567
00:26:58,200 --> 00:27:01,240
partite. Quindi F che inizia a fare

568
00:27:01,240 --> 00:27:04,240
Juventus, Milan,

569
00:27:04,240 --> 00:27:07,720
Juventus, Bologna,

570
00:27:07,720 --> 00:27:10,840
Juventus, Roma,

571
00:27:10,840 --> 00:27:14,360
Milan, Bologna,

572
00:27:14,360 --> 00:27:16,440
Milan, Roma,

573
00:27:16,440 --> 00:27:20,320
Bologna Roma. Ok? Cioè f ha preso in

574
00:27:20,320 --> 00:27:23,360
input una lista di squadre, sta sputando

575
00:27:23,360 --> 00:27:27,159
fuori vertici. Che vertici sputa? Sputa

576
00:27:27,159 --> 00:27:29,720
fuori un vertice per ognuna delle

577
00:27:29,720 --> 00:27:32,799
possibili partite. Ok? E ci mettiamo

578
00:27:32,799 --> 00:27:35,679
questa etichetta sopra in maniera tale

579
00:27:35,679 --> 00:27:37,799
che sappiamo quel vertice a quale

580
00:27:37,799 --> 00:27:40,640
partita il mio di principio è collegato.

581
00:27:40,640 --> 00:27:43,240
Va bene? Chiaro?

582
00:27:43,240 --> 00:27:45,120
Un grafo di cosa è fatto? di vertici

583
00:27:45,120 --> 00:27:47,440
archi.

584
00:27:47,440 --> 00:27:51,840
Siccome noi vogliamo ottenere un grafo

585
00:27:51,840 --> 00:27:55,320
la cui colorazione ci dirà quale partite

586
00:27:55,320 --> 00:27:58,480
possono essere giocate assieme e partite

587
00:27:58,480 --> 00:28:01,000
che non possono essere giocate assieme

588
00:28:01,000 --> 00:28:02,840
sono le partite che hanno una squadra in

589
00:28:02,840 --> 00:28:04,919
comune da un lato e dall'altro lato i

590
00:28:04,919 --> 00:28:06,799
nodi che non possono avere lo stesso

591
00:28:06,799 --> 00:28:10,039
colore sono i nodi collegati da un arco.

592
00:28:10,039 --> 00:28:15,200
La funzione f? Collega con un arco tutti

593
00:28:15,200 --> 00:28:20,320
i nodi relativi a partite incompatibile.

594
00:28:20,320 --> 00:28:23,720
Chiaro? Quindi F che fa? dopo che ha

595
00:28:23,720 --> 00:28:26,159
generato questi sei nodi, inizia a

596
00:28:26,159 --> 00:28:29,519
collegarlo questo con questo, questo con

597
00:28:29,519 --> 00:28:32,720
questo, questo con questo.

598
00:28:32,720 --> 00:28:35,240
Milan, Bologna, Bologna, Bologna,

599
00:28:35,240 --> 00:28:39,760
Bologna, Roma, Roma, Milan, Milan,

600
00:28:39,760 --> 00:28:42,039
Roma Roma

601
00:28:42,039 --> 00:28:46,679
Roma Roma sta qua. Milan, Milan sta qua.

602
00:28:46,679 --> 00:28:50,080
Bologna Bologna così e Milan Milan è

603
00:28:50,080 --> 00:28:54,120
questo. Ok, è chiaro?

604
00:28:54,120 --> 00:28:58,000
Quindi questa funzione fzione di

605
00:28:58,000 --> 00:29:00,840
riduzione, guardate, eh dobbiamo essere

606
00:29:00,840 --> 00:29:05,320
precisi, che prende come input

607
00:29:05,480 --> 00:29:07,720
una lista di squadre, ok? Che è

608
00:29:07,720 --> 00:29:10,640
l'istanza del problema di partenza. Cosa

609
00:29:10,640 --> 00:29:14,679
deve sputare in output? Un grafo. E un

610
00:29:14,679 --> 00:29:16,039
numero. Il numero ancora non l'abbiamo

611
00:29:16,039 --> 00:29:18,440
visto. Ok? deve sputare fuori un grafo.

612
00:29:18,440 --> 00:29:20,559
Quindi F partendo da una lista di

613
00:29:20,559 --> 00:29:22,080
squadre

614
00:29:22,080 --> 00:29:26,279
tira fuori che cosa? Tira fuori un

615
00:29:26,279 --> 00:29:27,960
grafo.

616
00:29:27,960 --> 00:29:32,240
Un grafo che ha tanti nodi quante sono

617
00:29:32,240 --> 00:29:35,039
tutte le possibili partite.

618
00:29:35,039 --> 00:29:39,320
E i vertici di questo grafo, no? vertici

619
00:29:39,320 --> 00:29:44,240
gli archi di questo grafo collegano nodi

620
00:29:44,240 --> 00:29:46,679
relative a relativi a partite

621
00:29:46,679 --> 00:29:49,720
incompatibili, ok? Cioè, quindi F questo

622
00:29:49,720 --> 00:29:52,640
fa sputa nodi, sputa archi e li assembla

623
00:29:52,640 --> 00:29:55,760
così. Ok?

624
00:29:55,760 --> 00:30:00,760
Siccome l'idea era che

625
00:30:00,760 --> 00:30:06,159
i nodi colorati con un certo colore sono

626
00:30:06,159 --> 00:30:09,120
le partite che vanno a finire in quella

627
00:30:09,120 --> 00:30:12,240
in quella giornata, dobbiamo avere tanti

628
00:30:12,240 --> 00:30:14,559
colori quante sono le possibili

629
00:30:14,559 --> 00:30:17,600
giornate. Adesso in un campionato di

630
00:30:17,600 --> 00:30:20,320
quattro squadre quante giornate ci

631
00:30:20,320 --> 00:30:23,120
stanno?

632
00:30:23,120 --> 00:30:26,120
Tre. Perché ognuno deve giocare con

633
00:30:26,120 --> 00:30:28,240
qualcun altro, quindi ogni squadra,

634
00:30:28,240 --> 00:30:29,960
ognuna di queste quattro squadre deve

635
00:30:29,960 --> 00:30:32,240
fare tre partite contro le rimanenti

636
00:30:32,240 --> 00:30:36,919
tre. Ok? Quindi questa funzione fera

637
00:30:36,919 --> 00:30:40,519
fuori questa coppia grafo così è il

638
00:30:40,519 --> 00:30:44,760
numero 3. Ok?

639
00:30:46,640 --> 00:30:48,360
È chiaro?

640
00:30:48,360 --> 00:30:50,200
Quindi dobbiamo essere su questo

641
00:30:50,200 --> 00:30:52,080
preciso.

642
00:30:52,080 --> 00:30:54,960
F cosa ha preso in input?

643
00:30:54,960 --> 00:30:57,720
Una lista di squadre. Perché? Perché una

644
00:30:57,720 --> 00:31:00,159
lista di squadre è l'istanza del

645
00:31:00,159 --> 00:31:02,519
problema di partenza.

646
00:31:02,519 --> 00:31:06,399
Cosa spuda fuori in output? Una coppia.

647
00:31:06,399 --> 00:31:10,600
Grafo colori, numero di colori. Perché?

648
00:31:10,600 --> 00:31:13,080
Perché la coppia, grafo, numero di

649
00:31:13,080 --> 00:31:15,480
colori è l'istanza del problema di

650
00:31:15,480 --> 00:31:18,200
arrivo.

651
00:31:18,200 --> 00:31:21,440
Come la sputa fuori questo grafo, questo

652
00:31:21,440 --> 00:31:23,960
e questo numero di colori f la butta

653
00:31:23,960 --> 00:31:27,519
fuori a caso? potrebbe, però in realtà a

654
00:31:27,519 --> 00:31:30,880
noi serve una f tale per cui il grafo

655
00:31:30,880 --> 00:31:34,120
che lui che costruisce ci torna utile

656
00:31:34,120 --> 00:31:36,440
per risolvere il problema di partenza,

657
00:31:36,440 --> 00:31:38,240
perché se non c'è alcun tipo di

658
00:31:38,240 --> 00:31:40,600
correlazione non ce ne facciamo niente,

659
00:31:40,600 --> 00:31:43,279
ok? Quindi il grafo generato dalla

660
00:31:43,279 --> 00:31:46,279
funzione f deve essere un grafo tale per

661
00:31:46,279 --> 00:31:48,440
cui una volta colorato quella

662
00:31:48,440 --> 00:31:51,480
colorazione noi la usiamo per generare

663
00:31:51,480 --> 00:31:54,200
il calendario. Se il grafo sfrutato

664
00:31:54,200 --> 00:31:57,919
fuori da f è un grafo a caso, non ce ne

665
00:31:57,919 --> 00:32:00,159
facciamo niente, ok? Quindi f deve

666
00:32:00,159 --> 00:32:03,840
essere progettata in maniera funzionale.

667
00:32:03,840 --> 00:32:06,840
Ok?

668
00:32:07,399 --> 00:32:11,480
Chiaro? Fin qua? Alr? Quindi cosa

669
00:32:11,480 --> 00:32:14,279
abbiamo fatto? Questa è lo scenario in

670
00:32:14,279 --> 00:32:17,440
cui siamo. Vogliamo un solver per il

671
00:32:17,440 --> 00:32:20,320
problema del calendario. Prendiamo in

672
00:32:20,320 --> 00:32:25,679
input che cosa? Una lista di squadre.

673
00:32:25,679 --> 00:32:30,240
Noi ci siamo inventati questa funzione f

674
00:32:30,240 --> 00:32:33,720
in input una lista di squadre sputa

675
00:32:33,720 --> 00:32:36,799
fuori y una coppia grafo numero di

676
00:32:36,799 --> 00:32:41,480
colore, ok? Dopodiché questa cosa qua lo

677
00:32:41,480 --> 00:32:45,120
facciamo risolvere a un solutore per B.

678
00:32:45,120 --> 00:32:47,440
Quindi il solver per B che cos'è? È un

679
00:32:47,440 --> 00:32:51,559
algoritmo che colora grafici.

680
00:32:51,559 --> 00:32:55,480
La colorazione ottenuta la trasformeremo

681
00:32:55,480 --> 00:32:57,880
al contrario per ottenere il calendario

682
00:32:57,880 --> 00:33:01,159
della partita. Ok? Adesso guardate.

683
00:33:01,159 --> 00:33:04,039
Quindi la funzione fatto?

684
00:33:04,039 --> 00:33:08,320
ha preso questa lista, ha tirato fuori

685
00:33:08,320 --> 00:33:10,760
questa coppia,

686
00:33:10,760 --> 00:33:14,919
c'è il passaggio della colorazione, ok?

687
00:33:14,919 --> 00:33:17,760
La colorazione di questo grafo. Quindi

688
00:33:17,760 --> 00:33:20,000
diamo questo grafo e questo numero di

689
00:33:20,000 --> 00:33:22,360
colori a un sold diciamo, senti qua,

690
00:33:22,360 --> 00:33:24,600
abbiamo questo grafo fatto in questo

691
00:33:24,600 --> 00:33:27,600
modo e c'abbiamo tre colori. Me lo

692
00:33:27,600 --> 00:33:31,399
colori? Ok? Noi non sappiamo come fa',

693
00:33:31,399 --> 00:33:36,240
ma lo fanno. Ok? Mettiamoci qualcosa.

694
00:33:36,240 --> 00:33:41,600
Eh, questo qua. Ok.

695
00:33:41,919 --> 00:33:43,519
Alright.

696
00:33:43,519 --> 00:33:46,200
Quindi con tre colori come possiamo

697
00:33:46,200 --> 00:33:49,760
farlo? Per esempio, possiamo fare questo

698
00:33:49,760 --> 00:33:52,760
verde,

699
00:33:53,200 --> 00:33:56,679
questo blu perché è agganciato e quindi

700
00:33:56,679 --> 00:34:00,240
non possiamo usare lo stesso colore. Ok?

701
00:34:00,240 --> 00:34:03,840
Poi quest'altra qui deve avere un terzo

702
00:34:03,840 --> 00:34:05,840
colore ancora perché lui è agganciato

703
00:34:05,840 --> 00:34:08,000
sia a questo che a questo, quindi non

704
00:34:08,000 --> 00:34:10,520
può essere né verde né blu e lo facciamo

705
00:34:10,520 --> 00:34:12,960
rosso.

706
00:34:12,960 --> 00:34:15,480
Dov'è? Qua.

707
00:34:15,480 --> 00:34:20,359
Questo è rosso bello. Ma insomma. Ok, lo

708
00:34:20,359 --> 00:34:24,480
coloriamo di questo colore. Va bene.

709
00:34:24,480 --> 00:34:27,879
Si vede un cavo.

710
00:34:30,679 --> 00:34:34,919
Bravo così. Eh,

711
00:34:37,839 --> 00:34:40,639
ok, va bene.

712
00:34:40,639 --> 00:34:44,159
Dobbiamo colorare colorare gli altri.

713
00:34:44,159 --> 00:34:46,599
Focalizziamoci su Milan Bologna. Di che

714
00:34:46,599 --> 00:34:50,119
colore deve essere? Blu
blu perché è

715
00:34:50,119 --> 00:34:53,879
colorato a una

716
00:34:53,879 --> 00:34:55,399
Sì,

717
00:34:55,399 --> 00:34:58,599
è colorato a due nodi verdi e rossi,

718
00:34:58,599 --> 00:35:01,720
quindi questo deve essere blu.

719
00:35:01,720 --> 00:35:05,920
Focalizziamoci su Juventus Bologna. Di

720
00:35:05,920 --> 00:35:08,560
che colore deve essere?

721
00:35:08,560 --> 00:35:11,119
Rosso.

722
00:35:11,119 --> 00:35:13,359
Focalizziamoci su Bologna- Roma. Di che

723
00:35:13,359 --> 00:35:15,560
colore deve essere?

724
00:35:15,560 --> 00:35:18,000
Verde. Ok.

725
00:35:18,000 --> 00:35:19,560
Quindi,

726
00:35:19,560 --> 00:35:21,160
ricapitolando,

727
00:35:21,160 --> 00:35:23,680
la funzione f ha preso in mano una lista

728
00:35:23,680 --> 00:35:28,320
di squadre, ha sputato fuori ad arte

729
00:35:28,320 --> 00:35:31,640
ad arte un grafo e un numero di colori

730
00:35:31,640 --> 00:35:34,720
tale per cui una colorazione di quel

731
00:35:34,720 --> 00:35:38,160
grafo costruito d'arte può essere

732
00:35:38,160 --> 00:35:42,000
riutilizzato per generare il calendario.

733
00:35:42,000 --> 00:35:46,760
Ok? Quindi glielo diamo impasto al

734
00:35:46,760 --> 00:35:51,240
solver per B, quindi otteniamo Sy. Che

735
00:35:51,240 --> 00:35:54,760
cos'è? È questa colorazione. Ad esempio.

736
00:35:54,760 --> 00:35:57,920
Adesso da SY noi dobbiamo lavorarci

737
00:35:57,920 --> 00:36:01,000
sopra per ottenere il calendario. Ok?

738
00:36:01,000 --> 00:36:05,319
Secondo voi, qual è il calendario?

739
00:36:10,960 --> 00:36:13,040
Un colore, una giornata. un colore, una

740
00:36:13,040 --> 00:36:14,960
giornata. Quindi il calendario è

741
00:36:14,960 --> 00:36:20,920
Juventus, Milan e Bologna- Roma.

742
00:36:21,240 --> 00:36:27,000
L'altro è Juventus, Roma, Milan, Bologna

743
00:36:27,000 --> 00:36:30,640
e l'altro cos'è? È Milan, Roma,

744
00:36:30,640 --> 00:36:32,720
Juventus, Bologna e come vedete

745
00:36:32,720 --> 00:36:35,760
magicamente abbiamo il nostro calendario

746
00:36:35,760 --> 00:36:39,480
e non ci siamo proprio preoccupati

747
00:36:39,480 --> 00:36:42,200
dell'algoritmo che lo risolve, ok? Ci

748
00:36:42,200 --> 00:36:45,400
siamo chiesti, ma io sto problema lo

749
00:36:45,400 --> 00:36:47,920
posso trasformare in istanze, le istanze

750
00:36:47,920 --> 00:36:50,440
di questo problema lo posso trasformare

751
00:36:50,440 --> 00:36:53,040
in istanze di un altro problema e uso

752
00:36:53,040 --> 00:36:55,480
l'altro solutore.

753
00:36:55,480 --> 00:36:57,319
Ok?

754
00:36:57,319 --> 00:37:00,920
Adesso facciamo pausa. Eh,

755
00:37:00,920 --> 00:37:03,040
quindi

756
00:37:03,040 --> 00:37:04,720
ad alto livello, che cosa abbiamo

757
00:37:04,720 --> 00:37:06,160
imparato finora? Poi facciamo una

758
00:37:06,160 --> 00:37:10,400
considerazione e ci fermiamo. Ok?

759
00:37:10,400 --> 00:37:13,119
intuitivamente cos'è una riduzione?

760
00:37:13,119 --> 00:37:15,599
Intuitivamente una riduzione è una

761
00:37:15,599 --> 00:37:17,599
trasformazione

762
00:37:17,599 --> 00:37:23,480
di cosa? di istanze di un partenza in un

763
00:37:23,480 --> 00:37:26,359
problema di arrivo. Guys, qui è

764
00:37:26,359 --> 00:37:29,040
importante. C'è una direzione, c'è un

765
00:37:29,040 --> 00:37:31,160
problema da cui partiamo e un problema

766
00:37:31,160 --> 00:37:33,200
da cui arriviamo. Qui stiamo

767
00:37:33,200 --> 00:37:36,400
trasformando una lista di squadre in un

768
00:37:36,400 --> 00:37:38,760
grafo, non un grafo in una lista di

769
00:37:38,760 --> 00:37:41,920
squadre. È chiaro? So due trasformazioni

770
00:37:41,920 --> 00:37:44,599
diverse. Qual è il problema di partenza

771
00:37:44,599 --> 00:37:46,119
nella riduzione che abbiamo appena

772
00:37:46,119 --> 00:37:48,839
vista? è il calendario.

773
00:37:48,839 --> 00:37:52,640
Qual è il problema di arrivo nella eh

774
00:37:52,640 --> 00:37:54,640
riduzione che abbiamo appena visto? È la

775
00:37:54,640 --> 00:37:56,160
colorabilità.

776
00:37:56,160 --> 00:37:57,920
Stabilire chi è il problema di partenza,

777
00:37:57,920 --> 00:38:00,000
stabilire chi è il problema di arrivo ci

778
00:38:00,000 --> 00:38:02,839
permette di capire cos'è l'input della

779
00:38:02,839 --> 00:38:05,119
funzione f, cos'è l'output della

780
00:38:05,119 --> 00:38:07,920
funzione f. Ok? Questo a livello di

781
00:38:07,920 --> 00:38:09,640
struttura delle stringhe che deve

782
00:38:09,640 --> 00:38:12,240
gestire. Però la funzione f non è che la

783
00:38:12,240 --> 00:38:15,839
può mettare da buffo, deve essere

784
00:38:15,839 --> 00:38:18,240
disegnata, progettata in maniera tale

785
00:38:18,240 --> 00:38:21,280
che la trasformazione che f ci propone

786
00:38:21,280 --> 00:38:25,319
in output è tale per cui

787
00:38:25,319 --> 00:38:27,880
la soluzione dell'istanza del problema

788
00:38:27,880 --> 00:38:30,160
di arrivo può essere riconvertita

789
00:38:30,160 --> 00:38:31,880
agevolmente

790
00:38:31,880 --> 00:38:33,920
nella in una soluzione dell'istanza del

791
00:38:33,920 --> 00:38:36,319
problema di partenza. Adesso il fatto

792
00:38:36,319 --> 00:38:37,760
che noi riusciamo a generare il

793
00:38:37,760 --> 00:38:40,000
calendario in quel modo, in maniera così

794
00:38:40,000 --> 00:38:41,839
semplice, guardando la colorazione del

795
00:38:41,839 --> 00:38:43,960
grafo, è perché il grafo ha quella

796
00:38:43,960 --> 00:38:46,599
forma. Se noi c'era ci fossimo aumentati

797
00:38:46,599 --> 00:38:48,240
un altro grafo, magari non serviva

798
00:38:48,240 --> 00:38:51,680
niente, ok? Cioè, quindi la funzione f

799
00:38:51,680 --> 00:38:53,800
deve essere progettata in maniera tale

800
00:38:53,800 --> 00:38:55,920
che noi possiamo riutilizzare la

801
00:38:55,920 --> 00:38:57,760
soluzione, senò non ce ne facciamo

802
00:38:57,760 --> 00:39:01,040
nulla. Ok? Chiaro per tutti? Cos'è una

803
00:39:01,040 --> 00:39:03,359
riduzione? è una trasformazione di

804
00:39:03,359 --> 00:39:05,200
istanze

805
00:39:05,200 --> 00:39:08,200
svolta al fine di riutilizzare le

806
00:39:08,200 --> 00:39:11,839
risposte di un problema di destinazione.

807
00:39:11,839 --> 00:39:13,480
Ok?

808
00:39:13,480 --> 00:39:15,880
Quindi problema di partenza, problema di

809
00:39:15,880 --> 00:39:18,280
destinazione è importantissimo perché

810
00:39:18,280 --> 00:39:21,240
uno degli errori comuni invertire queste

811
00:39:21,240 --> 00:39:23,359
due cose, cioè fare la trasformazione al

812
00:39:23,359 --> 00:39:25,640
contrario. In quell'esempio, siccome

813
00:39:25,640 --> 00:39:28,640
volevamo risolvere calendario,

814
00:39:28,640 --> 00:39:30,520
sono le istanze di calendario che vanno

815
00:39:30,520 --> 00:39:32,160
trasformate, non le istanze della

816
00:39:32,160 --> 00:39:35,440
Korabilità. Ok?

817
00:39:35,440 --> 00:39:38,720
Ultima cosa,

818
00:39:38,720 --> 00:39:43,599
se siamo in grado di trasformare, quindi

819
00:39:43,599 --> 00:39:46,000
di ridurre,

820
00:39:46,000 --> 00:39:50,000
quando usiamo la parola ridurre è una

821
00:39:50,000 --> 00:39:51,800
porting in italiano di una parola in

822
00:39:51,800 --> 00:39:54,000
inglese che è reduction, però voi

823
00:39:54,000 --> 00:39:56,880
pensate alla che è trasformare. Ok? Cosa

824
00:39:56,880 --> 00:39:59,079
significa ridurre? Significa trasformare

825
00:39:59,079 --> 00:40:00,800
istanze di un problema in istanze di un

826
00:40:00,800 --> 00:40:03,520
altro problema. Quando noi siamo in

827
00:40:03,520 --> 00:40:07,319
grado di ridurre

828
00:40:07,319 --> 00:40:09,400
un problema

829
00:40:09,400 --> 00:40:12,640
di partenza a un problema di arrivo, in

830
00:40:12,640 --> 00:40:15,359
questo caso il problema calendario al

831
00:40:15,359 --> 00:40:18,240
problema della K colorabilità lo

832
00:40:18,240 --> 00:40:23,040
indichiamo con questo simbolo

833
00:40:26,839 --> 00:40:30,280
minore o uguale. Ok? Questo è il simbolo

834
00:40:30,280 --> 00:40:33,040
della riduzione. Quindi, se un problema

835
00:40:33,040 --> 00:40:39,000
A si riduce a un problema B, noi a

836
00:40:39,000 --> 00:40:44,160
simboli scriviamo A ug b. Una domanda

837
00:40:44,160 --> 00:40:47,400
per voi e poi ci fermiamo. Quindi noi

838
00:40:47,400 --> 00:40:49,839
abbiamo trasformato un problema di

839
00:40:49,839 --> 00:40:53,119
partenza, ma si vede? un problema di

840
00:40:53,119 --> 00:40:57,200
partenza in un problema di arrivo. Ok,

841
00:40:57,200 --> 00:40:59,359
chiaro?

842
00:40:59,359 --> 00:41:03,079
Che possiamo dire

843
00:41:03,079 --> 00:41:07,160
della relativa difficoltà di questi due

844
00:41:07,160 --> 00:41:10,160
problemi?

845
00:41:12,680 --> 00:41:14,480
Sì,
dipende dalla complessità della

846
00:41:14,480 --> 00:41:16,480
funzione di trasformazione.

847
00:41:16,480 --> 00:41:18,000
Assumiamo che la funzione di

848
00:41:18,000 --> 00:41:20,880
trasformazione siamo nel reame del

849
00:41:20,880 --> 00:41:23,640
supponiamo che sia facile, ok? Poi poi

850
00:41:23,640 --> 00:41:26,880
dovremmo essere molto molto

851
00:41:26,880 --> 00:41:29,400
specifici su quello, però supponiamo che

852
00:41:29,400 --> 00:41:31,599
f sia una cosa facile o comunque

853
00:41:31,599 --> 00:41:35,800
calcolabile. Cosa possiamo dire? Ok, mi

854
00:41:35,800 --> 00:41:37,800
faccio meglio la domanda. Cosa possiamo

855
00:41:37,800 --> 00:41:42,680
dire relativamente alla decidibilità dei

856
00:41:42,680 --> 00:41:45,920
due problemi?

857
00:41:47,599 --> 00:41:50,359
Sì,
se è decidibile uno è decidibile la

858
00:41:50,359 --> 00:41:52,720
l'uno chiolismo.

859
00:41:52,720 --> 00:41:54,839
Se è decidibile il problema B, allora

860
00:41:54,839 --> 00:41:57,040
anche il problema A sarà decis.
Sì.

861
00:41:57,040 --> 00:41:59,560
Allora, l'intuizione è questa. Adesso

862
00:41:59,560 --> 00:42:01,280
vedremo formalmente tutte le cose dopo

863
00:42:01,280 --> 00:42:06,200
la pausa. Se noi riduciamo il problema A

864
00:42:06,200 --> 00:42:09,240
B e B è decidibile,

865
00:42:09,240 --> 00:42:12,400
allora lo è anche A.

866
00:42:12,400 --> 00:42:14,440
Perché una procedura per risolvere A

867
00:42:14,440 --> 00:42:15,480
qual è?

868
00:42:15,480 --> 00:42:18,000
trasformare
trasformare le stanze, usare

869
00:42:18,000 --> 00:42:20,240
il solutore per B che è decidibile e

870
00:42:20,240 --> 00:42:22,200
così abbiamo le soluzioni per A e questa

871
00:42:22,200 --> 00:42:24,920
è una procedura per risolvere A. E se A

872
00:42:24,920 --> 00:42:28,160
è indecidibile

873
00:42:31,839 --> 00:42:35,720
possiamo dire
mh che possiamo dire di B?

874
00:42:35,720 --> 00:42:37,800
Anche B è indeccibile.
Anche B è

875
00:42:37,800 --> 00:42:39,760
indecciibile

876
00:42:39,760 --> 00:42:41,960
perché

877
00:42:41,960 --> 00:42:44,000
se noi abbiamo che il problema A si può

878
00:42:44,000 --> 00:42:46,440
trasformare nel problema B e il problema

879
00:42:46,440 --> 00:42:48,839
B è indecidibile, il problema A è

880
00:42:48,839 --> 00:42:51,359
indecidibile, non possiamo sperare di

881
00:42:51,359 --> 00:42:53,559
risolverlo trasformandolo in un altro

882
00:42:53,559 --> 00:42:56,359
problema, ok? Quello lì pure dovrà

883
00:42:56,359 --> 00:42:59,079
essere indecidibile se la funzione di

884
00:42:59,079 --> 00:43:01,000
trasformazione è calcolabile. Però

885
00:43:01,000 --> 00:43:02,839
questi sono tutti i dettagli che vedremo

886
00:43:02,839 --> 00:43:05,559
formalmente dopo la pausa, ok? Il quarto

887
00:43:05,559 --> 00:43:08,559
d'ora

888
00:43:15,960 --> 00:43:18,960
va.

889
00:43:28,359 --> 00:43:33,200
Ok. la nozione di riduzione.

890
00:43:34,800 --> 00:43:37,040
Chiaro?

891
00:43:37,040 --> 00:43:38,880
Ok? Quindi è semplicemente la

892
00:43:38,880 --> 00:43:42,000
trasformazione di un delle stanze di un

893
00:43:42,000 --> 00:43:45,000
problema in istanze di un altro. Non una

894
00:43:45,000 --> 00:43:47,079
trasformazione a cavoli, una

895
00:43:47,079 --> 00:43:48,720
trasformazione che ci permetta di

896
00:43:48,720 --> 00:43:50,520
riutilizzare le sue perché se

897
00:43:50,520 --> 00:43:53,559
trasformiamo così a buffo non serve

898
00:43:53,559 --> 00:43:56,119
assolutamente a niente. Ok?

899
00:43:56,119 --> 00:43:59,520
Alr, quindi ora dobbiamo

900
00:43:59,520 --> 00:44:01,599
introdurre la definizione formale di

901
00:44:01,599 --> 00:44:04,359
questo concetto di riduzione che poi lo

902
00:44:04,359 --> 00:44:06,520
useremo per il resto del nostro corso.

903
00:44:06,520 --> 00:44:08,800
Ok?

904
00:44:08,800 --> 00:44:10,880
Allora, nell'esempio che abbiamo visto

905
00:44:10,880 --> 00:44:15,240
prima, che tipo di problemi erano il la

906
00:44:15,240 --> 00:44:17,319
generazione del calendario e la

907
00:44:17,319 --> 00:44:19,319
colazione

908
00:44:19,319 --> 00:44:22,960
del di un grafo?

909
00:44:24,040 --> 00:44:25,800
erano problemi di ricerca o di

910
00:44:25,800 --> 00:44:27,359
decisione?

911
00:44:27,359 --> 00:44:29,400
Problemi di ricerca perché abbiamo degli

912
00:44:29,400 --> 00:44:34,240
output. Ok? Siccome noi ci interessiamo

913
00:44:34,240 --> 00:44:37,079
di problemi di decisione,

914
00:44:37,079 --> 00:44:39,400
la nozione di riduzione la possiamo

915
00:44:39,400 --> 00:44:42,480
semplificare, ok? Perché? Perché le

916
00:44:42,480 --> 00:44:45,559
risposte sono solo 01. Quindi la

917
00:44:45,559 --> 00:44:48,119
trasformazione all'indietro della

918
00:44:48,119 --> 00:44:51,680
soluzione data dal solver del problema B

919
00:44:51,680 --> 00:44:55,520
in realtà non serve perché le risposte

920
00:44:55,520 --> 00:44:59,880
che ci darà il solder per B è 01. Ok? E

921
00:44:59,880 --> 00:45:03,280
noi in output dobbiamo restituire 01.

922
00:45:03,280 --> 00:45:06,480
Quindi la nozione di riduzione fra

923
00:45:06,480 --> 00:45:09,559
problemi di decisione è più semplice.

924
00:45:09,559 --> 00:45:15,240
Ok? Quindi formalizziamo questo

925
00:45:17,960 --> 00:45:21,200
Sì, siano

926
00:45:21,200 --> 00:45:26,960
A e B due linguaggi.

927
00:45:32,359 --> 00:45:36,559
La funzione f

928
00:45:40,000 --> 00:45:45,839
è una riduzione

929
00:45:49,440 --> 00:45:52,440
da

930
00:45:52,520 --> 00:45:55,000
a

931
00:45:55,000 --> 00:45:59,559
B. Ok? Quindi c'è il verso eh problema

932
00:45:59,559 --> 00:46:02,520
di linguaggio di partenza, linguaggio di

933
00:46:02,520 --> 00:46:05,800
destinazione. Ok? Quindi

934
00:46:05,800 --> 00:46:09,680
siano e B due linguaggi. La funzione f è

935
00:46:09,680 --> 00:46:14,280
una riduzione da A a B.

936
00:46:14,280 --> 00:46:17,040
Se

937
00:46:17,040 --> 00:46:20,240
per ogni

938
00:46:20,240 --> 00:46:23,240
stringa

939
00:46:24,520 --> 00:46:27,520
W,

940
00:46:30,359 --> 00:46:36,000
la stringa W appartiene al linguaggio A

941
00:46:36,000 --> 00:46:41,559
se e solo se il trasformato secondo f

942
00:46:41,559 --> 00:46:44,599
appartiene al linguaggio B

943
00:46:44,599 --> 00:46:47,760
e inoltre

944
00:46:48,640 --> 00:46:53,480
F è calcolabile.

945
00:46:54,319 --> 00:46:56,400
Ok? F non può fare magia, deve essere

946
00:46:56,400 --> 00:46:58,640
una cosa che si può calcolare, ok?

947
00:46:58,640 --> 00:47:00,359
Quindi non è che in F ci mettiamo un

948
00:47:00,359 --> 00:47:03,480
problema impeccile. In F deve esserci

949
00:47:03,480 --> 00:47:05,319
qualcosa che sta nel reame delle

950
00:47:05,319 --> 00:47:08,839
funzioni ricorsive. Ok? Quindi

951
00:47:08,839 --> 00:47:11,319
di nuovo, che cos'è una riduzione? una

952
00:47:11,319 --> 00:47:15,359
riduzione è una trasformazione,

953
00:47:15,359 --> 00:47:18,200
una riduzione da un linguaggio A un

954
00:47:18,200 --> 00:47:20,440
linguaggio B o da un problema A un

955
00:47:20,440 --> 00:47:22,839
problema B, che è la stessa cosa, è una

956
00:47:22,839 --> 00:47:26,720
funzione falcolabile

957
00:47:27,559 --> 00:47:33,640
tale per cui per ogni stringa W V è

958
00:47:33,640 --> 00:47:36,760
un'istanza sì del linguaggio A se solo

959
00:47:36,760 --> 00:47:39,880
se la trasformazione di doppia B tramite

960
00:47:39,880 --> 00:47:43,319
F che unistanza sia del linguaggio B.

961
00:47:43,319 --> 00:47:45,200
Ok?

962
00:47:45,200 --> 00:47:47,240
Quindi questa è una semplificazione del

963
00:47:47,240 --> 00:47:49,280
concetto che abbiamo visto prima perché

964
00:47:49,280 --> 00:47:52,000
nel momento adesso in cui noi riduciamo

965
00:47:52,000 --> 00:47:54,000
un problema di decisione A a un problema

966
00:47:54,000 --> 00:47:57,079
di decisione B, quell'algoritmino

967
00:47:57,079 --> 00:47:59,640
che avevamo visto in cui sfruttiamo la

968
00:47:59,640 --> 00:48:05,680
riduzione per fare la eh

969
00:48:05,680 --> 00:48:08,359
per calcolare la soluzione del problema.

970
00:48:08,359 --> 00:48:10,280
In questo caso è molto più semplice

971
00:48:10,280 --> 00:48:11,760
perché quello che dobbiamo fare è che

972
00:48:11,760 --> 00:48:15,319
cos'è? Ci arriva w input, la

973
00:48:15,319 --> 00:48:18,440
trasformiamo secondo F,

974
00:48:18,440 --> 00:48:21,079
la facciamo risolvere a un solutore per

975
00:48:21,079 --> 00:48:24,480
B. Il solutore per B sì o no. Quella

976
00:48:24,480 --> 00:48:27,119
stessa risposta la di noi ok? Questo è

977
00:48:27,119 --> 00:48:29,760
il significato.

978
00:48:29,760 --> 00:48:33,040
Il fatto che W appartiene ad A, se è

979
00:48:33,040 --> 00:48:35,960
solo se il trasformato di W appartiene a

980
00:48:35,960 --> 00:48:40,359
V. Significa che se V se w è un'istanza

981
00:48:40,359 --> 00:48:43,760
s di A, f deve essere un'istanza sì di

982
00:48:43,760 --> 00:48:49,480
B. Se B è un istanza no di A, allora f

983
00:48:49,480 --> 00:48:52,440
deve essere un'istanza di B. Ok? Questo

984
00:48:52,440 --> 00:48:54,640
significa

985
00:48:54,640 --> 00:48:56,599
qui abbiamo

986
00:48:56,599 --> 00:49:02,440
una eh un pezzo che ci manca che cos'è

987
00:49:02,440 --> 00:49:04,440
una funzione calcolabile, ok? Perché

988
00:49:04,440 --> 00:49:06,480
finora non ci siamo occupati di

989
00:49:06,480 --> 00:49:10,280
funzioni, ma ci siamo solamente occupati

990
00:49:10,280 --> 00:49:12,440
di problemi di decisione, ok? una

991
00:49:12,440 --> 00:49:14,040
funzione è una cosa un po' diversa

992
00:49:14,040 --> 00:49:15,520
perché abbiamo un input, abbiamo un

993
00:49:15,520 --> 00:49:17,559
output e problemi di decisione, quelli

994
00:49:17,559 --> 00:49:19,280
sono tutti i linguaggi, o la stringa è

995
00:49:19,280 --> 00:49:21,400
dentro o la stringa è fuori. Quindi ci

996
00:49:21,400 --> 00:49:25,280
serve una definizione per calcolabilità.

997
00:49:25,280 --> 00:49:28,520
Ok? Allora, per definire

998
00:49:28,520 --> 00:49:30,760
quand'è che una funzione calcolabile,

999
00:49:30,760 --> 00:49:34,119
dobbiamo definire non li guarderemo in

1000
00:49:34,119 --> 00:49:36,280
estrema precisione, ci serve giusto per

1001
00:49:36,280 --> 00:49:38,720
dare questa definizione. Dobbiamo vedere

1002
00:49:38,720 --> 00:49:42,480
le macchine di Turing che calcolano un

1003
00:49:42,480 --> 00:49:44,119
output, perché finora abbiamo visto

1004
00:49:44,119 --> 00:49:46,040
macchine di Touring che dicono solo s

1005
00:49:46,040 --> 00:49:48,119
No, ma una macchina di Touring sa pure

1006
00:49:48,119 --> 00:49:51,400
fare le somme per dire. Ok? Quindi come

1007
00:49:51,400 --> 00:49:53,440
come definiamo formalmente la

1008
00:49:53,440 --> 00:49:55,960
calcolabilità delle funzioni? Lo si fa

1009
00:49:55,960 --> 00:49:57,839
tramite questo concetto che è il

1010
00:49:57,839 --> 00:50:01,720
concetto di trasduttore.

1011
00:50:09,000 --> 00:50:11,520
Alrght. Cos'è un trasduttore? Un

1012
00:50:11,520 --> 00:50:13,040
trasduttore

1013
00:50:13,040 --> 00:50:17,040
è una macchina di ting,

1014
00:50:17,040 --> 00:50:19,760
quindi cos'è un trasduttore? È una

1015
00:50:19,760 --> 00:50:23,599
macchina di tuning,

1016
00:50:28,119 --> 00:50:33,040
caratterizzata da tre nastri.

1017
00:50:33,839 --> 00:50:36,440
Ok? Usiamo una definizione multinastro

1018
00:50:36,440 --> 00:50:38,599
perché è comoda. Questa cosa si può

1019
00:50:38,599 --> 00:50:40,480
adattare anche a un nastro solo, però

1020
00:50:40,480 --> 00:50:43,400
per essere chiare. Quindi è una macchina

1021
00:50:43,400 --> 00:50:46,559
di Turouring che calcola calcola

1022
00:50:46,559 --> 00:50:48,520
funzioni, ok?

1023
00:50:48,520 --> 00:50:52,400
Questa macchina ha un nastro di input,

1024
00:50:52,400 --> 00:50:53,960
il primo nastro che è il nastro di

1025
00:50:53,960 --> 00:50:56,880
input, come siamo abituati e questo qua

1026
00:50:56,880 --> 00:51:01,319
è un nastro a solo lettura.

1027
00:51:02,160 --> 00:51:05,920
Ok? Quindi questa macchina ha un nastro

1028
00:51:05,920 --> 00:51:08,200
di input sul quale può solamente

1029
00:51:08,200 --> 00:51:10,520
leggere, non ci può scrivere cose, può

1030
00:51:10,520 --> 00:51:12,799
spostare la testina eccetera, può

1031
00:51:12,799 --> 00:51:14,720
leggere quello che c'è sul nastro, ma

1032
00:51:14,720 --> 00:51:17,200
non lo può alterare.

1033
00:51:17,200 --> 00:51:19,839
Poi c'ha un secondo nastro che è un work

1034
00:51:19,839 --> 00:51:24,280
tape, quindi è della memoria dove può

1035
00:51:24,280 --> 00:51:27,520
fare roba e questo è un nastro a lettura

1036
00:51:27,520 --> 00:51:30,520
scrittura.

1037
00:51:32,040 --> 00:51:35,240
E poi c'è un terzo nastro

1038
00:51:35,240 --> 00:51:38,000
che è il nastro di output

1039
00:51:38,000 --> 00:51:42,680
che è un nastro a sola scrittura.

1040
00:51:43,960 --> 00:51:46,960
Ok.

1041
00:51:47,480 --> 00:51:49,559
Quindi l'intuizione di un trasduttore

1042
00:51:49,559 --> 00:51:51,640
che cos'è? È una macchina di touring che

1043
00:51:51,640 --> 00:51:53,480
legge l'input sul primo nastro, sul

1044
00:51:53,480 --> 00:51:55,119
secondo nastro ci fa il lavoro che ci

1045
00:51:55,119 --> 00:51:57,440
deve fare, quando ha la risposta pronta

1046
00:51:57,440 --> 00:52:00,559
la scrive sul nastro di e poi si ferma.

1047
00:52:00,559 --> 00:52:02,799
Quindi, intuitivamente, la funzione

1048
00:52:02,799 --> 00:52:05,200
calcolata da una macchina di Touring è

1049
00:52:05,200 --> 00:52:08,359
la funzione che ricevendo un input sul

1050
00:52:08,359 --> 00:52:11,119
nastro di input dà come output quello

1051
00:52:11,119 --> 00:52:14,040
che rimane scritto sul nastro di output

1052
00:52:14,040 --> 00:52:16,799
a termine, ok? Quindi non c'è un vero e

1053
00:52:16,799 --> 00:52:18,480
proprio una vera e propria nozione di

1054
00:52:18,480 --> 00:52:20,119
accettazione. Non è che la macchina dice

1055
00:52:20,119 --> 00:52:22,400
sì, dice no, la macchina parte e a un

1056
00:52:22,400 --> 00:52:25,000
certo punto si ferma. Quando si ferma,

1057
00:52:25,000 --> 00:52:27,839
quello che è stato scritto su output è

1058
00:52:27,839 --> 00:52:31,720
il risultato del calcolo. Ok?

1059
00:52:31,720 --> 00:52:33,880
Noi diciamo

1060
00:52:33,880 --> 00:52:35,480
quindi

1061
00:52:35,480 --> 00:52:37,240
un

1062
00:52:37,240 --> 00:52:40,240
trasduttore

1063
00:52:42,160 --> 00:52:43,960
M che quindi è semplicemente una

1064
00:52:43,960 --> 00:52:47,720
macchina. calcola

1065
00:52:47,720 --> 00:52:51,040
la funzione

1066
00:52:53,160 --> 00:52:55,280
f

1067
00:52:55,280 --> 00:53:00,520
se per ogni stringa

1068
00:53:03,119 --> 00:53:05,880
w

1069
00:53:05,880 --> 00:53:08,200
quando

1070
00:53:08,200 --> 00:53:12,280
m esegue

1071
00:53:12,920 --> 00:53:15,520
su W

1072
00:53:15,520 --> 00:53:19,079
al suo arresto

1073
00:53:21,200 --> 00:53:23,520
lascia

1074
00:53:23,520 --> 00:53:25,799
FW

1075
00:53:25,799 --> 00:53:29,040
in output.

1076
00:53:29,319 --> 00:53:31,839
Ok? Quindi

1077
00:53:31,839 --> 00:53:33,720
definizione abbastanza stida ad una

1078
00:53:33,720 --> 00:53:36,480
macchina. chiamiamo trasduttore giusto

1079
00:53:36,480 --> 00:53:38,640
per per

1080
00:53:38,640 --> 00:53:40,160
convenienza nostra, per capire

1081
00:53:40,160 --> 00:53:41,680
direttamente se la macchina è un

1082
00:53:41,680 --> 00:53:44,000
decisore o un calcolatore. Quindi quando

1083
00:53:44,000 --> 00:53:45,280
è un calcolatore lo chiamiamo

1084
00:53:45,280 --> 00:53:47,160
trasuttore, quando è un decisore lo

1085
00:53:47,160 --> 00:53:50,440
chiamiamo macchina di ok? Quindi un

1086
00:53:50,440 --> 00:53:53,839
trasduttore calcola una certa funzione f

1087
00:53:53,839 --> 00:53:57,720
se su ogni stringa che ricevi input

1088
00:53:57,720 --> 00:54:00,680
questa macchina M

1089
00:54:00,680 --> 00:54:02,799
al termine del calcolo, cioè quando la

1090
00:54:02,799 --> 00:54:05,839
macchina si arresta, sul nastro di

1091
00:54:05,839 --> 00:54:08,880
output troviamo il trasformato di doppi

1092
00:54:08,880 --> 00:54:11,760
secondo la funzione f. Ok? Sì,
possiamo

1093
00:54:11,760 --> 00:54:14,160
dire che i classiori

1094
00:54:14,160 --> 00:54:18,960
eh abbiano sempre unazione.

1095
00:54:18,960 --> 00:54:21,680
Ah, ok, perfetto.

1096
00:54:21,680 --> 00:54:23,559
È una richiesta nostra. Sì, perché

1097
00:54:23,559 --> 00:54:26,359
essendo una macchina di Turing, essendo

1098
00:54:26,359 --> 00:54:28,119
un caso più generale delle macchine di

1099
00:54:28,119 --> 00:54:29,920
Turing, il trasguttore in linea di

1100
00:54:29,920 --> 00:54:33,799
principio lo

1101
00:54:33,799 --> 00:54:36,960
potrebbe non fermarsi. Allora, cos'è per

1102
00:54:36,960 --> 00:54:40,400
noi una funzione calcolabile? è una

1103
00:54:40,400 --> 00:54:43,599
funzione per il quale esiste un

1104
00:54:43,599 --> 00:54:46,160
trasmuttore che la calcola sempre in

1105
00:54:46,160 --> 00:54:50,319
tempo fisso. Ok?

1106
00:54:50,720 --> 00:54:52,280
Questo è il concetto. Quindi una

1107
00:54:52,280 --> 00:54:56,400
funzione per noi è calcolabile

1108
00:54:56,400 --> 00:54:59,520
se esiste un trasduttore che la calcoli

1109
00:54:59,520 --> 00:55:02,079
in tempo finito, cioè che per ogni input

1110
00:55:02,079 --> 00:55:04,520
che noi gli diamo,

1111
00:55:04,520 --> 00:55:08,000
stageggino a un certo punto si ferma e

1112
00:55:08,000 --> 00:55:10,640
sul un nastro di output avrà scritto il

1113
00:55:10,640 --> 00:55:13,720
risultato. Ok?

1114
00:55:13,720 --> 00:55:16,760
Quindi, nella definizione di riduzione

1115
00:55:16,760 --> 00:55:18,200
che abbiamo dato prima, che abbiamo

1116
00:55:18,200 --> 00:55:21,440
detto, cos'è una riduzione da AB? È una

1117
00:55:21,440 --> 00:55:24,720
funzione che trasforma le istanze di A

1118
00:55:24,720 --> 00:55:28,520
in istanze di B, tale per cui doppia per

1119
00:55:28,520 --> 00:55:32,000
ogni stringa W. w appartiene a se lo

1120
00:55:32,000 --> 00:55:34,079
sente trasformato di W secondo la

1121
00:55:34,079 --> 00:55:36,200
trasformazione, cioè secondo F

1122
00:55:36,200 --> 00:55:39,079
appartiene a B e la funzione f deve

1123
00:55:39,079 --> 00:55:40,960
essere calcolabile perché senò

1124
00:55:40,960 --> 00:55:42,799
ovviamente è un concetto che non

1125
00:55:42,799 --> 00:55:44,440
possiamo

1126
00:55:44,440 --> 00:55:47,440
non possiamo sfruttare per quello che ci

1127
00:55:47,440 --> 00:55:50,760
serve. Ok? Chiaro per tutti?

1128
00:55:50,760 --> 00:55:54,920
Possiamo adesso iniziare a vedere

1129
00:55:54,920 --> 00:55:59,160
un po' di proprietà delle riduzioni. Ok?

1130
00:55:59,160 --> 00:56:03,240
Vediamo se qua tempo finito.

1131
00:56:03,240 --> 00:56:07,000
Ok? Quindi, nel momento in cui noi

1132
00:56:07,000 --> 00:56:10,720
dobbiamo specificare una riduzione da un

1133
00:56:10,720 --> 00:56:14,000
problema ad un'alttro, no,

1134
00:56:14,000 --> 00:56:15,520
noi dobbiamo specificare qual è sta

1135
00:56:15,520 --> 00:56:18,200
funzione feme una funzione calcolabile e

1136
00:56:18,200 --> 00:56:20,520
per definizione formale la una funzione

1137
00:56:20,520 --> 00:56:22,480
è calcolabile se esiste un trasduttore

1138
00:56:22,480 --> 00:56:24,400
che la calcola in tempo finito. La

1139
00:56:24,400 --> 00:56:26,200
domanda quindi è: ma allora quando

1140
00:56:26,200 --> 00:56:27,960
dobbiamo ridurre un problema a un altro

1141
00:56:27,960 --> 00:56:29,280
dobbiamo mostrare la macchinina di

1142
00:56:29,280 --> 00:56:32,240
Turing che fa la trasformazione? No, non

1143
00:56:32,240 --> 00:56:35,160
è necessario.

1144
00:56:35,160 --> 00:56:37,599
Nelle prossime descrizioni e anche

1145
00:56:37,599 --> 00:56:40,839
quando farete l'esame, se vi chiedo una

1146
00:56:40,839 --> 00:56:42,640
riduzione,

1147
00:56:42,640 --> 00:56:45,440
quello che eh siamo interessati è un

1148
00:56:45,440 --> 00:56:48,680
algoritmo o in pseudocodice o in

1149
00:56:48,680 --> 00:56:50,440
linguaggio naturale che sia

1150
00:56:50,440 --> 00:56:52,599
sufficientemente preciso da far capire

1151
00:56:52,599 --> 00:56:55,559
che fa sta funzione f, no? Perché un

1152
00:56:55,559 --> 00:56:57,640
conto è tipo sul problema di prima del

1153
00:56:57,640 --> 00:56:59,799
calendario. La funzione f prende la

1154
00:56:59,799 --> 00:57:02,880
lista del delle squadre, genera tutte le

1155
00:57:02,880 --> 00:57:05,160
coppie per farne i nodi, collega i nodi

1156
00:57:05,160 --> 00:57:07,599
secondo questo criterio. Il numero dei

1157
00:57:07,599 --> 00:57:09,200
colori è questo. Questa è una

1158
00:57:09,200 --> 00:57:11,920
descrizione precisa. Una descrizione del

1159
00:57:11,920 --> 00:57:14,680
tipo: la funzione f prende la lista

1160
00:57:14,680 --> 00:57:18,039
delle delle squadre e tira fuori il

1161
00:57:18,039 --> 00:57:20,440
grafo che mi serve, quello è una

1162
00:57:20,440 --> 00:57:22,599
descrizione un po' meno precisa. Ok?

1163
00:57:22,599 --> 00:57:25,319
Quindi non è necessario tirar fuori il

1164
00:57:25,319 --> 00:57:27,640
trasuttore, la macchina di Touring, però

1165
00:57:27,640 --> 00:57:30,359
è indispensabile che la descrizione, che

1166
00:57:30,359 --> 00:57:32,359
sia anche in linguaggio lavorale, non

1167
00:57:32,359 --> 00:57:34,760
importa, sia sufficientemente precisa da

1168
00:57:34,760 --> 00:57:37,240
capire com'è che statput viene generato

1169
00:57:37,240 --> 00:57:41,839
dalla funzione di trasformazione. Ok?

1170
00:57:41,839 --> 00:57:44,039
Alright.

1171
00:57:44,039 --> 00:57:47,920
Quindi proprietà delle riduzioni e poi

1172
00:57:47,920 --> 00:57:49,760
vedremo un'applicazione di riduzioni

1173
00:57:49,760 --> 00:57:54,160
così vediamo che ci possiamo fare.

1174
00:57:54,160 --> 00:57:56,920
Formalizziamo l'intuizione che abbiamo

1175
00:57:56,920 --> 00:58:00,720
avuto prima. teorema

1176
00:58:02,160 --> 00:58:04,039
siano

1177
00:58:04,039 --> 00:58:09,280
A e B due linguaggi

1178
00:58:11,160 --> 00:58:13,119
tali che

1179
00:58:13,119 --> 00:58:18,039
A si riduce a B. Ok? Quindi noi abbiamo

1180
00:58:18,039 --> 00:58:20,079
due linguaggi

1181
00:58:20,079 --> 00:58:23,839
per i quali sappiamo esiste una

1182
00:58:23,839 --> 00:58:29,079
riduzione, ok? Da A B.

1183
00:58:30,319 --> 00:58:33,319
1.

1184
00:58:33,640 --> 00:58:39,880
Se A non appartiene a R,

1185
00:58:40,880 --> 00:58:43,480
allora

1186
00:58:43,480 --> 00:58:48,000
B non appartiene a R.

1187
00:58:49,000 --> 00:58:50,440
Ora dimostriamo. Eh, comunque è

1188
00:58:50,440 --> 00:58:53,359
un'intuizione che già abbiamo avuto.

1189
00:58:53,359 --> 00:58:55,319
Secondo,

1190
00:58:55,319 --> 00:59:01,440
se A non appartiene ad re, allora

1191
00:59:01,440 --> 00:59:06,599
B non appartiene a R-.

1192
00:59:06,599 --> 00:59:08,799
Induivamente ci siete? che avevamo

1193
00:59:08,799 --> 00:59:11,079
discusso un po' prima, cioè se A è

1194
00:59:11,079 --> 00:59:13,039
indecidibile

1195
00:59:13,039 --> 00:59:15,520
e lo trasformo a B tramite una funzione

1196
00:59:15,520 --> 00:59:18,200
falcolabile e lì vi indico perché se la

1197
00:59:18,200 --> 00:59:20,559
funzione di trasformazione è la funzione

1198
00:59:20,559 --> 00:59:23,280
del mago merlino, allora potremmo

1199
00:59:23,280 --> 00:59:25,680
tradurre trasformare le istanze di un

1200
00:59:25,680 --> 00:59:27,920
problema decidibile in istanze di un

1201
00:59:27,920 --> 00:59:30,680
problema, cioè istanze di un problema

1202
00:59:30,680 --> 00:59:33,200
indecidibili in istanze di un problema

1203
00:59:33,200 --> 00:59:35,880
semplicissimo perché la funzione di

1204
00:59:35,880 --> 00:59:37,839
trasformazione che è il potere della

1205
00:59:37,839 --> 00:59:40,079
bacchetta magica e trasforma ste cose

1206
00:59:40,079 --> 00:59:43,640
qua, no? Però se abbiamo il vincolo

1207
00:59:43,640 --> 00:59:44,960
stringente che la funzione di

1208
00:59:44,960 --> 00:59:47,079
trasformazione deve essere computabile,

1209
00:59:47,079 --> 00:59:48,480
cioè ci deve stare una macchina di

1210
00:59:48,480 --> 00:59:50,920
Touring che è in grado di calcolarla in

1211
00:59:50,920 --> 00:59:53,760
tempo finito, allora intuitivamente non

1212
00:59:53,760 --> 00:59:55,480
possiamo sperare di trasformare un

1213
00:59:55,480 --> 00:59:57,720
problema indecidibile in qualcosa che si

1214
00:59:57,720 --> 01:00:00,760
decide, ok? è quella è quella la chiave

1215
01:00:00,760 --> 01:00:02,240
rivolta, cioè che la funzione di

1216
01:00:02,240 --> 01:00:05,480
trasformazione deve essere calcolabile

1217
01:00:05,480 --> 01:00:07,680
perché senò tutta la difficoltà della

1218
01:00:07,680 --> 01:00:11,119
trasformazione della riduzione,

1219
01:00:11,119 --> 01:00:13,640
la difficoltà di prendere un problema

1220
01:00:13,640 --> 01:00:15,720
difficile e buttarlo su un problema

1221
01:00:15,720 --> 01:00:17,880
facile si anniditerebbe nella funzione

1222
01:00:17,880 --> 01:00:19,640
di trasformazione. Ok? Ma se noi

1223
01:00:19,640 --> 01:00:20,799
diciamo, guarda che la funzione di

1224
01:00:20,799 --> 01:00:22,640
trasformazione non è che può fa cose

1225
01:00:22,640 --> 01:00:25,599
strane, deve essere calcolabile, allora

1226
01:00:25,599 --> 01:00:28,680
non possiamo sperare di trasformare un

1227
01:00:28,680 --> 01:00:31,400
problema indecidibile in qualcosa di

1228
01:00:31,400 --> 01:00:34,319
decidibile. Ok?

1229
01:00:34,319 --> 01:00:35,400
Ok.

1230
01:00:35,400 --> 01:00:37,640
Dimostriamo formalmente queste proprietà

1231
01:00:37,640 --> 01:00:40,319
che poi è quello che useremo per il

1232
01:00:40,319 --> 01:00:44,079
resto del corso. Eh,

1233
01:00:44,079 --> 01:00:46,799
dimostrazione.

1234
01:00:46,799 --> 01:00:50,720
Partiamo dal primo.

1235
01:00:53,720 --> 01:00:55,839
Allora, procediamo. Procediamo assieme,

1236
01:00:55,839 --> 01:00:57,400
ragioniamoci assieme. Allora, noi

1237
01:00:57,400 --> 01:01:02,039
vogliamo mostrare che se A si riduce a B

1238
01:01:02,039 --> 01:01:04,119
e A

1239
01:01:04,119 --> 01:01:08,079
non è ricorsivo, allora nemmeno B può

1240
01:01:08,079 --> 01:01:11,119
esserlo. Ok?

1241
01:01:11,119 --> 01:01:14,960
Vi do io l'avvio e poi ci ragioniamo

1242
01:01:14,960 --> 01:01:17,760
assieme. Ok? Come vedete,

1243
01:01:17,760 --> 01:01:21,240
adesso stiamo sostanzialmente annidando

1244
01:01:21,240 --> 01:01:24,920
nella dimostrazione di questa proprietà

1245
01:01:24,920 --> 01:01:27,359
tutte quelle dimostrazioni che abbiamo

1246
01:01:27,359 --> 01:01:29,319
fatto ieri che avevano tutte la stessa

1247
01:01:29,319 --> 01:01:32,920
forma. Adesso noi fattorizziamo

1248
01:01:32,920 --> 01:01:35,240
quell'idea nella proprietà delle

1249
01:01:35,240 --> 01:01:37,200
riduzioni e dopodiché usiamo le

1250
01:01:37,200 --> 01:01:39,480
riduzioni. Ok?

1251
01:01:39,480 --> 01:01:43,039
Quindi, primo passaggio,

1252
01:01:43,039 --> 01:01:46,039
se A non appartiene a R, allora B non

1253
01:01:46,039 --> 01:01:49,079
appartiene ad R. Questa è

1254
01:01:49,079 --> 01:01:51,200
un'implicazione.

1255
01:01:51,200 --> 01:01:54,160
Dobbiamo assumere per assurdo la sua

1256
01:01:54,160 --> 01:01:55,839
negazione.

1257
01:01:55,839 --> 01:01:58,400
Qual è la negazione di questa

1258
01:01:58,400 --> 01:02:01,400
implicazione?

1259
01:02:03,039 --> 01:02:06,039
Sì,
se B appartiene R, anche A

1260
01:02:06,039 --> 01:02:12,680
appartiene R
che A non appartiene ad R

1261
01:02:12,680 --> 01:02:18,680
e B appartiene ad R.

1262
01:02:18,839 --> 01:02:21,640
Come ci si arriva? Eh, ok, questo è il

1263
01:02:21,640 --> 01:02:23,880
trucco.

1264
01:02:23,880 --> 01:02:27,119
A, B. Devo usare altri nomi. X e Y. X e

1265
01:02:27,119 --> 01:02:29,720
Y. Ok.

1266
01:02:29,720 --> 01:02:32,359
Quello che è scritto là sopra.

1267
01:02:32,359 --> 01:02:35,200
Se A non appartiene a R, allora B non

1268
01:02:35,200 --> 01:02:39,240
appartiene a R. È questa cosa qua. X

1269
01:02:39,240 --> 01:02:44,079
implica Y, in cui X A non appartiene a R

1270
01:02:44,079 --> 01:02:48,480
e Y e B non appartiene a R. È chiaro il

1271
01:02:48,480 --> 01:02:50,799
significato di quei due pezzi? Questa

1272
01:02:50,799 --> 01:02:53,240
questo pezzo di formula logica è uguale

1273
01:02:53,240 --> 01:02:56,880
a Lo sapete riscrivere senza la

1274
01:02:56,880 --> 01:02:59,079
frecettina?

1275
01:02:59,079 --> 01:03:06,160
Not X
not X or Y. Not X or Y. Ok.

1276
01:03:06,160 --> 01:03:08,839
Se no prendiamo la negazione di questo,

1277
01:03:08,839 --> 01:03:10,599
che cos'è?

1278
01:03:10,599 --> 01:03:12,119
X

1279
01:03:12,119 --> 01:03:17,640
X and not Y. E guardate qua,

1280
01:03:17,640 --> 01:03:21,119
A non appartiene a Ro.

1281
01:03:21,119 --> 01:03:22,920
And

1282
01:03:22,920 --> 01:03:26,599
il negato di y

1283
01:03:26,599 --> 01:03:30,200
ho sbagliato un attimo.

1284
01:03:31,640 --> 01:03:34,359
E B appartiene a R che è il negato di Y

1285
01:03:34,359 --> 01:03:37,599
che Y era

1286
01:03:37,599 --> 01:03:41,079
Ok? Quindi così si nega una

1287
01:03:41,079 --> 01:03:43,440
un'implicazione. Eh, il negato di

1288
01:03:43,440 --> 01:03:44,960
un'implicazione che cos'è? È che

1289
01:03:44,960 --> 01:03:49,039
l'cedente è vero e il conseguente è

1290
01:03:49,039 --> 01:03:54,119
falso. Ok? Chiaro? Quindi

1291
01:03:54,119 --> 01:03:57,839
questo qua è in inciso. Rifocalizziamoci

1292
01:03:57,839 --> 01:04:00,440
sulla assunzione per assurdo. La nostra

1293
01:04:00,440 --> 01:04:05,400
assunzione per assurdo è che A Sì,

1294
01:04:05,400 --> 01:04:09,440
che A non appartiene a ricorsivo e

1295
01:04:09,440 --> 01:04:15,920
nonostante ciò B sia ricorsivo. Ok?

1296
01:04:16,480 --> 01:04:19,520
Chiaro? Quindi questa è l'assunzione di

1297
01:04:19,520 --> 01:04:23,680
partenza da cui ci stiamo muovendo. Ok?

1298
01:04:23,680 --> 01:04:25,799
Se B è riporsivo, che cosa possiamo

1299
01:04:25,799 --> 01:04:28,799
dire?

1300
01:04:31,760 --> 01:04:34,039
Sì,

1301
01:04:34,039 --> 01:04:36,920
sì.

1302
01:04:36,920 --> 01:04:41,279
Allora, se B appartiene ad R, allora

1303
01:04:41,279 --> 01:04:44,319
esiste una macchina MDB

1304
01:04:44,319 --> 01:04:47,640
che decide

1305
01:04:48,039 --> 01:04:52,039
B. Ok?

1306
01:04:53,839 --> 01:04:56,520
Ma allora

1307
01:04:56,520 --> 01:04:58,319
potremmo

1308
01:04:58,319 --> 01:05:00,599
costruirci

1309
01:05:00,599 --> 01:05:05,799
un decisore per A fatto in questo modo.

1310
01:05:07,839 --> 01:05:10,480
Quindi questa è un MA che è un decisore

1311
01:05:10,480 --> 01:05:13,240
per A.

1312
01:05:13,240 --> 01:05:18,000
prende in input w

1313
01:05:18,799 --> 01:05:23,480
calcola la funzione di f per ottenere f.

1314
01:05:23,480 --> 01:05:25,680
E questa cosa è fattibile perché stiamo

1315
01:05:25,680 --> 01:05:28,400
assumendo che A si riduce a b, quindi f

1316
01:05:28,400 --> 01:05:30,720
è una funzione che esiste ed è una

1317
01:05:30,720 --> 01:05:34,359
funzione calcolabile. Ok?

1318
01:05:34,359 --> 01:05:37,279
E questa cosa viene data in input a la

1319
01:05:37,279 --> 01:05:40,680
macchina MB.

1320
01:05:40,680 --> 01:05:44,200
Se questa risponde sì, rispondiamo sì.

1321
01:05:44,200 --> 01:05:49,119
Se questa risponde no, rispondiamo no.

1322
01:05:49,119 --> 01:05:52,119
Ok?

1323
01:05:52,680 --> 01:05:54,640
Qual è il linguaggio di questa macchina

1324
01:05:54,640 --> 01:05:58,319
che chiamiamo ma?

1325
01:06:11,960 --> 01:06:13,880
Mh.

1326
01:06:13,880 --> 01:06:15,680
Il linguaggio della macchinona, della

1327
01:06:15,680 --> 01:06:17,720
macchina grossa, della macchina esterna.

1328
01:06:17,720 --> 01:06:22,640
Vai. Mh. Ah, il linguaggio di questa

1329
01:06:22,640 --> 01:06:24,640
macchina

1330
01:06:24,640 --> 01:06:29,319
è A. Di conseguenza noi avremmo un

1331
01:06:29,319 --> 01:06:32,640
decisore per A.

1332
01:06:32,640 --> 01:06:36,200
Ma questo non è possibile perché noi

1333
01:06:36,200 --> 01:06:40,720
stiamo assumendo che A è indecci,

1334
01:06:40,720 --> 01:06:45,680
quindi per forza B deve essere esso

1335
01:06:45,680 --> 01:06:49,599
stesso indecidibile.

1336
01:06:50,920 --> 01:06:56,039
Ok? È chiaro? Quindi, se noi riduciamo

1337
01:06:56,039 --> 01:06:58,799
tramite una funzione calcolabile un

1338
01:06:58,799 --> 01:07:03,039
problema indecidibile a un altro, allora

1339
01:07:03,039 --> 01:07:05,520
quest'altro problema, il problema di

1340
01:07:05,520 --> 01:07:07,680
destinazione deve essere esso stesso

1341
01:07:07,680 --> 01:07:11,160
indecidibile. Ok?

1342
01:07:11,160 --> 01:07:13,440
Secondo

1343
01:07:13,440 --> 01:07:14,960
pezzo

1344
01:07:14,960 --> 01:07:18,119
si procede allo stesso modo.

1345
01:07:18,119 --> 01:07:20,640
Supponiamo da qui. Questa quindi è una

1346
01:07:20,640 --> 01:07:23,920
contraddizione. Contraddizione. Quindi

1347
01:07:23,920 --> 01:07:27,200
assumiamo che A

1348
01:07:27,200 --> 01:07:31,880
non appartenga ad RE and B appartenga ad

1349
01:07:31,880 --> 01:07:33,520
R.

1350
01:07:33,520 --> 01:07:37,839
la costruzione è identica,

1351
01:07:37,839 --> 01:07:40,559
nel senso che in questo in questo caso

1352
01:07:40,559 --> 01:07:45,160
il il la macchina che riconosce qui non

1353
01:07:45,160 --> 01:07:48,640
è un decisore, ma è un accettatore. Ok?

1354
01:07:48,640 --> 01:07:50,760
Però se costruiamo la macchina allo

1355
01:07:50,760 --> 01:07:53,680
stesso modo, eh qui prendiamo W in

1356
01:07:53,680 --> 01:07:56,000
input,

1357
01:07:56,000 --> 01:07:59,279
calcoliamo F di W. F cos'è? è proprio la

1358
01:07:59,279 --> 01:08:01,760
funzione che trasforma a in béch

1359
01:08:01,760 --> 01:08:04,119
sappiamo nell'assunzione del teorema che

1360
01:08:04,119 --> 01:08:06,960
A si riduce a B e poi abbiamo impasto

1361
01:08:06,960 --> 01:08:10,000
all'accettatore di B, noi otterremo

1362
01:08:10,000 --> 01:08:13,279
overall un accettatore per A. Ma ciò non

1363
01:08:13,279 --> 01:08:16,640
è possibile perché stiamo assumendo che

1364
01:08:16,640 --> 01:08:19,920
A non sia ricorsivamente numerabile,

1365
01:08:19,920 --> 01:08:22,319
quindi per forza anche qui non deve

1366
01:08:22,319 --> 01:08:25,000
esserlo.

1367
01:08:25,000 --> 01:08:26,880
È chiaro questo passaggio? Siamo andati

1368
01:08:26,880 --> 01:08:31,000
troppo veloce. Ok,

1369
01:08:36,000 --> 01:08:39,080
mi serve un po' di tempo ora per fare un

1370
01:08:39,080 --> 01:08:43,159
esemplino. Ok, chiaro? Quindi un'altra

1371
01:08:43,159 --> 01:08:47,640
proprietà che è in

1372
01:08:47,640 --> 01:08:49,920
è il

1373
01:08:49,920 --> 01:08:54,400
è è interessante che è un corollario

1374
01:08:55,520 --> 01:08:58,799
del problema del teorema precedente è

1375
01:08:58,799 --> 01:09:01,520
ottenuto tramite

1376
01:09:01,520 --> 01:09:04,679
l'inversione dell'implicazione. Ok? Noi

1377
01:09:04,679 --> 01:09:08,080
abbiamo visto che se A non è non

1378
01:09:08,080 --> 01:09:10,799
appartiene a R, allora B non non deve

1379
01:09:10,799 --> 01:09:13,279
appartenere a R. E se A non appartiene a

1380
01:09:13,279 --> 01:09:16,759
R, allora B non appartiene ad R. Però

1381
01:09:16,759 --> 01:09:19,040
noi possiamo fare, come si dice in

1382
01:09:19,040 --> 01:09:22,040
italiano? Il converso,

1383
01:09:22,040 --> 01:09:25,120
come
converso.
Il converso, sì,

1384
01:09:25,120 --> 01:09:27,960
l'opposto. Boh. Lo giriamo, ok? lo

1385
01:09:27,960 --> 01:09:30,719
svoltiamo, facciamo un calzino bla e lo

1386
01:09:30,719 --> 01:09:34,239
facciamo allora che si ottiene come

1387
01:09:34,239 --> 01:09:36,279
guardando la definizione di

1388
01:09:36,279 --> 01:09:40,520
implicazione, no? Che noi possiamo

1389
01:09:40,520 --> 01:09:42,799
ve la scrivo.

1390
01:09:42,799 --> 01:09:45,799
Se x implica y, allora questa cosa è

1391
01:09:45,799 --> 01:09:50,239
uguale a not x or y, però questa cosa è

1392
01:09:50,239 --> 01:09:54,679
uguale a not y implica noti

1393
01:09:54,679 --> 01:09:56,960
riscriviamo la cosa al contrario, ok?

1394
01:09:56,960 --> 01:09:59,920
Quindi, applicando questa trasformazione

1395
01:09:59,920 --> 01:10:04,600
al di prima otteniamo questo corollario.

1396
01:10:04,600 --> 01:10:06,440
Siano

1397
01:10:06,440 --> 01:10:11,199
A e B due linguaggi

1398
01:10:11,800 --> 01:10:18,239
tali che A si riduce a B. 1. Se B

1399
01:10:18,239 --> 01:10:22,400
appartiene ad R, allora

1400
01:10:22,400 --> 01:10:28,120
A appartiene a R. 2. Se B appartiene ad

1401
01:10:28,120 --> 01:10:31,520
R, allora

1402
01:10:31,520 --> 01:10:37,280
A appartiene e scritto proprio

1403
01:10:37,280 --> 01:10:39,560
appartiene ad re. Ok? Abbiamo

1404
01:10:39,560 --> 01:10:41,280
semplicemente preso il verso

1405
01:10:41,280 --> 01:10:43,120
dell'implicazione del teorema di prima e

1406
01:10:43,120 --> 01:10:45,440
l'abbiamo tutto qua. Eh, non abbiamo

1407
01:10:45,440 --> 01:10:49,000
fatto nulla di drammaticamente

1408
01:10:49,000 --> 01:10:51,440
complicato. Ok? Abbiamo ascoltato la

1409
01:10:51,440 --> 01:10:52,560
proprietà di definizione

1410
01:10:52,560 --> 01:10:55,000
dell'implicazione.

1411
01:10:55,000 --> 01:10:56,600
È chiaro? Chiaro come abbiamo ottenuto

1412
01:10:56,600 --> 01:11:00,640
sto corollario? Ok.

1413
01:11:01,840 --> 01:11:04,840
Alright.

1414
01:11:06,199 --> 01:11:09,120
Vediamo adesso un altro linguaggio

1415
01:11:09,120 --> 01:11:10,840
insieme a quelli di ieri che vogliamo

1416
01:11:10,840 --> 01:11:12,719
dimostrare essere indecidibile, però

1417
01:11:12,719 --> 01:11:15,120
stavolta lo dimostriamo la sua

1418
01:11:15,120 --> 01:11:17,199
indecidibilità tramite induzione. Quindi

1419
01:11:17,199 --> 01:11:19,159
vediamo che non ci dobbiamo inventare

1420
01:11:19,159 --> 01:11:22,840
più quei teoremi per assurdo, cose così,

1421
01:11:22,840 --> 01:11:24,080
ci dobbiamo inventare un'altra cosa,

1422
01:11:24,080 --> 01:11:26,080
cioè ci dobbiamo inventare la riduzione.

1423
01:11:26,080 --> 01:11:29,080
Ok?

1424
01:11:31,400 --> 01:11:36,280
Definiamo il linguaggio LNE,

1425
01:11:36,280 --> 01:11:40,800
il linguaggio not empty, che è l'insieme

1426
01:11:40,800 --> 01:11:44,560
dei codici di macchine di Touring,

1427
01:11:44,560 --> 01:11:48,520
tale che il linguaggio della macchina M

1428
01:11:48,520 --> 01:11:52,560
con I non è vuoto.

1429
01:11:52,560 --> 01:11:54,400
Ok?

1430
01:11:54,400 --> 01:11:56,400
Infinitivamente, che cosa definisce sto

1431
01:11:56,400 --> 01:11:59,400
linguaggio?

1432
01:12:06,159 --> 01:12:07,880
Le macchine che accettano almeno

1433
01:12:07,880 --> 01:12:11,000
stilica. Sì. In LNE ci stanno i codici

1434
01:12:11,000 --> 01:12:13,800
di macchine di touring, le quali dicono

1435
01:12:13,800 --> 01:12:17,320
sì su almenut. Quale? Non ci importa,

1436
01:12:17,320 --> 01:12:22,679
basta che sia uno, almeno uno. Ok?

1437
01:12:26,400 --> 01:12:28,960
Allora, vogliamo studiare la proprietà

1438
01:12:28,960 --> 01:12:31,480
di decidibilità di questo linguaggio,

1439
01:12:31,480 --> 01:12:34,520
ok? È come chiederci un programma, è

1440
01:12:34,520 --> 01:12:36,520
vero che risponde sì su almeno una

1441
01:12:36,520 --> 01:12:38,920
string input? Questa è la cosa che ci

1442
01:12:38,920 --> 01:12:40,920
stiamo chiedendo.

1443
01:12:40,920 --> 01:12:45,400
Allora, questo

1444
01:12:46,159 --> 01:12:49,040
linguaggio

1445
01:12:49,040 --> 01:12:54,719
si può dimostrare essere in re. Ok? Ln

1446
01:12:54,719 --> 01:12:57,080
appartiene, ve lo dico io, appartiene ad

1447
01:12:57,080 --> 01:12:58,800
re. Secondo voi come si può fare sta

1448
01:12:58,800 --> 01:13:03,960
cosa? Come si dimostra che ln? Sì,
posso

1449
01:13:03,960 --> 01:13:07,960
ridurlo a quello dell'arresto?

1450
01:13:08,840 --> 01:13:11,880
Eh, ok. Qual è l'istanza del problema

1451
01:13:11,880 --> 01:13:14,880
dell'arresto?

1452
01:13:19,159 --> 01:13:21,520
È una macchina e una stringa. Che

1453
01:13:21,520 --> 01:13:23,800
stringa gli do? C può essere una cosa,

1454
01:13:23,800 --> 01:13:26,719
no? Più standard. Ok. Sì, cioè nel

1455
01:13:26,719 --> 01:13:28,600
principio uno potrebbe farlo. Facciamo

1456
01:13:28,600 --> 01:13:30,400
un po' facile. Vi ricordo che un

1457
01:13:30,400 --> 01:13:32,320
linguaggio appartiene ad RS se esiste

1458
01:13:32,320 --> 01:13:35,480
una macchina di tringo accetta. Ok? Noi

1459
01:13:35,480 --> 01:13:38,520
prendiamo questa strada per per questo

1460
01:13:38,520 --> 01:13:40,760
risultato. Ok? Qual è una macchina di

1461
01:13:40,760 --> 01:13:44,159
Turing che potrebbe accettare LN? Ok?

1462
01:13:44,159 --> 01:13:46,639
Quindi riceve input,

1463
01:13:46,639 --> 01:13:48,400
quindi abbiamo una una macchina di

1464
01:13:48,400 --> 01:13:50,760
Touring che riceve in input un'altra

1465
01:13:50,760 --> 01:13:54,000
macchina di Touring e deve stabilire se

1466
01:13:54,000 --> 01:13:56,360
la macchina ricevuta in input risponde

1467
01:13:56,360 --> 01:14:00,880
sì su qualche strilla.

1468
01:14:03,639 --> 01:14:06,280
Sì, cioè allora a livello nonistico

1469
01:14:06,280 --> 01:14:09,199
è immediato. Praticamente prendiamo come

1470
01:14:09,199 --> 01:14:12,120
indoviniamo ciò che accetta. Prendiamo

1471
01:14:12,120 --> 01:14:14,000
la st che accetta e prendiamo come inut.

1472
01:14:14,000 --> 01:14:16,800
Esattamente. E questa è la soluzione.

1473
01:14:16,800 --> 01:14:19,560
Ok? È semplicissima la cosa. Usiamo una

1474
01:14:19,560 --> 01:14:21,400
macchina non deterministica. Poi vi

1475
01:14:21,400 --> 01:14:23,880
spiego un attimo perché ci conviene far

1476
01:14:23,880 --> 01:14:27,600
questo. Allora, quindi una macchina

1477
01:14:27,600 --> 01:14:33,080
per LNE, la chiamiamo mne, ad esempio,

1478
01:14:33,080 --> 01:14:38,920
riceviamo in input m con i. Poi, come ci

1479
01:14:38,920 --> 01:14:41,920
suggeriva il nostro collega, gessiamo

1480
01:14:41,920 --> 01:14:44,280
una stringa

1481
01:14:44,280 --> 01:14:47,280
W, la diamo impasto alla macchina

1482
01:14:47,280 --> 01:14:50,120
universale. Se questa dice di sì, noi

1483
01:14:50,120 --> 01:14:54,600
diciamo di sì. Ok?

1484
01:14:56,760 --> 01:14:59,880
È chiaro che fa sta macchina? Allora, un

1485
01:14:59,880 --> 01:15:03,840
algoritmo per questa macchina è appunto

1486
01:15:03,840 --> 01:15:07,480
questo, cioè che la macchina MNE non lo

1487
01:15:07,480 --> 01:15:10,000
sa fin da principio qual è la stringa

1488
01:15:10,000 --> 01:15:12,239
che mi

1489
01:15:12,239 --> 01:15:16,360
può accettare che fa la Ok? Se una tale

1490
01:15:16,360 --> 01:15:19,120
stringa esiste, la macchina non è la

1491
01:15:19,120 --> 01:15:22,520
gessa, quindi la sputa fuori. Come la fa

1492
01:15:22,520 --> 01:15:24,880
a gessare? È quella cosa che abbiamo

1493
01:15:24,880 --> 01:15:27,360
visto in quell'esercizio in cui dicevo

1494
01:15:27,360 --> 01:15:30,159
scriviamo preventivamente le cose sul

1495
01:15:30,159 --> 01:15:33,440
nastro. Che fa la macchina? Sputa sul

1496
01:15:33,440 --> 01:15:36,199
nastro preventivamente sta W. Dice

1497
01:15:36,199 --> 01:15:38,320
questa verrà accettata dalla macchina

1498
01:15:38,320 --> 01:15:41,719
mail. Dopodiché simula su W tramite una

1499
01:15:41,719 --> 01:15:43,440
macchina universale. Se questa accetta

1500
01:15:43,440 --> 01:15:47,000
risponde di sì. Ok? È chiaro che questo

1501
01:15:47,000 --> 01:15:49,400
è il linguaggio che il linguaggio

1502
01:15:49,400 --> 01:15:53,400
accettato da MNE è LNE.

1503
01:15:53,400 --> 01:15:55,880
Ok? Perché la vogliamo gessare e non le

1504
01:15:55,880 --> 01:15:59,960
proviamo una dopo l'altra?

1505
01:16:02,960 --> 01:16:04,679
Sì,
perché su alcune potrebbe non

1506
01:16:04,679 --> 01:16:06,440
terminare.
Perché su alcune potrebbe non

1507
01:16:06,440 --> 01:16:08,040
terminare. Cioè, quindi se iniziamo a

1508
01:16:08,040 --> 01:16:10,280
testare una stringa dopo l'altro e mu

1509
01:16:10,280 --> 01:16:12,639
non si arresta, è un caso di problema.

1510
01:16:12,639 --> 01:16:16,000
Allora, la che siamo, ok? Poi sappiamo

1511
01:16:16,000 --> 01:16:17,760
che esiste una trasformazione da

1512
01:16:17,760 --> 01:16:19,159
macchina non deterministica a

1513
01:16:19,159 --> 01:16:20,560
deterministica, quindi questa ci

1514
01:16:20,560 --> 01:16:25,480
garantisce che il linguaggio LNE è in R.

1515
01:16:25,480 --> 01:16:30,719
Ok? La domanda ora è se LNE apparteng o

1516
01:16:30,719 --> 01:16:33,719
meno.

1517
01:16:33,960 --> 01:16:36,960
Teorema.

1518
01:16:39,800 --> 01:16:43,639
Intuitivamente il linguaggio,

1519
01:16:45,159 --> 01:16:51,159
secondo voi appartiene a R a a R o no?

1520
01:16:51,159 --> 01:16:53,760
Hai

1521
01:16:53,760 --> 01:16:57,199
intuito. Eh,

1522
01:17:01,120 --> 01:17:05,000
no, perché può essere l'infuzione e

1523
01:17:05,000 --> 01:17:08,360
la possibilità che non

1524
01:17:08,360 --> 01:17:12,560
possa terminare su una stringa.
Mh,

1525
01:17:12,560 --> 01:17:15,400
quello No, non è quello, perché quello è

1526
01:17:15,400 --> 01:17:17,360
su una determinata stringa potrebbe non

1527
01:17:17,360 --> 01:17:19,080
terminare, però magari termina su

1528
01:17:19,080 --> 01:17:22,400
un'altra. La questione è l'intuizione

1529
01:17:22,400 --> 01:17:24,480
del l'intuizione della ragione per cui

1530
01:17:24,480 --> 01:17:26,560
questo linguaggio non è ricorsivo, cioè

1531
01:17:26,560 --> 01:17:29,159
io ragiono così. E se ho problemi a dire

1532
01:17:29,159 --> 01:17:32,480
di no. Se devo rispondere di no su

1533
01:17:32,480 --> 01:17:34,600
un'istanza di LNE, che sono le istanze

1534
01:17:34,600 --> 01:17:36,760
di LN?

1535
01:17:36,760 --> 01:17:40,159
Sono macchine. Se devo rispondere di no,

1536
01:17:40,159 --> 01:17:42,239
significa che quella macchina non

1537
01:17:42,239 --> 01:17:44,760
accetta niente. E io come faccio a

1538
01:17:44,760 --> 01:17:46,360
essere sicuro che quella macchina non

1539
01:17:46,360 --> 01:17:47,840
accetta niente? Che faccio? Le provo

1540
01:17:47,840 --> 01:17:49,760
tutte? Sì. Quanto tempo mi serve?

1541
01:17:49,760 --> 01:17:54,000
Infinito. Quindi intuitivamente

1542
01:17:54,000 --> 01:17:56,280
è difficile rispondere di noi su questo

1543
01:17:56,280 --> 01:17:58,159
problema. Poi magari esiste un modo più

1544
01:17:58,159 --> 01:18:00,639
furbo, però questo mi dà l'intuizione

1545
01:18:00,639 --> 01:18:02,679
che il problema non è ricorsivo perché

1546
01:18:02,679 --> 01:18:05,880
perché ho difficoltà a dire di no. Cioè

1547
01:18:05,880 --> 01:18:09,040
io così ragiono, ok? Perché ma riesco a

1548
01:18:09,040 --> 01:18:11,360
rispondere di no? M è difficile, quindi

1549
01:18:11,360 --> 01:18:15,360
forse forse non è di corivo. Ok? E di

1550
01:18:15,360 --> 01:18:18,760
fatto si può dimostrare che LNE non è un

1551
01:18:18,760 --> 01:18:23,520
linguaggio ricorsivo. Ok?

1552
01:18:24,320 --> 01:18:26,600
Si dovrebbe dimostrare con la solita

1553
01:18:26,600 --> 01:18:29,120
cosa dimostrazione per assurda eccetera

1554
01:18:29,120 --> 01:18:31,960
bla. Quello che noi facciamo invece è

1555
01:18:31,960 --> 01:18:37,639
che dimostriamo che LNE non è ricorsivo

1556
01:18:37,639 --> 01:18:39,679
tramite

1557
01:18:39,679 --> 01:18:43,719
una riduzione. Ok? Se vogliamo

1558
01:18:43,719 --> 01:18:49,960
dimostrare che LNE non appartiene a R,

1559
01:18:49,960 --> 01:18:51,679
LNE

1560
01:18:51,679 --> 01:18:54,360
dovrà essere il il problema di

1561
01:18:54,360 --> 01:18:56,199
destinazione

1562
01:18:56,199 --> 01:18:58,639
di una riduzione

1563
01:18:58,639 --> 01:19:02,600
da un problema di partenza che non sia

1564
01:19:02,600 --> 01:19:06,920
R. Ok? Se io voglio dimostrare che lne

1565
01:19:06,920 --> 01:19:11,760
non appartiene a R, devo ridurre a LNE

1566
01:19:11,760 --> 01:19:16,040
un problema che so non essere iner ok?

1567
01:19:16,040 --> 01:19:17,960
Per la proprietà del teorema che abbiamo

1568
01:19:17,960 --> 01:19:21,440
visto prima. Quindi, se io

1569
01:19:21,440 --> 01:19:25,440
se io riduco un problema indecidibile a

1570
01:19:25,440 --> 01:19:28,440
LNE, allora lne lo dovrà essere pure.

1571
01:19:28,440 --> 01:19:32,360
Ok? Come problema di sorgente prendiamo

1572
01:19:32,360 --> 01:19:39,120
le Ok? Quindi dimostreremo che lne

1573
01:19:39,120 --> 01:19:44,040
è indecidibile perché ridurremo Llu a

1574
01:19:44,040 --> 01:19:46,040
LN.

1575
01:19:46,040 --> 01:19:49,040
Ok?

1576
01:19:49,520 --> 01:19:51,480
Wah! Dobbiamo fare tutto in 10 minuti.

1577
01:19:51,480 --> 01:19:54,280
Spero che ce la facciamo perché qua

1578
01:19:54,280 --> 01:19:58,639
arriva l'intrigasì. Ok.

1579
01:19:58,960 --> 01:20:01,199
processo che è quello che faccio io

1580
01:20:01,199 --> 01:20:03,239
nella mia testa e vi suggerisco di

1581
01:20:03,239 --> 01:20:06,840
seguire. Dobbiamo ridurre lu a ln. Ok?

1582
01:20:06,840 --> 01:20:09,159
Vedete il simbolo maggiore uguale?

1583
01:20:09,159 --> 01:20:12,280
Minore uguale. Ecco, una delle ragioni

1584
01:20:12,280 --> 01:20:14,840
per cui usiamo minore uguale perché

1585
01:20:14,840 --> 01:20:17,639
mette una relazione fra la decidibilità

1586
01:20:17,639 --> 01:20:19,520
dei problemi.

1587
01:20:19,520 --> 01:20:22,840
Ed è facile da ricordarselo così.

1588
01:20:22,840 --> 01:20:26,239
Siccome scritto così significa che lne è

1589
01:20:26,239 --> 01:20:29,239
almeno difficile quanto lu se lu è

1590
01:20:29,239 --> 01:20:32,080
indecidibile allora lne è indecidibile.

1591
01:20:32,080 --> 01:20:33,639
Io così me lo ricordo minore o uguale

1592
01:20:33,639 --> 01:20:37,520
che c'ha quel significato. Ok?

1593
01:20:37,520 --> 01:20:40,880
Ok. Dobbiamo ridurre lu a ln. Qual è il

1594
01:20:40,880 --> 01:20:44,400
problema di partenza?

1595
01:20:45,719 --> 01:20:49,080
Dai su che abbiamo solo 10 m

1596
01:20:49,080 --> 01:20:52,520
è me lo scrivo da questo lato. Vi faccio

1597
01:20:52,520 --> 01:20:56,960
vedere proprio come le faccio io. Eh,

1598
01:20:58,000 --> 01:21:01,080
qual è il problema di arrivo?
Ln.
Ln e

1599
01:21:01,080 --> 01:21:03,960
me lo scrivo di qua.

1600
01:21:03,960 --> 01:21:06,960
Ok.

1601
01:21:07,239 --> 01:21:10,800
Quali sono le istanze del problema di

1602
01:21:10,800 --> 01:21:12,600
partenza?

1603
01:21:12,600 --> 01:21:18,040
e m
coppie macchine e stringhe Mw.

1604
01:21:18,040 --> 01:21:21,600
Quali sono le istanze del problema di

1605
01:21:21,600 --> 01:21:23,480
arrivo?

1606
01:21:23,480 --> 01:21:25,159
Macchine.

1607
01:21:25,159 --> 01:21:27,280
Gli diamo un nome diverso per non

1608
01:21:27,280 --> 01:21:31,960
confonderci, ok? Chiamiamolo m'.

1609
01:21:31,960 --> 01:21:35,120
Quindi la riduzione che è una

1610
01:21:35,120 --> 01:21:36,960
trasformazione, io faccio proprio così,

1611
01:21:36,960 --> 01:21:38,400
eh, me le scrivo da un lato e

1612
01:21:38,400 --> 01:21:40,719
dall'altro, senò confondersi diventa

1613
01:21:40,719 --> 01:21:43,320
semplicissimo.

1614
01:21:43,320 --> 01:21:46,199
La riduzione che deve fare? Deve

1615
01:21:46,199 --> 01:21:49,840
prendere coppie, macchine e stringhe e

1616
01:21:49,840 --> 01:21:55,040
ottenere una macchina M'

1617
01:21:55,040 --> 01:21:59,560
che dipende da M e W. Ok?

1618
01:21:59,560 --> 01:22:02,120
È chiaro? Questo fa la riduzione. La

1619
01:22:02,120 --> 01:22:06,320
riduzione deve essere calcolabile

1620
01:22:06,719 --> 01:22:09,239
ovviamente

1621
01:22:09,239 --> 01:22:13,679
e deve deve soddisfare la proprietà

1622
01:22:13,679 --> 01:22:15,560
della risposta

1623
01:22:15,560 --> 01:22:22,480
e cioè che se mw è un'istanza,

1624
01:22:22,480 --> 01:22:25,600
quindi se Mw

1625
01:22:25,600 --> 01:22:29,040
appartiene ad LU, allora

1626
01:22:29,040 --> 01:22:30,800
f(mvw

1627
01:22:30,800 --> 01:22:32,800
V

1628
01:22:32,800 --> 01:22:37,480
deve essere un M'O che appartiene a Lne

1629
01:22:37,480 --> 01:22:40,880
e inoltre che se Mw

1630
01:22:40,880 --> 01:22:44,080
non appartiene a Lu, allora il

1631
01:22:44,080 --> 01:22:47,560
trasformato della coppia deve essere un

1632
01:22:47,560 --> 01:22:52,639
M'O che non appartiene a Ln. Ok? Queste

1633
01:22:52,639 --> 01:22:55,960
sono le cose.

1634
01:22:55,960 --> 01:22:58,159
Chiaro?

1635
01:22:58,159 --> 01:23:02,199
Quand'è che MW è un'istanza s di lu?

1636
01:23:02,199 --> 01:23:04,600
Quando la macchina

1637
01:23:04,600 --> 01:23:07,639
Sì. Quand'è che M prim' è un'istanza s

1638
01:23:07,639 --> 01:23:10,840
di lne?

1639
01:23:12,840 --> 01:23:16,520
Quando accetta qualcosa. Ok.

1640
01:23:16,520 --> 01:23:20,080
Qual è quand'è che Mw è un'istanza no

1641
01:23:20,080 --> 01:23:23,080
di?

1642
01:23:27,560 --> 01:23:31,199
Quando M non accetta W, quand'è che M' è

1643
01:23:31,199 --> 01:23:35,440
un'istanza? No, di lne

1644
01:23:37,360 --> 01:23:41,960
quando
quando m' dice no su tutto. Ok?

1645
01:23:41,960 --> 01:23:44,639
Quindi la funzione f deve essere una

1646
01:23:44,639 --> 01:23:47,520
funzione che prende in input una coppia

1647
01:23:47,520 --> 01:23:51,400
MW, sputa fuori una macchina M' che

1648
01:23:51,400 --> 01:23:55,760
dipende da MW. ed è tale per cui la m'

1649
01:23:55,760 --> 01:23:59,000
che otteniamo mantiene questa relazione

1650
01:23:59,000 --> 01:24:01,560
fra le stanze. Se riusciamo a ottenere

1651
01:24:01,560 --> 01:24:04,400
questo, allora

1652
01:24:04,400 --> 01:24:09,639
lne è indecidibile. Ok?

1653
01:24:10,520 --> 01:24:14,800
Questa è la

1654
01:24:14,800 --> 01:24:17,280
riduzione che vi propongo che ci sta

1655
01:24:17,280 --> 01:24:20,280
anche

1656
01:24:20,560 --> 01:24:24,040
abbiamo una coppia MW,

1657
01:24:24,040 --> 01:24:27,199
otteniamo un M prim' in questo modo.

1658
01:24:27,199 --> 01:24:32,600
Partendo da MW otteniamo M' fatta così.

1659
01:24:32,600 --> 01:24:37,040
Non c'è spazio, no? Ovviamente

1660
01:24:40,239 --> 01:24:43,920
lo mettiamo qua, dai.

1661
01:24:45,000 --> 01:24:46,960
È chiaro? Adesso lo sto facendo grafico,

1662
01:24:46,960 --> 01:24:48,639
però la funzione di trasformazione che

1663
01:24:48,639 --> 01:24:53,080
fa? Prende la coppia di Mw e tira fuori

1664
01:24:53,080 --> 01:24:56,639
un M' che dipende da MW e deve

1665
01:24:56,639 --> 01:24:58,639
dipenderci avendo quelle proprietà

1666
01:24:58,639 --> 01:25:00,280
specifiche.

1667
01:25:00,280 --> 01:25:03,920
Allora, m' fa questo,

1668
01:25:03,920 --> 01:25:08,560
riceve un certo input, ok?

1669
01:25:08,560 --> 01:25:12,239
E cosa fa? Lo ignora.

1670
01:25:12,239 --> 01:25:14,040
Cioè poi riceve per l'input non gliene

1671
01:25:14,040 --> 01:25:17,679
frega una mazza, cioè nemmeno lo fa

1672
01:25:17,679 --> 01:25:21,840
tutt'altro. Che cosa fa?

1673
01:25:21,840 --> 01:25:25,560
Scrive w sul nastro.

1674
01:25:25,560 --> 01:25:26,880
Abbiamo visto ieri che è una cosa

1675
01:25:26,880 --> 01:25:31,280
possibile da fare. Quale W scrive?

1676
01:25:31,280 --> 01:25:33,159
Questa.

1677
01:25:33,159 --> 01:25:36,760
Ok? Perché M' è una macchina ottenuta

1678
01:25:36,760 --> 01:25:38,639
partendo da questa coppia, quindi la

1679
01:25:38,639 --> 01:25:40,520
costruzione di questa macchina dipende

1680
01:25:40,520 --> 01:25:44,000
da questi due elementi. Quindi M' è una

1681
01:25:44,000 --> 01:25:47,440
macchina che il suo input proprio non

1682
01:25:47,440 --> 01:25:52,320
gliene importa niente. Scrive W nastro.

1683
01:25:52,320 --> 01:25:56,280
Ma che è W? è questa qua. Dopodiché

1684
01:25:56,280 --> 01:25:59,040
esegue

1685
01:25:59,040 --> 01:26:00,639
M.

1686
01:26:00,639 --> 01:26:07,280
Ok? Se M dice sì, allora risponde sì.

1687
01:26:07,800 --> 01:26:10,000
Quindi

1688
01:26:10,000 --> 01:26:11,679
scoriamo di qualche minuto, cerchiamo di

1689
01:26:11,679 --> 01:26:13,920
stare attenti. Ok, abbiamo preso la

1690
01:26:13,920 --> 01:26:16,199
coppia M.

1691
01:26:16,199 --> 01:26:19,800
La funzione fendo

1692
01:26:19,800 --> 01:26:22,679
dalla coppia genera una macchina M

1693
01:26:22,679 --> 01:26:24,840
primo. Genera una macchina M primo, che

1694
01:26:24,840 --> 01:26:26,840
significa? Sputa fuori una funzione di

1695
01:26:26,840 --> 01:26:29,199
transizione per una macchina M'. Questa

1696
01:26:29,199 --> 01:26:31,840
macchina M' è una macchina particolare,

1697
01:26:31,840 --> 01:26:34,880
è una macchina che

1698
01:26:34,880 --> 01:26:37,480
ignora il proprio input, non gliene

1699
01:26:37,480 --> 01:26:42,159
frega niente, scrive sul nastro w quale

1700
01:26:42,159 --> 01:26:44,239
la whe

1701
01:26:44,239 --> 01:26:46,000
in input alla funzione di trasformazione

1702
01:26:46,000 --> 01:26:48,719
f, dopodiché esegue la funzione di

1703
01:26:48,719 --> 01:26:51,320
transizione di n sulla w che si è appena

1704
01:26:51,320 --> 01:26:53,679
scritta da solo, ok? E alla fine dà la

1705
01:26:53,679 --> 01:26:56,480
stessa risposta. Ok?

1706
01:26:56,480 --> 01:26:58,480
Dobbiamo vedere se ora la proprietà

1707
01:26:58,480 --> 01:27:02,760
della riduzione vale.

1708
01:27:03,440 --> 01:27:09,040
Supponiamo che MW sia un'istanza s di l

1709
01:27:09,040 --> 01:27:13,239
che significa che M

1710
01:27:13,239 --> 01:27:17,719
accetta w. Ok?

1711
01:27:21,280 --> 01:27:23,960
Guardate m'

1712
01:27:23,960 --> 01:27:26,400
se m

1713
01:27:26,400 --> 01:27:29,080
qua qua qui c'è ok lo rivedremo tante

1714
01:27:29,080 --> 01:27:30,280
volte quindi ci sarà modo di

1715
01:27:30,280 --> 01:27:33,320
specificarlo. Noi dobbiamo mostrare che

1716
01:27:33,320 --> 01:27:36,199
questa proprietà vale se solo se nel

1717
01:27:36,199 --> 01:27:43,480
senso che se Mw è un'istanza s di luas

1718
01:27:43,480 --> 01:27:46,880
secondo f è un m' che è un'istanza s di

1719
01:27:46,880 --> 01:27:52,400
ln. Se la coppia MW è un'istanza no di

1720
01:27:52,400 --> 01:27:55,360
lu, allora la sua trasformazione è un

1721
01:27:55,360 --> 01:27:58,199
m'o che è un'istanza no di ln. Ecco

1722
01:27:58,199 --> 01:28:00,159
perché abbiamo necessità di guardare le

1723
01:28:00,159 --> 01:28:02,159
due cose, ok? Perché noi dobbiamo

1724
01:28:02,159 --> 01:28:04,920
mostrare che il mapping tramite f di

1725
01:28:04,920 --> 01:28:08,280
istanze sta mappando istanze sì su

1726
01:28:08,280 --> 01:28:10,480
istanze sì e istanze no su istanze no.

1727
01:28:10,480 --> 01:28:13,040
Ok? Quindi non ci stiamo andando a

1728
01:28:13,040 --> 01:28:16,000
curare della decidibilità in sé dei

1729
01:28:16,000 --> 01:28:18,320
linguaggi, ci stiamo andando a curare se

1730
01:28:18,320 --> 01:28:21,000
la trasformazione mappi istanze sì su

1731
01:28:21,000 --> 01:28:22,840
istanze sì e istanze non su istanze no.

1732
01:28:22,840 --> 01:28:25,920
Ok? Quindi vediamo il caso delle istanze

1733
01:28:25,920 --> 01:28:29,239
sì. Supponiamo che MW sia un'istanza s

1734
01:28:29,239 --> 01:28:32,400
di luaggio

1735
01:28:32,440 --> 01:28:35,800
di M' cosa accetta M' o cosa non

1736
01:28:35,800 --> 01:28:38,800
accetta?

1737
01:28:39,119 --> 01:28:41,800
Mh.
Sempre.

1738
01:28:41,800 --> 01:28:45,639
Attenzione, attenzione.

1739
01:28:46,199 --> 01:28:49,760
Input, chiamiamolo, dai, chiamiamolo X.

1740
01:28:49,760 --> 01:28:53,239
L'input di M'O chi è?

1741
01:28:53,239 --> 01:28:54,840
X.

1742
01:28:54,840 --> 01:28:59,880
m' su X risponde sì se

1743
01:28:59,880 --> 01:29:03,000
se M accetta w
se M accetta w. Ok?

1744
01:29:03,000 --> 01:29:08,679
Quindi se Mw è un'istanza s di LO

1745
01:29:08,679 --> 01:29:13,520
che linguaggio accetta M prim?

1746
01:29:15,920 --> 01:29:20,000
Ogni X.
Accetta ogni X. M' risponde sì

1747
01:29:20,000 --> 01:29:22,800
su tutto perché se ne forte dell'input

1748
01:29:22,800 --> 01:29:26,520
suo dà la risposta di M su w. Però

1749
01:29:26,520 --> 01:29:29,040
siccome m stiamo assumendo che accetti

1750
01:29:29,040 --> 01:29:32,159
W, m' sì su qualsiasi cosa ci sta

1751
01:29:32,159 --> 01:29:34,880
dentro. Ok? Quindi

1752
01:29:34,880 --> 01:29:37,880
il linguaggio di m' in questo caso è

1753
01:29:37,880 --> 01:29:40,719
l'insieme di tutte le stringhe che è un

1754
01:29:40,719 --> 01:29:44,880
linguaggio non vuoto. Quindi m' accetto

1755
01:29:44,880 --> 01:29:48,760
un linguaggio non vuoto. Ok?

1756
01:29:48,760 --> 01:29:53,960
Quindi se M accetta w v la funzione f ha

1757
01:29:53,960 --> 01:29:58,080
sputato fuori in output. una macchina M'

1758
01:29:58,080 --> 01:30:01,080
il cui linguaggio è non vuoto, che è

1759
01:30:01,080 --> 01:30:04,400
quello che volevamo.

1760
01:30:04,400 --> 01:30:06,760
Altro verso della riduzione.

1761
01:30:06,760 --> 01:30:11,360
Assumiamo che Mw non appartiene a Lu.

1762
01:30:11,360 --> 01:30:16,000
Qual è il linguaggio accertato da M'?

1763
01:30:16,520 --> 01:30:20,000
m' che è ottenuto dalla trasformazione

1764
01:30:20,000 --> 01:30:22,719
F. Non è che M' è una cosa a casa.

1765
01:30:22,719 --> 01:30:26,080
Supponiamo che MW sia un'istanza no. La

1766
01:30:26,080 --> 01:30:29,320
diamo in pasto ad f. F macchina sopra,

1767
01:30:29,320 --> 01:30:33,119
tira fuori M primo. Sto M' che ha tirato

1768
01:30:33,119 --> 01:30:35,199
fuori, sapendo che partivamo da

1769
01:30:35,199 --> 01:30:37,639
un'istanza, no, di LO, che proprietà ha?

1770
01:30:37,639 --> 01:30:39,880
Qual è il linguaggio di M'O?

1771
01:30:39,880 --> 01:30:42,939
[Musica]

1772
01:30:43,840 --> 01:30:48,040
Eh,
è vuoto perché M'O ignora il suo

1773
01:30:48,040 --> 01:30:51,239
input e dà la risposta di m su w. Ma m

1774
01:30:51,239 --> 01:30:53,719
su w stiamo dicendo che stiamo partendo

1775
01:30:53,719 --> 01:30:55,960
da un stanza no, quindi dirà no su

1776
01:30:55,960 --> 01:30:58,719
tutto. Ok?

1777
01:30:58,719 --> 01:31:00,880
Da ciò

1778
01:31:00,880 --> 01:31:04,520
abbiamo che il linguaggio di M' è il

1779
01:31:04,520 --> 01:31:06,880
linguaggio vuoto.

1780
01:31:06,880 --> 01:31:09,080
Quindi, siccome siamo in grado di

1781
01:31:09,080 --> 01:31:12,360
mappare istanze sì di LU su istanze sì

1782
01:31:12,360 --> 01:31:15,920
di LNE e istanze no di lu su istanze no

1783
01:31:15,920 --> 01:31:17,760
di LNE, vuol dire che esiste una

1784
01:31:17,760 --> 01:31:22,639
riduzione da LU a LNE tale per cui LNE

1785
01:31:22,639 --> 01:31:26,440
non è ricordivo perché Lu non lo è.

1786
01:31:26,440 --> 01:31:29,280
Chiaro?

1787
01:31:29,840 --> 01:31:33,360
Ultima cosa, ultima cosa, così poi non

1788
01:31:33,360 --> 01:31:37,360
finiamo. Quindi abbiamo che

1789
01:31:37,360 --> 01:31:40,119
quest R questo R

1790
01:31:40,119 --> 01:31:43,119
ln

1791
01:31:44,880 --> 01:31:48,239
e che è il linguaggio

1792
01:31:48,239 --> 01:31:50,480
delle macchine che non accettano niente.

1793
01:31:50,480 --> 01:31:54,560
Quindi mi tale che il linguaggio di mi è

1794
01:31:54,560 --> 01:31:58,920
vuoto. Noi abbiamo che le è l'opposto di

1795
01:31:58,920 --> 01:32:02,920
Ln. Ok?

1796
01:32:04,199 --> 01:32:05,360
Abbiamo il complemento, stiamo

1797
01:32:05,360 --> 01:32:07,400
considerando il complemento di lne, solo

1798
01:32:07,400 --> 01:32:08,760
che gli abbiamo dato un nome, lo

1799
01:32:08,760 --> 01:32:12,679
chiamiamo L. Quindi se Lne sta in R e

1800
01:32:12,679 --> 01:32:16,080
non in R, che possiamo dire di L?
Che

1801
01:32:16,080 --> 01:32:21,159
sta fuori re
che sta fuori re perché?

1802
01:32:23,639 --> 01:32:25,159
Come?

1803
01:32:25,159 --> 01:32:26,840
Perché altrimenti sarebbero entrambi in

1804
01:32:26,840 --> 01:32:30,600
R, quindi L qua. Ok?

1805
01:32:30,600 --> 01:32:32,440
Chiaro? È chiaro il concetto di

1806
01:32:32,440 --> 01:32:33,880
riduzione? Perché è una cosa che la

1807
01:32:33,880 --> 01:32:38,360
useremo quasi ogni volta. Ok? Grazie

1808
01:32:38,360 --> 01:32:42,239
mille. Buona giornata.