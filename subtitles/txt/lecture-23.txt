[Musica] Ok, oggi andiamo un po' avanti. Questo è vista tutta vista, non vista, vista. Teorema di Cook l'avete capito? Era difficile, eh. [Musica] Si capiva, eh, era digeribile. Ok, spero di averlo infatti rimodulato in un formato che fosse comprensibile. Ok, quindi oggi andiamo un po' avanti, iniziamo a vedere cose nuove. Ok. Definizione di classe NP. Cosa ci sta in NP? Se vede che ci sta in NP. I problemi di di decisione problemi di decisione polinomiale deterministico. Ok? Il check è deterministico. Ok? Consideriamo, quindi lo ricordate tutti, quindi cos'è? NP. Ok, consideriamo questo problema. data una formula f è una formula in CNF non soddisfacile. Ok? Quindi il linguaggio ANSAT è il linguaggio simile a SAP che è l'insieme delle stringhe che codificano formule buleane in CNF che non siano soddisfacbili. Ok? Che significa che una formula è non soddisfacbile? Che non esiste un segnamento di variabili tale che la formula sia. Esattamente. Ok. Questo problema sta in NP. Prendetemi un po' di tempo per pensare. Sì, sì, perché SAT è decidibile e quindi anche e ha un SAAT che è il problema dovrebbe essere decidibile. Eh, è indecidibile, ma la mia domanda non è se Ansat è decidibile o meno. La mia domanda è: ma Ansat sta in NP? Per stare in NP ci deve stare una macchina non deterministica che è in grado di decidere il problema in tempo polinomiale. Siamo in grado di farlo? Ah! Ah! Ok. E se invece noi che avete sentito il commento del nostro collega è no, non è NP perché per e per rispondere sì la formula non è soddisfacile, allora noi dovremmo essere sicuri che qualsiasi assegnamento di verità che eh noi possiamo dare alle variabili che compaiono nella formula, qualsiasi assegnamento di verità non la soddisfa e quindi noi non è che lo possiamo gessare. Ok? Ma questo è un ragionamento che ci sta, eh, che dice "Ok, questo approccio è è non è non perseguibile". Ok. Che ne pare di questa macchina? Noi gessiamo un assegnamento di verità, ok? Per le variabili nella formula. Poi verifichiamo che non soddisfa la formula e rispondiamo sì. Questa cosa funzionerebbe? Facciamo un guess di un assegnamento di verità per le variabili della formula. Verifichiamo che l'assegnamento non soddisfi la formula e poi rispondiamo sì. Questo questa macchina decide Ansat o no? No. No. Sì. No. No. Cosa decide? se esiste affazione qualsiasi e decide se questa macchina decide se dato esiste una formula mette un assegnamento che non la soddisfa. Ok? Quindi se noi chiamiamo tautologi l'insieme delle tautologie, no? l'insieme delle formule F in CNF che sono tautologie. Vi ricordate cos'è una formula tautologica? Qualsiasi assegnamento di verità la soddisfi. Ok? Quindi una macchina che faccia un guess di un assegnamento per la formula fifica che questo assegnamento non soddisfa F, in realtà sta decidendo il complemento di Tautology. Ok? Quindi è un problema di rilievo o meno, dipende un po' da quello che ci serve, però questa macchina, ok? cheessa un assegnamento di verità e verifica che la formula non è soddisfatta, in realtà sta semplicemente decidendo il complemento del linguaggio delle tautologie. Ok? In effetti questo problema è un po' particolare, come ci diceva il nostro collega, noi non è che possiamo rispondere sì se troviamo un assegnamento di verità che soddisf che non soddisfa la formula. Noi possiamo rispondere sì, questa formula file non è soddisfaci tutti gli assegnamenti, l'intrizione è questa, e se tutti gli assegnamenti alle variabili buuleane che costituiscono fai non soddisfino la formula. Ok? Quindi in qualche modo noi vorremmo che tutti i patione di questa macchina non deterministica siano rifiutanti per poter dire sì. Sì, questa formula non è soddisfacile quando sappiamo che in qualsiasi modo proviamo a gessare non siamo mai in grado di soddisfarlo. Ok? Allora, in effetti questo problema che è un po' particolare è un esempio di una classe diversa da NP che introduciamo ora ed è la classe CNP. Che cos'è la classe QNP? Similmente a come avevamo definito CO R. La classe CNP è la classe dei linguaggi L i cui complementi stanno in NP. Ok? Questa è la definizione di CNP. ci stanno tutta una serie di problemi interessanti, però sostanzialmente questa classe è definita come i complementi dei linguaggi in NP. Ok? Quindi, ad esempio, ansat è un problema della classe CNP perché il suo complemento, il complemento di Ansat e SAT sta in NP. Ok? intuitivamente. Allora, una cosa importante è che con NP non è il complemento di NP, ok? Perché cosa sarebbe il complemento di NP? Supponiamo qua di avere R - NP, come R - NP, sì. E tutto quello il complemento di NP sarebbe tutto quello che sta fuori NP tra cui R, le cose R fuori R e tutto quello che non sta in NP. Quindi con NP non è il complemento di NP, esattamente come non era il complemento di R. CNP è definito in maniera similate a Creed è l'insieme dei linguaggi i cui complementi stanno in NP. Quindi unsatisfiability, che è il contrario di satisfyability è un problema che sta dentro con NP. Ok? Adesso i linguaggi, l'intuizione che noi possiamo avere per i linguaggi in NP è sostanzialmente speculare di quello che abbiamo per NP. Un linguaggio sta in cpiste, se le sue istanze no sono caratterizzate da un certificato. Ok? Allora, in NP, adesso vediamo un esempio. In NP abbiamo i linguaggi le cui istanze sì ammettono un certificato per dire di sì. In CNP ci stanno i linguaggi le cui istanze no ammettono un certificato per dire di no. Cioè, noi siamo in grado di rispondere no gessando qualcosa. Prendiamo unsatisfiability. Data una formula buleana f in CNF dobbiamo stabilire se sia soddisfacbile o meno. Ok? Se sia non soddisfacile. Questa è la definizione di Anzal. Come facciamo per rispondere no? questa formula non è, cioè questa formula non è non soddisfacbile che siamo un assegnamento che la soddisfa, ok? Quindi questo è il senso. In NP, poiché con NP è definita in questo modo particolare, cioè in CNP ci stanno i complementi dei linguaggi in NP, noi possiamo rimodulare la definizione intuitiva dei linguaggi in CNP come quei linguaggi per i quali abbiamo un certificato conciso per rispondere di no. Quindi in NP ci stanno quei linguaggi che ammettono un certificato conciso per rispondere di sì. In CNP ci stanno quei linguaggi che ammettono un certificato conciso per rispondere di no. Adesso ad esempio tautologi. Il problema delle tautologia dato una formula buleana in CNF. Decidere se sia un'auto meno. Dove sta? In NP o in cof? Prendetevi un attimo del tempo. Sì, perché quindi tautologia sta in perché perché sto complimento. Sì, ci deve essere un falso. Esattamente. Sì, tautology. Il problema delle tautologie sta in CNP perché per riconoscere le sue istanze, no, cioè le formule che non sono delle tautologie è sufficiente per noi dessare che cosa? Un assegnamento che non la soddisfa. Ok? Quindi i linguaggi NP possono essere risolti ghessando qualcosa che ci permette di dire di sì. I linguaggi in co sono quei linguaggi per i quali noi possiamo ghessare qualcosa per rispondere di no. Ok? Questo è l'intuizione. Poi, formalmente CNP è definito come l'insieme dei complementi dei linguaggi NP. Tutto qua. Ok? Però l'intuizione per poterci lavorare è questa. Se io gesso per rispondere sì, quel linguaggio sta in NP. Se io gesso per rispondere di no, quel linguaggio sta in QNP. Eh, questo è l'ho. Ok. Allora, quello che noi ci chiediamo ora è vedere un po' la relazione che ci sta fra con NP ed NP. Ricordate che qualche un po' di lezioni fa facemmo tutto uno studio sulle relazioni fra re e co ok? riuscimmo a dire parecchio, riuscimmo a dire che co è diverso da R. riuscimmo a dire che l'intersezione di co R è, seguiamole qua. Allora, cosa riuscimmo a dire? Riuscimmo a dire che co re ed sono due classi distinte. Siamo riusciti pure a dire che l'intersezione di coe ed re è esattamente r. Ok? Quello che adesso noi ci chiediamo è che relazione ci sta fra NP co NP e P. Ok? Quindi noi abbiamo quest'altra situazione ora con NP NP eh un po' piccolino un po' più grande da da co NP NP. Vogliamo stabilire un po' qual è la loro relazione e la relazione con eventualmente P, cioè se P sta qui, sta qui o no, se occupa tutto lo spazio, se è un sottoinsieme, eccetera. Ok? Allora, a differenza delle relazioni tra R ed R, che le conosciamo, le relazioni fra NP con NP e P sono aperte, nessuno sa niente. Ok? Noi sappiamo questa cosa qua. Noi non sappiamo, come primo elemento, noi non sappiamo se NP e CNP siano due classi distinte o meno. Cioè noi non sappiamo questa cosa qui. C NP è uguale o no ad NP. Questo qui è un problema aperto esattamente come P versus NP. Esattamente come noi non sappiamo nulla riguardo l'inclusione stretta fra P NP. Noi non sappiamo nulla nella relazione fra CNP ed NP. Cioè, noi non lo sappiamo se queste eh se queste classiano distinte o meno. Nessuno non è mai riuscito a dimostrare che queste due classiano uguali, ma nessuno non è mai riuscito a dimostrare che queste due classiano distinte. Abbiamo dei risultati, adesso ne vedremo uno, che legano un po' come siano legate NP e CNP, però più di questo non siamo in graviglia. Prego. Quindi con NP non neanche se NFA NP. Adesso diciamo. Sì. Allora, un teorema, un risultato che noi siamo stati in grado di eh cioè che la comunità è riuscita a risolvere è il seguente teorema. NP è uguale a CNP se e solo se esiste un linguaggio L NP completo tali che L appartenga a con NP. Cioè questa è una cosa che siamo in grado di dimostrare. Ok? Noi abbiamo quindi che semmai un linguaggio L NP completo si trova in NP, allora avremo che NP è uguale a PNP. Ok? Allora, poi faremo dei commenti a riguardo, però l'intuizione sostanzialmente qual è? e che noi ci aspettiamo che queste due classiano distinte perché nel momento in cui uno dei problemi tosti di NP, che sono i problemi NP completi che sono i quali sono i problemi i quali sono in grado di codificare tutti i problemi dentro NP perché esistono riduzioni da ogni problema linguaggio NP completo. mai un problema NP completo si dovesse trovare dentro con NP, allora queste due classi sono uguali. Ok? Questo è sostanzialmente che possi quello che possiamo dire. La cosa interessante è che nessuno è mai riuscito a dimostrare l'esistenza di un linguaggio NP completo che sia anche in quel quindi è una questione aperta anche questa dagli anni 60 mi pare, e nessuno è mai riuscito a mostrare né che i linguaggi NP completi possono essere in QNP né che non lo possano essere. semplicemente non lo sappiamo e siccome nessuno c'è mai riuscito, iniziamo a ipotizzare che questo non sia il caso, cioè la nostra ipotesi è che NP ed e CNP siano due classi distinte perché nessuno è mai riuscito a mostrare un linguaggio NP completo che sia anche in qu NP. Questa è l'intuizione. Ok? Però ora dimostriamo questo questo risultato. Ok? Quindi noi dobbiamo dimostrare che se N np uguale al NP, se è solo se esiste un linguaggio NP completo che appartenga anche alla classe con NP. Allora, primo verso della dimostrazione. Dobbiamo mostrare che se NP è uguale a quel NP, allora esiste un linguaggio NP completo in CNP. Ok? Ma alle volte metto il trattino, alle volte no. È la stessa cosa. Ok. Come si può fare? Secondo voi proviamo a guardare il complemento di sotto. Attenzione, attenzione, è molto più facile. Eh, un attimo. Sì, è giar, cioè se se è un problema se un linguaggio NP completo lo c in NP. Anche in NP. Sì, esattamente. È una è una questione di definizione. È proprio semplice. Ok, questo verso della dimostrazione è facile. Se L è NP completo, per definizione L è anche in NP. Ma se NP è uguale a quel NP, allora L deve stare anche in QP. Ok? Quindi questo verso della dimostrazione è semplicissimo. Più complicato è l'altro è questo qua. Se esiste, dobbiamo mostrare che se esiste un linguaggio L NP completo che sia in co NP, allora NP è uguale a CNP. Ok? Per riuscire a dimostrare questa uguaglianza, dobbiamo mostrare che se è vera questa cosa che esiste un linguaggio LP L NP completo che sia NC con NP, allora questa cosa deve valere. Il che significa dobbiamo mostrare che NP è un sottinsieme di co NP e coNP è un sottinsieme di NP. Ok? Quindi dobbiamo fare due due cose. Ok? Allora, prima di partire, noi andiamo a fare queste considerazioni. Primo punto, se L è NP completo, allora L appartiene ad NP, da cui il suo complemento appartiene a QNP. Queste sono semplicemente delle osservazioni iniziali che ci serviranno dopo. D'altro canto, se L appartiene a co NP, allora il suo complemento appartiene a NP. Quindi componiamo questi risultati che abbiamo, quindi abbiamo questo qui e questo qui più questo qui e questo qui. Ok? Quindi in che situazione ci troviamo? ci troviamo nella situazione che qua c'è con NP, qua c'è NP, quindi questo è con NP, questo è NP. E allora abbiamo che L sta nell'intersezione fra NP e co NP, come abbiamo dai pezzettini rossi, ma abbiamo pure che L soprasegnato sta là dentro. Quindi questa è la situazione in cui ci troviamo. Ok? Ok. Allora, quello che ora noi dobbiamo dimostrare è questa cosa qua. Dobbiamo dimostrare, partiamo da certo spazio, sì, da questo elemento qua. Noi mostriamo che NP è un sottinsieme di CNP se valgono le assunzioni iniziali, cioè che esiste un linguaggio L che è NP completo e che sia anche in NP. Ok? Allora, partiamo così. Sia L'O appartenente a NP un linguaggio un linguaggio qualsiasi. Mostriamo che L'ONP. E ciò lo mostriamo facendo vedere che L'O soprasegnato appartiene a NP. Ok? Quindi noi abbiamo un linguaggio L'O qualsiasi che appartiene a NP. Vogliamo mostrare che L'O appartene anche a Qnp, da cui otterremo che NP è un sottinsieme di Qnp. E come mostriamo che come mostreremo che L' appartiene a NP? Lo mostreremo mostrando che il complemento di L'O appartiene ad NP. Ok? Adesso saranno una serie di passaggi di rimanipolazioni di cose eh provenienti da definizione eccetera. Ok? Sì. facendo eh facendo vedere che L'O soprasegnato appartiene ad MP. Allora, primo passaggio, noi abbiamo questa cosa qua. Siccome L'O appartiene ad NP ed inoltre L è NP completo per assunzione complete, abbiamo che L'O si riduce polinomialmente ad L. Ok? Questo qua per assunzioni. Ok? Stiamo semplicemente andando a ritoccare definizioni e giochiamo un po' su queste cose qua. Ok? Adesso questa è una riduzione polinomiale. Se L'O si riduce a L, che cosa possiamo cosa possiamo dire? che esiste una funzione di trasformazione fasforma stringhe verso stringhe tale per cui per ogni stringa W appartiene ad L'O è solo se il trasformato secondo f di w appartiene A L. Ok? Questa è la definizione di trasformazione di di riduzione. Ok? Però siccome questa relazione vale come un sé e solo sé, noi la possiamo scrivere anche in quest'altro modo. Quindi per ogni per ogni V non appartiene a L' è solo se F non appartiene ad L. Ok, qua la pagina è finita. Questo possiamo riscriverlo ancora in un'altro modo da cui doppia per ogni w appartiene a L'O segnato se è solo se FB appartiene a L segnato. Ok, stiamo invertendo tutto. Cosa ci dice questa cosa qua? che L primo segnato è riducibile polinomialmente a L. A L segnato. Sì. Quindi noi possiamo dire che esiste una riduzione da L'O segnato verso L segnato. Ok? N segnata, insomma. Allora, che cosa abbiamo? Noi abbiamo che è L eh Ok, questo L qui appartiene a CNP. Ok? Ma il suo complemento, cioè questi due stanno sia in co che in NP, da cui io posso prendere che questo linguaggio qua, L soprasegnato che è lui sta dentro NP. Quindi esiste una riduzione dal complemento di L'O al complemento di L che è un linguaggio in NP. Scriviamolo dall'altro partio. Ok? Noi abbiamo che L soprasegnato appartiene a NP. Da cosa? Da quelle osservazioni che avevamo fatto all'inizio si vede dalla figurella, ok? L soprassegnato sta in NP. Da cui abbiamo che L'O soprasegnato si riduce a un linguaggio che sta in NP. Quindi abbiamo cosa? abbiamo che L'O soprasegnato si riduce a L soprassegnato e lui appartiene a NP. Quindi se L'O soprasegnato si riduce a un linguaggio che sta in NP, anche L'O soprasegnato sta in NP, da cui L'O soprasegnato appartiene a NP, ma questo era quello che ci serviva all'inizio per mostrare che L'O soprasegnato appartiene a L'. Ok? abbiamo un po' giocato con le definizioni. Tutto qua. L'unica osservazione importante di tutta questa dimostrazione è questa cosa qui, cioè se noi riduciamo, e questo è il pezzo importante, se noi riduciamo polinomialmente un linguaggio e L'O, allora stiamo anche riducendo il suo il complemento di L'O al complemento di L. Questa è tutta la l'osservazione che serve fare in questo pezzo di di dimostrazione. Ok? Quindi, siccome noi abbiamo ottenuto che L'O appartiene ad NP, da questo abbiamo che L'O appartiene a Qnp da cui L'O appartiene L'O appartiene a co NP da cui abbiamo che NP è un sottoinsieme di n di co NP. Ok? Alri, altro pezzettino. Un altro? Sì, quello. Ah, questo. Ok. Altro pezzettino è questo qua. Noi dobbiamo dimostrare che co NP sia un sottoinsieme di NP. Come lo facciamo? sia L'O appartenente a CNP, un linguaggio arbitrario. Mostriamo che L'O appartiene a NP. Ok? Quindi se è un linguaggio L'O qualsiasi di CNP sta anche in NP, allora possiamo dire che co NP è un sottoinsieme di NP. Allora, facciamo un giochino simile a quello che abbiamo visto prima, quindi abbiamo che L'O appartiene a con NP da cui L' soprassegnato appartiene a NP. appartiene a NP. Siccome noi abbiamo che L da sopra abbiamo che L è un linguaggio NP completo e L'O è un linguaggio che appartiene a NP. Seguiamolo qua. Quindi poiché l e NP completo e inoltre sì L'O soprasegnato appartiene a NP. Abbiamo che L'O soprasegnato si riduce a L in maniera polinomiale. Eh, tutte queste riduzioni sono polinomiali. Anche qui è semplicemente un rimaneggiamento di definizioni e cose. Adesso, per quello che abbiamo detto prima, se L'O soprasegnato si riduce a L, allora noi possiamo considerare anche i complementi, cioè noi abbiamo che L'O si riduce polinomialmente a L sovrasegnato. Scusate. Perché L NP concreto? Sì. E inoltre L' appartiene a NP. Ovviamente L'O si deve ridurre a L. Ok? Da questa riduzione noi la possiamo, tra virgolette invertire. Quindi se abbiamo che L'O soprasegnato si riduce a L, allora L'O si riduce polinomialmente a L soprassegnato. Ok? Ma L soprasegnato, come possiamo vedere da qui, sta in NP. abbiamo che L sovrasegnato appartiene a NP da cui L'O appartiene a NP, che è esattamente quello che volevamo ottenere. Sì, avremmo cari dicendo che quando L'assemiato appartiene L, diciamo la parte superiore della maglia. Sì, la prima parte secondo secondo secondo. Eh, la prima parte della dimostrazione diceva che NP è incluso in P, quindi N quadrato che si con P, quindi girato la puntata quadrato primo quadrato. Eh, sì, credo di sì. Sì, che si possa accorciare anche in quel modo. Sì, ottima osservazione. Grazie. Ok, quindi che cosa abbiamo? abbiamo la caratterizzazione di questo teorema che in realtà non ci dice moltissimo, ci dice solamente l'intuizione è questa: semmai noi avessimo un problema NP completo che fa parte di NP, allora queste due classi sarebbero la stessa cosa. Ok? Però in realtà nessuno è mai riuscito a dimostrare che questa cosa sia vera, cioè non siamo mai riusciti a collocare un problema NP completo dentro eh dentro NP. Per questa ragione noi supponiamo supponiamo che le due classi siano distinte, ok? e che quindi questa qui sia sia la situazione. Ok, vediamo cosa ci sta dopo. Una domanda. Quindi dimostrato che nessun problema di qu NPA perché no? Sì, sì, perché se fosse NPG eh se fosse NP argo, allora tutti i problemi di NP si potrebbero ridurre a questo problema in co NP e quindi starebbero tutti là dentro. Quindi nemmeno quello è stato è stato dimostrato. Quello che ci chiediamo ora prima della pausa e poi facciamo pausa è quale relazione ci sia fra P con NP. ed NP. Quindi qua abbiamo CNP, qua ci sta NP e qui c'è P. Ok? Allora, il risultato che abbiamo in questo caso è esattamente è proprio quello che vedete nella nella figura. Noi non sappiamo nemmeno questo. Noi non sappiamo se l'intersezione fra NP e con sia esattamente P o un sovrainsieme di P. Ok? Allora, siccome noi abbiamo che ci sono che se ci fosse un problema NP completo in NP, allora le due classi sarebbero equivalenti e nessuno ha mai dimostrato che questo sia il caso. Allora, noi abbiamo che i problemi che non sono abbiamo quindi un insieme di problemi che per essere in NP e in co NP non possono essere NP completi perché se ci fosse un problema NP completo in co NP avremmo che le due classi sono le stesse. Quindi noi ci attendiamo che nell'intersezione fra NP e con NP ci sono linguaggi non tosti. E in effetti sì, ci sono tutti questi qua. P i linguaggi P sono linguaggi non NP completi che stanno in P, in NP e co NP. Possiamo dimostrarlo in questo modo. Teorema. Cosa abbiamo? abbiamo che P è un sottinsieme di NP e CNP. Allora, la dimostrazione è abbastanza semplice, sia L un linguaggio generico di P, poiché allora il primo pezzo è semplice, poiché L appartiene a P e P è un sottoinsieme di NP, l'abbiamo già visto. Allora N appartiene a NP. Questo era semplicissimo. Ok. Consideriamo il linguaggio L soprassegnato. Ok? L era un linguaggio che stava dentro la classe P. Secondo voi il linguaggio L sovrasegnato in quale classe sta? Sì. Sì. Perché? Perché basterebbe tutta. Esattamente. Siccome L sta in P, quindi c'è una macchina diuring deterministica che in tempo polinomiale decide L. Se noi prendiamo quella macchina di touring e gli andiamo a cambiare gli stati accettanti e non accettanti, li scambiamo, allora quella macchina semplicemente andrà ad accettare L soprassegnato. Ok? Quindi noi abbiamo che L soprasegnato appartiene a P e in particolare proprio per questa ragione la classe P che è una classe deterministica, come tutte le classi deterministiche sono chiuse sotto complemento. Significa che se un linguaggio appartiene a una classe deterministica, il suo complemento appartiene alla stessa classe, ok? Perché basta prendere una macchina, gli scambiamo gli stati accettanti e non accettanti e abbiamo risolto la cosa. Ok? Ma quindi noi avremo da questo da L soprasegnato appartenente a P segue che L sovrasegnato appartiene a NP e quindi L appartiene a come NP. Ok? Quindi questo ci permette di mostrare che P è un linguaggio che i linguaggi, cioè che P è un sottieme dell'intersezione di NP e co NP, però sul fatto se siano eh se siano se l'intersezione di CNP ed NP sia esattamente P, questa è una cosa che anche questo è un problema aperto. Ok? Quindi, a differenza di co re, per i quali noi siamo in grado di stabilire delle relazioni precise fra queste classi, fra NP con NP e P, non lo sappiamo. Sappiamo che P è un sottoinsieme dell'intersezione, sappiamo, però non sappiamo se è esattamente l'intersezione delle due classi, non sappiamo se con NP ed NP coincidano o meno. quello che potrebbe accadere semmai, ok, vediamola qua insieme. Cosa succederebbe se p fosse uguale ad np? Che cosa potremmo dire della loro relazione con con co con co NP? Se P fosse uguale ad NP? Allora, n ugu Allora, con NP sarebbe uguale ad NP, ok? Quindi se P fosse uguale ad NP tutto collasserebbe su P. Però quello che potrebbe accadere ad esempio è avere NP e co NP uguali che però non coincidono a P. Ok? Questa è un'altra situazione che si potrebbe verificare. Non sappiamo se sia così perché nessuno c'ha mai riuscito a risolvere la questione. Quello che si ritiene sia la lo stato dei fatti è che P sia un sottoinsieme stretto dell'intersezione di NP e con NP. Questa è un'ipotesi. Ipotezziamo che sia così perché nessuno è mai riuscito a dimostrare diversamente. E un'altra cosa che ipotizziamo è che NP sia distinto da co però di nuovo questa qui è un'ipotesi perché non abbiamo un risultato certo a riguardo. Ok? Ehm, ok, possiamo fare 10 minuti, un quarto d'ora di pausa. Dov'è? Oggi oggi okam giusto qualche problema. Ok, prima di far questo, giusto un commento. Nella classe CNP ci stanno i problemi tosti di CONP, quindi esistono i problemi CNP ardu che non ansate. Ok? I problemi CNP ardu similmente ai problemi NP hard. sono i problemi almeno difficili quanto tutti i problemi di 2 NP. Questa è sostanzialmente l'intuizione. E un certo problema L è co Np arduo se il suo complemento è NP alo. Tutto qua. Ok? In realtà ci sono un paio di definizioni, uno le può definire anche a tramite le riduzioni, però non è una cosa che di cui ci occuperemo. Quindi esistono i problemi co NP hard, esistono i problemi con NP completi, eccetera, però insomma son cose che non andremo a guardare a guardare nei dettagli, giusto per sapere che ci stanno che similmente problemi in ard ci stanno i problemi coinpi. Ok? Allora, noi abbiamo che le classi con NP, NP e P. Ok, meglio C NP NP. E qua ci sta P. Questa è la relazione che noi crediamo ci sia queste classi. Di conseguenza c'è tutta quest'area qui che sono problemi per i quali non sono né NP completi, quindi non sono problemi tosti, però non sono problemi che nemmeno siamo riusciti a collocare dentro qui. Quindi ci sta una pletola di problemi qua in mezzo che non sono né difficili per quello che abbiamo detto, quindi non siamo riusciti a mostrare che siano problemi NP completi e reputiamo che nemmeno lo siano perché stando qua in mezzo stanno sia in NP che Enco NP. Di conseguenza noi non ci attendiamo che problemi che stanno qua dentro siano NP completi. Ok? Però sono problemi per i quali non siamo nemmeno riusciti a trovare degli algoritmi polinomiali. Quindi c'è un limbo qui di problemi che non sono né tosti né semplici. Ok? E su questi problemi si basano i sistemi di crittografia corrente. Ok? Sono problemi che stanno qua in mezzo. Uno di questo è il problema della fattorizzazione. Ok? Ovviamente il problema della fattorizzazione dato un numero produrre una fattorizzazione in numeri primi è un problema che secondo voi sta in NP? Siete sicuri? Dato un numero intero n produrre una sua fattorizzazione in numeri primi lo possi è una cosa fattibile in NP? No, perché non è un problema di decisione. Eh, attenzione, attenzione. Ok, quindi per analizzare un po' i problemi di fattorizzazione ci dobbiamo inventare una variante decisionale. Ok? La variante decisionale che guardiamo è questa. è l'insieme delle coppie di numeri n K tali che n è un intero naturale che ha almeno un fattore primo. P non superiore a K. Ok? Quindi questa è una definizione, ce ne potrebbero essere anche altre, però una possibile definizione di un problema decisionale basato sul problema della fattorizzazione è dati due numeri n e k. È vero che n ammette un fattore primo di valore al + k? Questa è una variante decisionale. Ok? e eh quindi è candidato a stare nelle nostre classi di complessità che sono classi di complessità di tipo decisionari. Ok? Ad esempio, se noi abbiamo che, che ne so, il numero che è dato da 5 * 5 * 7, avremo che questa coppia appartiene a factor perché 175 ha un numero primo il cui valore è al + 6 che lo divide. Invece 1754 non appartiene a factor perché nessuno dei fattori primi di 175 rientra dentro 4. Ok? Quindi questo è una possibile variante decisionale per eh il problema della fattorizzazione. Ok. Teorema factor appartiene a NP intersecato con NP. Primo pezzo, factor appartiene a appartiene a NP. Come possiamo dimostrare che factor appartena ad NP? Sì, siamo di cosaettino sì ug che sia minore o uguale a K. Ok? Quindi l'idea per dimostrare che fatto appartente alla classe NP, quello che noi facciamo è gessare un fattore primo, quindi gess di un fattore primo P di al + koiccare check. che P sia primo e che P divida N. Ok? Chiaro? Che cosa facciamo? Che siamo un numero primo P. Verifichiamo che questo numero P sia effettivamente primo, poi dividiamo n* p e verifichiamo che p effettivamente divide n. Ok? Siamo sicuri che questa cosa è fattibile in NP? Si può fare in tempo polinomiale? Questa è la domanda. Sì, perché lo indoviniamo poi m ah la divisione sia polinomiale Sì, la la divisione si fa in tempo polinomiale. Ok, un attimo un attimo, non accavallatevi. La divisione del numero di divisione devo fare dipende dal numero estetico, però dipende dalla taglia dei numeri, cioè dalla taglia di n e p. Si può dimostrare, noi lo vediamo, che fare la divisione di due numeri interi si può fare in tempo polinomiale nella taglia degli operandi. Ok? Ma chi ci garantisce? [Musica] che Ok, allora abbiamo due questioni. Uno, ma siamo sicuri che P non sia una cosa troppo grande da gessare? Di questo possiamo essere sicuri? Perché stiamo gessando qualcosa. Sto guess deve essere polinomiale. Prego. Care minore ug minore o uguale a KT o N. Quindi P quando lo chiessiamo non è mai troppo grosso perché è minore sia di n che di k. Ok? Quindi questo gest che noi facciamo è un guess piccolino. Quindi questo può essere fatto in tempo polinomiale. Poi abbiamo due ordini di problemi. È vero che n si può dividere per pi in tempo polinomiale? Sì, si può fa'. La divisione si fa in tempo polinomiale, nella taglia degli operandi. E l'altro test che dobbiamo fare che P sia polinomiale, ok? che sia primo. Il test che P sia primo, ve lo dico io, si fa in tempo polinomiale deterministico. È un risultato del 2003, cioè un algoritmo incasinatissimo, però in n^ 12 si riesce a testare in tempo polinomiale che p sia un numero primo. Ok? Quindi il guess è il guess di una cosa piccola e il check si può fare in tempo polinomiale. Ok? Questo ci permette di dire che il problema factor sta in NP. Ok? Quello che adesso noi dobbiamo mostrare è che factor appartenga a co? Allora, per dimostrare che factor appartiene al CNP, lo mostriamo facendo vedere che il complemento di factor appartenga ad NP, perché questa è la definizione formale che abbiamo, ok? Quindi factor appartiene a con NP se il complemento di factor appartene ad NP. Ok? Innanzitutto ci concentriamo su cosa sia il complemento di factor. Cosa ci sta in questo linguaggio? Dovete prendere factor e negarlo. Un attimo, vediamo se c'è qualcun altro, qualche voce nuova. Un attimo, un attimo. Dov'è la definizione di factor? Ok, dobbiamo prendere il complemento di quel linguaggio. Che cos'è il complemento di factor? Un attimo. Nuovi prego. E allora sempre la copia in capital e anche la partenza di naturale e a questo punto vengo e magari il resto e a questo punto il il fatto che p sia limitato da K lo manteniamo, però non deve esistere. Mh mh. Quindi n è un naturale la cui fattorizzazione eh non contiene eh primi min k e quindi tutti i fattori primi sono maggiori di k i cui fattori primi sono tutti più grandi di K. Mi interessano come che n de anche intero. Sì, sì, sì, sì. N è un naturale e intero. Sì. Più grande di K. Ok. Adesso factor soprassegnato. No, factor soprassegnato. A perché non do ad NP una volta che abbiamo definito che cos'è? Come facciamo a stabilire, dato una coppia NK, dobbiamo stabilire che tutti i fattori primi di n siano più grandi di K. Come lo facciamo? In NP? Sì, possiamo parlando nello stesso modo in cui che siamo T mag> K. Tutti tutti i fattori primi di di n devono essere più grande di K. Se lei ne uno e fa il check, le sta mostrando che un fattore primo è più grati di K. Noi dobbiamo mostrare che tutti sono più grati di K. Sei quorare fattori? Ecco, come si fa a sapere che quello è esattamente più piccolo? Eh, però io l'ho ghesso. È interessante la procedura. Eh, noi che siamo un numero primo, vogliamo essere sicuri che sia il più piccolo fattore di n. Come facciamo a saperlo che non ce ne siano di più piccoli? Dobbiamo fare un altro guess. Possiamo fare il guest di tutti i fattori primi. Possiamo fare il guess della fattorizzazione. Ok? Quindi in questo caso noi che facciamo? Gessiamo tutta la fattorizzazione di n che noi sappiamo essere unica a parte l'ordine dei fattori. Quindi, come si fa? Gess della fattorizzazione di N. Ok? E quindi gessiamo che cosa? P1, P2, bla bla bla bla PM. Ok? Poi che cosa dobbiamo verificare? che il più piccolo sia maggiore o uguale di K, sia maggiore di K. Sì. Ok. E che moltiplicati che siano tutti i primi. Che siano tutti i primi e che moltiplicati tra loro viene effettivamente il numero il numero n. Ok? Quindi abbiamo tre cose da cercare che siano tutti i primi. Quanto tempo ci serve? m * m* m per polinomiale è una cosa polinomiale. Ok? La questione è ma quanti ne stiamo cheando? Sono il numero polinomiale? Cioè questi P1 PM sono tanti, pochi? Sono tantissimi. Allora direi che sono polinomiali sulla taglia. La taglia di chi? del dn. DN. Sì, perché perché questo è detto un po' di non so se benissimo, dai. Il più piccolo numero primo è due. Sì. Quindi al minimo, cioè il numero massimo di fattori che posso avere è se è una e se è 2^ n è una potenza di 2, quindi il male che ci va, noi facciamo 2 * 2 * 2 * 2 * 2. Quelli là sono il numero polinomiale e quindi il numero polinomiale di fattori primi che il numero di fattori primi che siamo male che ci va è polinomiale. Noi possiamo rimanere in quell'ambito. Ok? Quindi sappiamo che m è bounded da un polinomio nella taglia di N. Quanto ci costa testare che sono tutti i primi? Ci costa tempo polinomiale perché dobbiamo fare un numero polinomiale di test polinomiali, ok? Quindi il check che P1, P2, bla bla PN siano polinomiali, si fa in tempo polinomiale. Poi dobbiamo cercare che cosa? che il loro prodotto sia n e la moltiplicazione si può fare in tempo polinomiale nella taglia degli operandi e poi dobbiamo verificare che siano tutti più grandi di K o che il più piccolo sia più grande di K. Comunque si fa anche questo in tempo polinomiale, cioè riscorriamo, facciamo delle verifiche e tutto ciò è fattibile in tempo polinomiale. Ok? Da ciò che cosa abbiamo? Da ciò abbiamo che factor è un problema per come l'abbiamo definito che sta qui. Ok? Questo qua è factor, è un problema che non è NP completo, ma è un problema che non sta nemmeno in B perché perché l'abbiamo dimostrato, no? sono CMC, cioè noi riteniamo che il problema della fattorizzazione sia un problema intrattabile, cioè quindi un problema non risolubile in tempo polinomiale, semplicemente perché nessuno è mai riuscito a farlo. E la cosa più interessante è che tutti, cioè tutti, buona parte dei sistemi crittografici a chiave pubblica che usiamo in questo momento, tipo RSA, si basano sul problema della fattorizzazione e si basano sul fatto che noi assumiamo che fattorizzare dei numeri sia un problema tosto. Ok? In realtà noi non lo sappiamo se sia un problema che sta dentro P o no. Siccome nessuno c'è mai riuscito, ipotizziamo che non lo sia. Quello che sappiamo è che con altissima probabilità il problema della fattorizzazione non è NP completo, quindi non è un problema tosto di NP perché Factor sta sia in NP che in co di conseguenza, se factor fosse uno dei problemi tosti di NP, se fosse un problema NP completo, allora avremmo che co NP sarebbe uguale a NP e a questo non ci aspettiamo che accada, ok? Quindi factor è un problema che non sta in Pché nessuno c'è mai riuscito a risolverlo in tempo polinomiale, però non abbiamo nemmeno la garanzia che Factor sia un problema tosto di quelli di INP. Riteniamo infatti che non lo sia. Nonostante ciò viene utilizzato per la per la sicurezza informatica in buona parte dei dei protocolli attuali. Come voi sapete, esiste un algoritmo per macchine quantistiche che è in grado di risolvere il problema della fattorizzazione in tempo polinomiale, ma come vedete questa è una domanda che insomma molti di voi vi hanno mi hanno fatto. Questo problema che è risolvibile in tempo polinomiale da macchine quantistiche non è un problema NP completo. Quello che infatti si sa, almeno quello che io so a riguardo, è che i problemi NP completi non sono risolvibili in tempo polinomiale da macchine quantistiche, cioè le macchine quantistiche riusciranno, semmai riusciremo ad averne qualcuna che veramente funziona, a risolvere in tempo polinomiale roba e i che sta qui. Ok? Cioè i problemi quelli veramente tosti, che ne so il Napsak, il be packing, tutta quella roba, il commesso viaggiatore che vedremo alla fine, no? Che sono problemi NP completi, sono problemi che non verranno risolti in tempo polinomiale da macchine quantistiche. Quindi la questione PNP rimane tutta, noi non lo sappiamo, riteniamo che non ci sia. Questa è una versione estesa, è una congettura di Aronson, mi pare che non ci sia un dispositivo fisico costruibile in questo universo che sia in grado di risolvere in tempo polinomiale i problemi più completi, cioè quelli non sono correntemente risolvibili in tempo polinomiale e ci aspettiamo che non lo saranno mai, cioè saranno sempre problemi al di fuori delle nostre capacità risolutive, a meno che, insomma, non abbiamo istanze piccole o cose del genere. Prego. Subord in questo caso quando interp il bordo si interrompe. Sì, sì, è una metafora che si potrebbe utilizzare a contatti a quelli in un Sì. Se noi ci immaginiamo che gli NP completi sono tutto metaforico, eh se c se ci immaginiamo che gli NP completi sono sul bordo di NP, ovviamente non possono essere questi perché sarebbero dentro con NP, quindi sono che possiamo pensare che questi siano gli NP completi e questi qua siano i co completi. Ok? Alright. Oggi stiamo andando più veloce del solito. Vediamo altre classi di complessità. Ok, giusto le introduciamo. Le introduciamo. Non vedremo cose troppo dettagliate perché perché richiede richiederebbe del tempo. Se poi avete curiosità me le me le chiedete. Ok? Allora, quello di cui abbiamo parlato finora sono i problemi NP che, come abbiamo detto non sono non è la classe dei problemi non polinomiali, ma sono i problemi non deterministic polynomial. Cioè, poi è rimasto classicamente il nome perché proveniva da non deterministic polynomial, ma non è che significa è non polinomiale. Poi di fatto sta che non siamo in grado di risolverli in tempo polinomiale, però non abbiamo la garanzia che non siano risolvibili in tempo polinomiale. Ok? Però ovviamente non è che le classi di complessità si esaiscono qua. Sopra NP ci stanno tante classi, alcune le vediamo oggi, altre le vedremo in altre lezioni. Daremo giusto delle delle intuizioni. Una cosa su cui ci concentriamo ora sono i problemi che in effetti, cioè possono essere risolti in tempo esponenziale, ok? Quindi è proprio un'altra categoria di problemi che sono i problemi exponential time, ok? E denotiamo la loro classe di complessità come exp. Allora, che cos'è Exp? Expo viene definita proprio come la classe dei problemi che possono essere dei problemi di decisione, sempre di cesione, tutto ciò è decisionale. Eh, ex è la classe dei problemi di decisione che possono essere risolti, decisi da macchine di touring deterministiche in tempo esponenziale. Ok? Quindi è l'unione su d time di 2^ n^ c per c che è maggiore uguale di 1. Cioè, quindi che cosa sono? sono quei problemi che possono essere risolti da macchine di touring deterministiche in il cui running time è 2 a elevato a un polinomio. Ok? Quindi quello è per noi exponential time. Exponential time, deterministic. Ok? Allora, la domanda che io ora vi faccio che relazione c'è fra P ed time? Chi sta dentro? Pista dentro ex ovviamente perché quello che noi riusciamo a fare in tempo polinomiale lo sappiamo fare anche in tempo esponenziale. Vi ricordo c'è che i linguaggi di P stanno dentro exp. Non è che per un linguaggio per stare dentro Exp si deve risolvere in tempo esponenziale e non di meno. Basta che sia risolvibile in tempo esponenziale, ok? Quindi abbiamo che exp time sta qui sopra, ok? Questo è exp. Che relazione c'è fra exp e p? tra e p noi siamo in grado di dire che sono diversi, ok? Non vediamo il risultato, però ve lo ve la dico io. Così, per esempio, tra exp time e polynomial time noi siamo in grado di dire che le due classi di complessità sono distinte, cioè ci sono dei problemi in expolvibili in polinomial time. si chiama il teorema della gerarchia temporale, qualcosa di questo genere, che ci permette di dire che polinomial time sia distinto da da esponential time. Adesso quello che io vi chiedo è secondo voi qual è la relazione fra NP ed exp time? Un attimo che mentre ci pensate io sposto questa cosa qua che mi serve dello spazio. Un giorno imparerò a spostare le figurelle, quindi abbiamo P qua exp time è qui. Ok. Cos'è che relazione c'è fra NP ed exp time? è incluso m perché eh perché col fatto che ehm NP include P, però possiamo dire che extra è diverso da P, allora sarà per forza un E perché non facciamo una cosa di questo tipo? Sì, perché possiamo simulare i le macchine non mistiche in questo Esattamente. La dimostrazione è quella. Noi abbiamo che la relazione fra where is it? Exp, la relazione fra NP ed exp time è questo qua per un risultato che abbiamo visto proprio all'inizio inizio. Siccome noi possiamo simulare il funzionamento di una macchina non deterministica con un con una crescita temporale di tipo esponenziale, se la macchina non deterministica esegue in tempo polinomiale, come le macchine in NP, la loro simulazione con la simulazione che noi conosciamo eh di fare l'esplorazione per livelli del computation tre, quella cosa si fa in esponenziale. Per questa ragione noi abbiamo che NP è incluso dentro XP. Ok? Cosa sappiamo dire tra Exp ed NP? Sono uguali? Non sono uguali? Ci muoviamo nuovamente in un territorio sconosciuto. Non sappiamo dire nulla. Ok? Non sappiamo né se sono uguali né se sono è strettamente incluso. Ok? Questo è un altro di quei risultati per i quali non sappiamo dire un granché. Ok? Quindi, come vedete, a differenza della decidibilità in cui sapevamo distinguere le classi di decidibilità, molte delle classi di complessità sono tutt'ora tutt'ora noi non sappiamo dire molto. Sappiamo dire che exp è diverso da P, ma non lo sappiamo dire rispetto ad NP. Cioè, NP potrebbe essere uguale a Next, ma non lo sappiamo. Riteniamo che siano distinte, però nessuno è mai riuscito a dimostrarlo. Ok? È proprio un territorio molto fumoso in cui assumiamo che queste classiano distinte perché nessuno è mai riuscito a dimostrare che siano uguali. Però queste dimostrazioni ci mancano, sono picche congettura. Ok? Similmente noi abbiamo che co NP è incluso in exp. Perché secondo voi? Perché sennò cioè i problemi complementari di Conn sono in NP e quindi dopo Sì, la ragione è quella. Allora, ecco co NP sta in exp perché in CNP abbiamo i linguaggi i cui complementi stanno in NP. Ci siete? Ma per la relazione di prima, NP sta dentro exp. Exp è una classe deterministica che è chiusa sotto complemento. Allora, sia l un linguaggio in co dobbiamo mostrare che è in in exp time, ok? Come si fa? Se l appartiene a co NP, allora l soprassegnato ad appartiene a NP. Ma se L soprassegnato appartiene ad NP, allora L soprasegnato appartiene a exp. Chiaro? Se L soprasegnato appartiene a exp, allora L appartiene a exp perché exp è chiuso sotto complemento. Ok? Per questa ragione noi abbiamo che con NP sta dentro. Ok? Altra classe e poi chiudiamo. Come vedete queste le stiamo facendo molto molto velocemente, eh, se mi capite bene, NP è una buona cosa. Ci sta un'altra classe che è questa qua, Nextp. Non deterministic exponential time. Ok? Secondo voi, se questa qui è la definizione di exp, come definiamo next? Stessa cosa invece di time non esattamente. Quindi noi abbiamo che next è l'unione su C mag uguale di 1 di cosa? Di n time di 2^ n^ c. Ok? Quindi è nondeterministic exponential time definito in maniera abbastanza standard. Poi ci stanno tutta una marea di altre classi esponenziali bla bla che non vediamo. Ci ho scritto un lavoro a riguardo. Se vi incuriosisce scritto malissimo, non si capisce niente. Lo sto sistemando. Eh, ok. Secondo voi, prendendo questa figurella, dove sta Nextp? Più grande contiene tutto, ok? Quindi, next. sta qua. Va bene. Ok. Secondo voi cosa siamo in grado di dire tra exp e Next? Sono uguali, sono stretta, sono distinti. Secondo voi? Esattamente la stessa cosa. Non sappiamo dire niente, ok? Sappiamo nulla, ok? Noi abbiamo che Nextp include exp, ma non sappiamo se lo include strettamente. Ok? Quello che invece sappiamo dire è questo qua che nextp è diverso da NP. Ok? Questo lo sappiamo dire per lo stesso teorema che è quindi il teorema della gerarchia temporale che è lo stesso che ci permette di distinguere exp da p e nex da np qual è la razio dietro. Poi teorema ci permette di dire questo: se due classi di complessità temporali si differenziano per un fattore esponenziale, cioè che una è esponenzialmente più grossa dell'altra, allora distintono. Quindi sappiamo che polynomial time è distinto da exponential time. sappiamo che exponential time è distinto da double exponential time, che double exponential time è distinto da triple exponential time and. Ok? Però per esempio noi sappiamo qui per questa cosa qua che exp è diverso da P da cui abbiamo ad esempio P sottoinsieme di NP sotto di exp. Siccome P è diverso da X, da qualche parte il contenimento stretto deve apparire, ma noi non lo sappiamo dov'è. In particolare potrebbe apparire ovunque. Quindi noi sappiamo che questi due sono distinti, ma delle relazioni che stanno in mezzo noi non sappiamo niente, non siamo in grado di distinguere, ok? È una è una condizione particolarmente intricata, ok? caratterizzazione di NextP, giusto per renderla simile a NP. E con questo concludiamo. Quindi Nx sono l'insieme dei linguaggi o dei problemi di decisione che possono essere decisi in tempo esponenziali da macchine deterministiche oppure si può definire tramite certificato che è questo: un linguaggio appartiene a Nextp. Se le sue istanze Sì sono caratterizzate da certificati di taglia esponenziale che sono verificabili da macchine deterministiche in tempo polinomiale. Attenzione, sono certificati sono le stanze sì sono caratterizzati da certificati di taglia esponenziali esponenziale verificabili, quindi il certificato è di taglia esponenziale rispetto a cosa? rispetto all'input e questo certificato enorm di taglia esponenziale può essere verificato da una macchina di touring deterministica, ponete attenzione qui, che lavora in tempo polinomiale nella taglia combinata dell'input e del certificato. Quindi abbiamo l'input che ha la sua taglia, facciamo un guess di taglia esponenziale, la verifica si fa in tempo dentro polinomiale. In cosa? Nella taglia dell'impio più la taglia del del certificato. Perché non diciamo che la verifica è tempo esponenziale nella taglia del certificato? Perché sennò la verifica sarebbe il tempo doppiamente esponenziale nella taglia dell'input. Ecco perché si fa così. Quindi abbiamo l'input, gestiamo un certificato enorme. Una volta che si fa il guess, la verifica si fa in tempo polinomiale nella taglia del certificato più la taglia dell'input. Ok? Prego. Perché si aggiunge la taglia dell'input tanto è lineare, non dovrebbe influire. Sì, quello sì, perché si fa una definizione a relazioni eccetera, quindi sono le colonne della tabella, quindi si aggisce, però ovviamente non influisce perché l'input può sempre stare dentro il semplificato. Eh, questo qua, eh. Ok, non credo non credo ci sia altro. Non vedremo altri dettagli di queste classi perché sono un po' un po' triti. Ok, buona serata. [Musica] Signor