Ok. Ok. [Musica] Quello che abbiamo fatto finora. Chiaro, complicato, difficile. Estremamente estremamente difficile. Di più non si capisce un cavolo. Vabbè. M Ok. Mi hanno detto che vi piacciono le riduzioni, quindi oggi ne facciamo un'altra per cambiare. Eh, lei lei lei non si pronuncia. Va bene, eh. Eh, ok. Con oggi chiudiamo la parte più espressamente dedicata a NP. Manca una sola cosa da vedere su NP, dopodiché ci sarebbero tante cose da vedere su NP, ma manca una cosa fondamentale che non abbiamo visto finora riguardo NP. Eh, dopodiché il resto delle lezioni saranno classi un po' più strane, eh un'esercitazione finale facciamo e quindi questo è quello che ho che ho più o meno in mente. Ok. Allora, allora, allora qui recup che cos'è? Che cos'è la classe lezione 22? Sì. Che cos'è la classe NP? Guys, che cos'è la classe NP? Dei problemi come decisione, decisione decisionali, perché gli altri problemi, quelli di funzione, non stanno in NP, hanno altre classi. Vedremo qualcosa velocissimamente alla fine, però in NP, come in P, come in R, in re, eccetera, ci sono solo problemi di decisione, ci stanno linguaggi, ok? E siccome per i linguaggi quello che possiamo dire è s No, ci stanno problemi di ok? Questa è la definizione precisa, l'insieme dei linguaggi decidibili macchine di Touring non deterministiche in tempo polinomiale. Eh, ok. Cosa sono i problemi NPD? Ve la ricordate la definizione? Sì. Ok. Sì. Quindi intuitivamente sono i problemi tra sono i problemi almeno difficili quanto tutti i problemi di NP. I problemi di P si possono ridurre a un problema NP arduo. Sì, perché perché i problemi in P sono anche in NP. Ok? Vi ricordate come si chiamano i problemi che sono sia in NP che NP hardue? NP completi. Alri guys, avete studiato? Buono. Comp complete. Ok. Dopodiché quello che abbiamo visto ora, la definizione che noi abbiamo fatto, quindi ah noi abbiamo detto che un linguaggio L e NP hard se per ogni linguaggio L'O appartenente a NP, L'O si riduce polinomialmente a L. Ok? Questa era la definizione di hardness, però non è quello che abbiamo fatto finora, no? Finora per dimostrare che Napsa era NP completo, exact cover, NP completo, colorabilità, vertex cover, click, tressat, bla bla tutte quelle cose là. Noi abbiamo usato un'altra definizione, abbiamo usato una proprietà delle riduzioni che è la transitività delle riduzioni polinomiali che ci diceva che se A e B sono due problemi con A np arduo e inoltre A si riduce polinomialmente a B, allora B è NP arduo. Ok? Questa è la proprietà che noi abbiamo utilizzato in tutte le nostre riduzioni eccetera. Adesso l'inghippo di questa proprietà che ci viene comodissima perché è stata alla base di tutte le dimostrazioni di complessità che abbiamo visto finora. Il problema di questa di questa definizione è che noi abbiamo bisogno di un problema a NP arduo per dimostrare che B NP arduo. Quindi come abbiamo dimostrato che Napsack era NP arduo, riduzione da exact. Come abbiamo dimostrato che exact cover era NP hard riduzione da 3 SAT. Come abbiamo dimostrato che 3 SAT è NP ardo, riduzione da SAT. E come abbiamo dimostrato che SAT NP arduo non l'abbiamo dimostrato. Ok? Quindi tutto quello che abbiamo fatto finora si fondava su questa assunzione che esiste almeno un problema in neppiardo, cioè esiste un problema che è almeno difficile quanto tutti i problemi della classe NP. Ok? Adesso per dimostrare che NP arduo non possiamo sfruttare questo trucco perché non abbiamo altri linguaggi NPD. Ok? Potremmo pure ridurre Napsa a SAT e mostrare che SAT è almeno difficile quanto Napsak, però il problema è che poi avremo una riduzione circolare. SAT che si riduce a Napsak, Napsac che si riduce a SAT. Che cosa avremmo? Avremmo che la complessità di questi due problemi è equivalente, ma niente più di quello, cioè non avremmo la proprietà che NP, ok? Ci serve quindi usare la definizione iniziale, cioè per dimostrare che SAT è NP argo, noi dobbiamo dimostrare che ogni linguaggio L di NP si riduce a SAT, che è una bella rogna perché ci dobbiamo inventare una riduzione da tutti i linguaggi in NP che mappino su SAT. Ok? Adesso a occhi e croce, secondo voi quanti sono i linguaggi in NP? Tanti, pochi? Pochini? Troppi, troppi. Quanti? 1000, 2000, quanti saranno? Avete un'intuizione? Infini. Infiniti. Sono infiniti i linguaggi dentro NP. Perché noi basta che ne prendiamo uno, lo modifichiamo leggermente, abbiamo una variante, ne abbiamo un altro in NP. Ok? Cioè i linguaggi dentro NP, tanto per cambiare sono infiniti. Quindi eh trovare una riduzione, trovare infinite riduzioni da ogni linguaggio L in NP a SAT e insomma è non è una cosa banalissima, ok? Cioè, ci dobbiamo inventare un trucco. Questa è la questione, perché noi dobbiamo mostrare che esiste una riduzione polinomiale da ogni linguaggio in NP verso SAT. Ok? È chiaro? Quindi quello che ci proponiamo oggi è far vedere che preso un qualsiasi linguaggio in NP noi lo possiamo e e può essere qualsiasi eh, può essere click, vertex cover, napsak, exact cover, problemi su teoria dei giochi. Può essere la qualsiasi, un qualsiasi linguaggio di NP si può mappare su su, ok? Questo risultato è dovuto a Cook e lo chiamiamo il teorema di Cook. Teorema di Cook, ok? È colui che ha inventato la definizione di NP hardness, NP completezza, riduzioni polinomiali. Questi sono tutti i concetti che dobbiamo a Stephen Cook e lui in quel paper mostrò che SAT è anche un problema NP completo, quindi si era inventato la nozione e ha dimostrato che SAT è NP completo. Ok? Allora, andiamo prima intuitivamente cerchiamo prima di focalizzare la nostra attenzione su come debba essere organizzata questa riduzione perché è una riduzione un po' problematica. Ok? Allora, abbiamo L che è un linguaggio di NP, lo dobbiamo, come al solito, lo scriviamo nel nostro modo usuale, no? Abbiamo L, che è un linguaggio generico di NP e lo vogliamo ridurre polinomialmente a SAT. Ok? Benissimo. In genere ci poniamo delle domande quando facciamo le riduzioni, no? Ve le ricordate che domanda ci poniamo in genere quando facciamo una riduzione da un linguaggio verso un altro? Cos'è unanza? Che cos'è un'istanza? Che cos'è un'istanza di L? Attenzione, che cos'è un L? Che cos'è? Un linguaggio. Che cosa sono le istanze dei linguaggi? Stringhe. Stringhe. Che cos'è un'istanza di L? Una stringa. Una stringa. Quindi è W. Ok. Possiamo dire qualcosa di questa stringa? È un grafo. È un'istanza di Napsac. Possibile, potrebbe essere qualsiasi cosa, non lo sappiamo. È è una stringa, ok? Su dei simboli, i simboli del linguaggio, quindi è uno sconosciuto, è una stringa. B è una stringa. Ok? Questa cosa va tradotta in una istanza di SAT. Che è? Cos'è? Un'istanza di SAT? formula è una formula una formula una formula una formula buleana è una formula buleana in formato CNF. Ok? Quindi noi abbiamo che dall'altro lato abbiamo f di W la chiamiamo è una formula in CNF. Ce lo segniamo qua. Ok? è una formula buleana. Ok, benissimo. Poi le domande successive quando facevamo, perché adesso quello che dobbiamo fare è inventarci una funzione f calcolabile in tempo polinomiale che trasforma questa stringa W di natura sconosciuta, ok? in una formula F che dipende da W. Ok? Poi, qual erano in genere le domande che ci poniamo quando facciamo le riduzioni? Sì, istanze no. Instanze sì, istanze no. Che cos'è un'istanza sì del linguaggio? L è una stringa di caratteri che appartiene al linguaggio. È una stringa di simboli che appartiene al linguaggio. Possiamo dire altro? [Musica] No, se non conosciamo L non possiamo dire un granché. Ok? Sappiamo che un'istanza sì per L, attenzione qua che qua stiamo andando proprio sull'astratto, eh? Qui se vi perdete ditemelo che io ripeto e mi invento un modo diverso. Ok? Allora, qual è il problema qua? Qual è il nocciolo della questione? Noi dobbiamo mostrare che preso un linguaggio L a caso che proviene da NP, un linguaggio di cui non sappiamo niente se non che L appartiene a NP, esiste un modo di trasformare le istanze di L qualsiasi in formule. Ok? E noi non è che questa trasformazione la facciamo a buffo, prendiamo delle stringhe W di cui non sappiamo niente perché sono definite su un certo alfabeto bla, ok? Tale per cui se W appartiene ad Lula file di W che proprietà deve avere? è soddisfacile. Deve essere soddisfacile. E se la stringa W non appartiene ad L, la formula F di W che proprietà deve avere? Deve essere non soddisfacile. Ok? Cioè fino a mo ci stiamo muovendo nell'ambito delle cose che abbiamo sempre visto. Ok? C'è un pezzo strano in questa riduzione è che noi non sappiamo che cosa sia l quella è la questione. Ok? Perché fino a quando avevamo grafi, altre formule buuleane, il gioco degli scacchi, qualsiasi cosa vi possa venire in mente, cioè noi sappiamo cos'è un'istanza e la trasformiamo in un'altra. Qui abbiamo il non trascurabile problema di star trasformando un'istanza di un linguaggio sconosciuto, perché L è un linguaggio generico. Stiamo trasformando un'istanza W di un linguaggio che non sappiamo che cos'è, eh perché può essere qualsiasi roba di NP, può essere pure un linguaggio di P, non lo sappiamo che cos'è. Ok? Dobbiamo trasformare però questa istanza w di l in maniera sensata in una formula file di W che sia soddisfa se è solo se W appartiene al linguaggio L e DL non sappiamo niente. Ok? Questo è il problema di questa trasformazione. Ok? Allora, quello che noi ci proponiamo di far vedere è che se L è un qualsiasi linguaggio di NP, allora esiste una riduzione. Ok? Non saremo in grado di dare il dettaglio della riduzione perché non sappiamo chi è L, però siamo in grado di mostrare che una tale riduzione c'è. Ok? Questo è il nostro principio. Ripeto, siccome noi non sappiamo chi è L, noi non possiamo dare una riduzione precisa. daremo uno scheletro di riduzione abbastanza preciso che ci mostra che qualsiasi L, basta che LP, allora L si può ridurre a SAT. Ok? Questa è l'idea. Noi L non lo conosciamo, quindi una riduzione esatta non la possiamo fornire. Quello che possiamo fornire però è uno scheletro di riduzione abbastanza preciso che ci permetta di trasformare una qualsiasi istanza di un qualsiasi linguaggio in NP verso SAT. Ok? Questa è l'idea. Questo è quello che sei inventato tu. Ok? Allora, per riuscire a vedere come fare, ragioniamo prima su una cosa. Adesso il formato di questa dimostrazione che vi do è un mix di varie dimostrazioni che ho visto in giro, ok? Non è né quella che trovate su Opcft né quella che trovate sugli appunti di Calauti. È un mix di quella roba che ho fatto io per semplificarla. Ok? Cioè è ancora precisa. Non sto togliendo rigore alla dimostrazione, però l'ho rimodulata, ispirata dalla riduzione che appare sul libro di Gerin Johnson, rimodulata in quel modo in maniera tale da rendere digeribile. Ok? Allora, cercherò di guidarvi in maniera tale che capiamo come cavolo si fa sta cosa, perché se guardate per esempio sull'opcocroft è una cosa impossibile da cioè ci si deve mettere cercare di capire. Io ho cercato di ristrutturarvela in maniera comprensibile, ok? In maniera intuibile, che c'è almeno un'intuizione dietro, ok? Allora, cerco di guidarvi in maniera tale da avere il razionale che ci sta dietro, cioè perché ci inviamo questo e non altro. Ok? Quindi noi dobbiamo ridurre, noi dobbiamo mostrare che esiste una riduzione da L sconosciuto verso SAT. ci dobbiamo inventare qualcosa. Quindi noi di questo L non sappiamo assolutamente niente, quindi non possiamo fidamento che stiamo trasformando grafica, non possiamo assumere che stiamo trasformando altre formule o giochi o qualsiasi altra cosa vi venga in mente. Non possiamo fare nessuna di queste assunzioni, ma noi possiamo fare un'assunzione su L che è esiste una macchina. Esattamente. L'unica cosa che siamo in grado di dire di L non sappiamo dire niente, sappiamo dire una cosa sola per il fatto che L è assunto appartenere ad NP. esiste, esiste una macchina. Allora, quindi siccome L appartiene a NP, esiste una macchina non deterministica M che in tempo polinomiale decide L. Ok? Questa è l'unica cosa che siamo in grado di dire su L. L è un linguaggio generico di NP. Da ciò esiste una macchina di Touring non deterministica che in tempo polinomiale lo decide. Ok? Assumiamo che il running time dim sia PDN, ok? Sia polinomio qua, ok? Questa è un'assunzione su running time. Sappiamo che deve essere un polinomio, lo chiamiamo PDN, ok? Alri. Allora, siccome noi sappiamo che L è un linguaggio in NP, L può essere qualsiasi ed è un linguaggio in NP e per questa ragione esiste una macchina di Touring non deterministica che lo decide in tempo polinomiale, la nostra riduzione si fonderà esattamente su questo perché che è un tipo di riduzione che a questo punto può valere per qualsiasi linguaggio L. La riduzione mirerà, questa è l'intuizione, poi vediamo il dettaglio di come si faccia. La nostra riduzione mirerà a trasformare W perché vi ricordo che F prende in input w e tira fuori file di W. Quindi deve prendere W in input, deve sputare fuori una formula buleana. Questa formula buleana fai di W che caratteristiche ha? Avrà la caratteristica di simulare il comportamento della macchina M su W e la formula sarà soddisfacbile se solo se la macchina M accetta W. Questa è l'idea. Ok? Recup. Siccome L è un linguaggio sconosciuto e non possiamo fare una riduzione diretta perché non sappiamo che faccia abbiano le istanze di L, se non che siano sequenze di simboli, noi dobbiamo sfruttare l'unica caratteristica che sappiamo di L e cioè la sua appartenenza alla classe NP. Poiché appartiene a NP, per definizione L ammette una macchina non deterministica M, che decide L in tempo polinomiale e lo chiamiamo PDM questo PDN, questo polinomio, ok? La riduzione può fondarsi su questa unica cosa che sappiamo di L perché altro di Lppiamo. Ok? Quindi cosa fa questa funzione di riduzione fare? prende m e prende w e la trasforma in una formula che mima il comportamento della macchina M su w. Ok? Questo la formula F di W sarà una formula che mima il comportamento della macchina M su W e la formula F di W sarà soddisfacibile se la macchina M accetta B. Sarà insoddisfacibile se la macchina M non accetta W. Ok? È chiaro il principio? Adesso questa riduzione che vediamo è una riduzione generica perché è parametrica nella nella macchina M. Ok? Perché noi dobbiamo trasformare in file di W il funzionamento di M su w. Quindi la funzione f in input la macchina M. La funzione f è progettata su M. Prende in input w e sputa fuori una funzione buleana fai di W che mima il comportamento di m su w. Ma m in input di f, è chiaro? Perché f deve trasformare istanze di L in istanze di sat e le istanze di L sono string. Ok? Quindi F non può prendere in input M. M è una conoscenza che F ha, ok? È una conoscenza che F sfrutta per sputare fuori i file di doppia D. Chiaro? Alri, quindi sostanzialmente quello che dovremo fare c'abbiamo spazio più o meno 1 2 3 4 Facciamolo qua. Quello che dovremmo fare, quindi, è mostrare che questa funzione prende in input solo w V. Questa funzione si basa su M, però come potete notare M non fa parte dell'input, f è basata su M. Questa funzione f prende w, sputa fuori file di w. Adesso s la funzione che noi dobbiamo tirare fuori è una funzione in CNF, quindi non deve essere una funzione buleana qualsiasi. Quindi, per esempio, sull'oproftano fuori una funzione buleana qualsiasi e poi fanno vedere che si può trasformare in CNF e quello secondo me è un po' più intricato. Noi non lo vediamo. Si possono trasformare, però questo dettaglio non lo vediamo. Noi ci inventiamo una formula che si ha direttamente in CNF, ok? in maniera tale che non ci dobbiamo curare del fatto se si possa trasformare o meno. Però per semplificarci il compito a noi, siccome le formule in CNF hanno una struttura abbastanza limitata, ci servono un po' di regole di trasformazione di funzioni buleane, in maniera tale che sappiamo che quel tipo di funzione può essere facilmente trasformata in CNF. Dopodiché noi usiamo una sintassi un po' più ricca in maniera tale che non usciamo pazzi. Ok? Allora, noi sfruttiamo una serie di proprietà delle formule buleane sulla base delle quali poi costruiamo in questa funzione FM. Ok? Distributività ci servirà. distributività. [Musica] Per esempio, se abbiamo A1 and bla bla bla and am Where is it? Questo qua è N. Allora, questa cosa è equivalente a basta fare tutte le possibili coppie e riscriviamo la cosa, ok? Quindi questa cosa si ritrasforma in per esempio A1 or B1 and A1 or B2 and bla bla bla and a 1 or BM and A2 or B1 bla bla bla fino and a n or bm. Vi è chiara questa trasformazione? La trasformazione, se noi abbiamo l'ord di quegli elementi, l'endgli elementi in or a quegli altri, si prendono tutte le coppie e si ritrasforma in questo modo. Come potete notare questa formula qua è in CNF, ok? Poi ci serve de Morgan. Per the Morgan utilizzeremo questa not a1 and bla bla bla and A n. Questo è equivalente a not a1 or not A2 or bla bla bla or not A n. Ok. Poi proprietà delle implicazioni. F implica psi è equivalente dove f e psi possono essere formule buleane qualsiasi. Questa è not psiché noi scriveremo tutte le nostre formule in forma implicativa, in maniera tale che siano più facili da leggere. Ok? E poi abbiamo che altra formula è f implica psi 1 and psai 2. Questa cosa è equivalente a f implica psi di 1 and implica psi di 2. Ok? Facciamo un piccolo esempio di riscrittura, così poi ci possiamo concentrare su la riduzione. Ok? Supponiamo di avere ad esempio A and B implica C and D or E and F. Ok. Allora, che cosa abbiamo? Possiamo applicare la distributività qua sopra. Quindi, per esempio, avremo A and B implica C o E and C or F and D or E and D or F. Questa cosa qua è equivalente, possiamo applicare la distributività sulla implicazione e quindi avremo A and B implica CR E. And a and B implica C or F and A and B implica D o E and A and B where is it? A and B implica D or F. Qua poi si può per esempio riapplicare l'altra storia e quindi avremo che cosa? Not a or not B or C or E. And not A or not B or C or F and not A or not B or D or E. and not A or not B or D or F. Ok? Quindi questa qua è tutta una trasformazione, ad esempio, che ci permette di poter listare le nostre funzioni come implicazioni e quindi ci occuperemo di trascrivere la riduzione come implicazione. Ok? Allora, abbiamo detto che dobbiamo trasformare, lo riscriviamo qua, L va ridotto polinomialmente a SAT. Abbiamo la stringa W che va trasformata in file di W tramite F. E quindi noi dobbiamo andare a trasformare, quindi andremo a trasformare la stringa W in una formula F di W in cui noi andremo a mimare il funzionamento della macchina M su W. Quando diciamo che andiamo a mimare il funzionamento della macchina M su W, vuol dire che dentro file di W ci saranno delle proposizioni buleane, delle variabili proposizionali che ci dicono cosa sta succedendo nella computazione di m su w. Ok? Quindi la formula deve mimare il funzionamento di m su w. Come fa una formula buleana a mimare il funzionamento di una macchina su una stringa? Sarà una formula che contienerà conterrà delle variabili proposizionali buleane che indipendenza, se sono vero o falso, ci diranno la macchina in questo stato o la macchina in quest'altro stato, il simbolo sul nastro in questa posizione, questo qua o la testina sta su questa cella qui. Ok? In questo modo noi saremo in grado di mimare il funzionamento della macchina, ok? Quindi la formula files avrà tutta una serie di sottoformule che ci diranno pezzetto per pezzetto cosa sta facendo la macchina Mentre processa la stringa W. Ok? i risultati, cioè le variabili che al nostro interno, all'interno di f di w saranno queste. Però prima di far questo ci concentriamo un secondo sul funzionamento della macchina, ok? Allora, la macchina M è una macchina che lavora in tempo polinomiale. Ok? Quindi avremo che parte da un ID0, può andare verso un ID1 o un ID2, essendo non deterministica, eccetera. Qua poi avremo ID3, ID4, ID5, ID6. Ok? In linea di principio, perché l'ho disegnato così? Ho disegnato così il computation brand, il computation 3 della macchina perché in linea di principio i rami di computazione di questa macchina possono avere lunghezza differente, cioè per alcune scelte la macchina potrebbe impiegare più tempo che non su altre scelte. L'unico vincolo che sappiamo è che la macchina ci mette al più P di n passi, ok? Dove n è la lunghezza della stringa w. Ok? Una cosa che noi faremo, quindi, è questo, faremo una serie di assunzioni su questa macchina in maniera tale da semplificare la traduzione del suo funzionamento all'interno della formula F di W. Le assunzioni che faremo sono: "La macchina non scrive mai bianco." Questo si può facilmente assumere che basta che la macchina usa un altro simbolo e siamo tutti contenti. La macchina ha un nastro semiinfinito, che significa che il nastro ha un punto di partenza, cioè c'è la cella numero zero e a sinistra di quello la macchina non sposta la testina. Ok? C'è una dimostrazione sul testo di Opcroft è riportata in cui si fa vedere che qualsiasi macchina può essere trasformata in una macchina in cui il nastro è semiinfinito. Quindi è un'assunzione che possiamo fare. Questo ci semplificherà un po' le cose. Perché ci conviene un nastro semiinfinito rispetto a un nastro infinito? Perché così sappiamo che questo nastro ha la cella numero 0, la cella numero 1, la cella numero 2, 3 4 e 5 e non dobbiamo gestirci la parte negativa. Ok? Ecco perché facciamo questa assunzione. L'altra assunzione di semplificazione è che però l'andremo a includere nella riduzione è che questa macchina ci mette esattamente PDN passi su tutti i rami, ok? cioè che questo albero qua ha delle ID extra in maniera tale che tutti i branch abbiano la stessa lunghezza. Ok? Queste configurazioni aggiuntive della macchina sono copie delle precedenti, cioè questa qua è la stessa di questa, questa è la stessa di questa e questa è la stessa di quella di sopra. Cioè, noi assumiamo che questa macchina abbia un comportamento un po' particolare. Una volta che entra in una configurazione finale, che sia accettante o meno, la macchina continua a ciclare là sopra fino a quando fa esattamente PDN passi. Ok? Questo per semplificarci un po' le cose. Alrght, come vi dicevo, quindi noi dobbiamo trasformare aveviamo. Sì, introduco questo e poi facciamo un po' di pausa. Dobbiamo arrivare a trasformare questa stringa w in questa formula file di W in cui simuliamo il comportamento della macchina M su W. Simulare il comportamento, abbiamo detto, sarà strutturare una formula con delle variabili buleane opportune che indipendenza, se sono ver o false ci dicono cosa sta facendo la macchina in un certo momento della sua computazione. Le variabili buleane che noi utilizzeremo saranno queste qua. Q di I K che vale true true se solo se al passo i di computazione la macchina M si trova nello stato Q. Ok? Quindi avremo, che ne so, la variabile Q38 che varrà vero se al terzo passo la macchina sarà nello stato 8. Q1524 che varrà vero se solo se al 15º passo la macchina si troverà nello stato numero 24. Ok? Quindi ne abbiamo tante di queste variabili Q00, Q01, Q02, eccetera, per tutti i passi, per tutti gli stati. Poi avremo le variabili H i J che vale vero se solo se al passo i la testina di M si trova sulla cella. del nastro. Ok, quindi questa sarà un'altra famiglia di variabili buleane. Saranno tante, H, H01, H02 e così via, tipo H36. H3,6 avrà questo significato. Yes. Cosa ho scritto? Male, perché sicuramente leggo la testina di M si trova su eh sulla cella del nastro. Sì. Ok. Quindi avremo tante di queste variabili buleane. Il significato che vorremmo dare è che per esempio H36 varrà vero se al terzo passo di computazione la macchina avrà la testina alla cella numero 6. Sarà mai possibile questa cosa? No, perché perché in tre passi non possiamo arrivare alla cella 6, però diamo questa possibilità, ok? Ci sono ste variabili che hanno sto significato. Ok? Qual è l'altra? Quindi abbiamo variabili che ci dicono in che stato è la macchina a un certo passo. Abbiamo variabili che ci dicono dove sta la testina della macchina a un certo passo. Quale altra informazione ci serve? Cosa c'è su un nastro? Quindi ci servono delle variabili che ci servono a codificare il contenuto del nastro della macchina mentre la macchina processa. E avremo le variabili T, I, J, L. Pure queste son tante. Vale true. E solo se al passo i la cella geesima del nastro contiene il simbolo alfa L proveniente dal dall'alfabeto di nastro della macchina M, proveniente da gamma. Ok? Quindi pure queste sono tantissime tantissime variabili. Per esempio T 3 6 2. Ad esempio, varrà vero quando al terzo passo, in sesta posizione del nastro ci sta il simbolo alfa 2 che potrebbe essere un blank, che potrebbe essere un quadratino, un alberello, qualsiasi cosa. Ok? È chiaro? Benissimo. Quello che ci chiediamo prima della pausa, quante sono queste variabili? Sono tante, sono poche? Focalizziamoci prima su Q i K. Quante sono? Perché se è una formula troppo grossa, no, cioè no, il gioco non funziona perché questa trasformazione deve avvenire in tempo polinomiale, cioè non è che possiamo generare una formula fantevole. Ok? Quante sono queste Q? Sì. Quindi I va da 0 a PDN e K va tra, diciamo, 0 ed R, dove R è il numero degli stati. E la cosa importante è che questo R è fissato, cioè dipende dalla macchina M, ok? Non dipende dalla doppia V. Eh, quante sono le variabili H? sono gli indici i e j variano fra 0 e p n entrambi, ok? Quindi sono il quadrato di pn. Quante sono le variabili t I j? Abbiamo di nuovo I e j compreso fra 0 e voi leggete sì PDN. ed è compreso fra 0 e diciamo Sissato. Ok? Quindi abbiamo che le Q di Q di IQ sono R * PN che è un polinomio. Le variabili HD dijo, PN qu che è ancora un polinomio. Le variabili T di i JL sono P qu * S, che è ancora un polinomio perché S è fissato. Ok, è chiaro il significato di queste variabili? Alri, io direi 10 minuti di pausa e poi riprendiamo assieme questa riduzione. È il numero di simboli della Sì, sì, sì. È un nome che gli diamo, può essere qualsiasi. Ok. [Musica] [Musica] Ho ripreso. Yes. Ok. Allora, quindi siamo in mezzo a questa riduzione. Abbiamo detto che stiamo riducendo in generico linguaggio L a SAT. Di questo linguaggio L non sappiamo nient'altro a parte che L sia decidibile da una macchina M in tempo polinomiale, M non deterministica in tempo polinomiale PDN. La trasformazione, abbiamo detto che sostanzialmente mirerà a costruire una formula puleana che descrive il linguaggio delle tramite il linguaggio delle formule buleane il funzionamento della macchina M sulla stringa w. Ok? E quindi questo funzionamento in questa formula buleana verrà descritta tramite queste variabili proposizionali che sono Q di I K che vi ricordo varrà vero se la macchina M al passo i sarà nello stato Kesimo. le variabili Hij J che varranno vero solamente se al passo iesimo di computazione la testina sarà sulla cella Gesima e le variabili t, quindi Q * Q degli stati, H di head, T di tape. Le variabili t varranno t i j varranno ovo, se solo se al passo iesimo la cellaesima contiene il simbolo esimo. Ok? Quindi questo è il significato che vorremmo utilizzeremo di queste variabili. Il tutto sarà di andare a inventarci questa formula f di w. Allora, questa formula F di W avrà dei pezzi che vedremo assieme. Cercherò di guidarvi sull'intuizione in maniera tale nella speranza che, insomma, questa riduzione vi rimanga più in mente, ok? Cioè che ci sia una ragione dietro del perché ce la stiamo inventando così e non è una cosa buttata là la riduzione funziona. Ok? Allora, siccome file di W deve mimare il funzionamento della macchina M su w tramite quelle variabili proposizionali sarà fatte da una serie di pezzi. Ok? Il primo ve lo dico io, gli altri li pensiamo assieme. Il primo pezzo che chiameremo C si sarà un pezzo di formula di f di W che si occupa della consistenza dell'assegnamento di verità a quelle variabili. Cioè, noi vorremmo essere sicuri che non è che potrà essere vero che Q23 è vero e Q24 è vero, che starebbe a significare al secondo passo la macchina sta nello stato 3 e nello stato 4. Ci sarà quindi un pezzo di formula che si dovrà occupare che fissato il passo la macchina sta in un solo stato. fissato il passo, la testina sta in una sola cella e fissato passo e numero di cella, sul nastro ci sta un solo simbolo, ok? Quindi ci sarà un pezzo della formula che codificherà questo, cioè imporrà questi vincoli alla soddisfacilità, a come possono essere assegnati i valori di verità a alle variabili, ok? Senò non mimiamo assolutamente niente, le buttiamo lì a caso. Dopodiché, siccome file di W deve mimare il funzionamento di m su W, secondo voi in questa formula cos'altro andremo a codificare? Che cosa ci dobbiamo infilare là per rendere le cose funzionanti? La funzione di transizione in qualche modo. Ok? E prima di quello cosa dovremmo fare? Gli stati finali in qualche modo. Gli stati finali anche quello, perché noi vorremo che la funzione codifichi il fatto che la macchina accetti questa stringa. Quindi questa formula dovrà essere vera perché alla fine la macchina transisce in uno stato accettante. La prima cosa che questa funzione deve codificare che cos'è? Ah, il fatto che si trovi nello stato iniziale all'inizio. Che si trovi nello stato iniziale all'inizio e che sia nella scelta iniziale all'inizio con la string scritta. Sì. Cioè, quindi il un pezzo di questa formula si deve occupare, lo chiamiamo start, si deve occupare di codificare il fatto che la macchina viene accesa nello stato iniziale e che sul nastro ci sia la stringa doppia V. Ok? Quindi ci sarà un pezzo di un pezzo di questa formula F W in cui che chiameremo S e sarà un pezzo di formula buleana che servirà a imporre che al passo iniziale la macchina sta nello stato iniziale e che sul nastro ci sta la stringa iniziale e che sulle celle residui ci sta blend. Ok? Dopodiché che deve fare questa formula? deve codificare che avete detto eh i passi, cioè che i passi codificati in questa formula seguano la funzione di transizione. Quindi avremo un pezzo n next step della formula che si occuperà di codificare che la formula descrive dei passi sensati, ok? Quindi i valori di verità assegnati a tutte quelle variabili che ci siamo inventati servano a replicare che la macchina veramente funziona come dovrebbe funzionare e dopodiché l'abbia l'avete già detto che final la macchina alla fine transisce in una configurazione accettante. Ok? Final step. È chiaro? Quindi questa formula avrà quattro pezzi. Sarà una formula buleana enorme, però cercheremo di dargli un significato, così riusciamo a capire. Un pezzo che chiamiamo C che si occuperà della consistenza dell'assegnamento alle variabili buleane, quindi che non possiamo dare true a tutto, per esempio. Ok? un pezzo che chiameremo S che si occuperà di descrivere che la macchina M parte su W da Q0. un pezzo che chiameremo n in cui la codificheremo nella formula che i passi che questa macchina fa devono seguire la funzione di transizione e un pezzo fà verificare se all'ultimissimo passo, che è il passo PDN, perché abbiamo assunto che la nostra macchina fa sempre esattamente PDN passi e all'ultimo passo la macchina si trovi in una strada accettante. Ok? Questi saranno i pezzi delle nostre delle nostre eh formula. Ok, partiamo da consistency. Ok. Come definiamo C? Ok. ci dobbiamo inventare adesso delle clausole che vi ricordo le clausole sono i pezzettini di una formula CNF che sostanzialmente ci vanno a dire che la macchina ha un dato passo non può stare in più di uno stato. La testina non può stare su più di una cella, una cella di un del nastro non può contenere più di un simbolo. Come lo possiamo scrivere? in forma di clausola. Per ogni stato possiamo mettere eh che deve verificare solo una stata alla volta, quindi sarà ehm cos'era? Q and Q + 1 Q + 1 not QD + 1 K. E attenzione attenzione partiamo ad alto livello. Cosa vogliamo descrivere? per esempio che al passo i può essere sullo stato zero e non su tutti gli altri e non su tutti gli altri. Quindi, come la possiamo descrivere questa cosa in forma di implicazione? Se la macchina sta Se zero eh, allora non tutti gli altri. Esattamente. E questa cosa la possiamo scrivere così. Quindi facciamo un end gigantesco di queste cose, no? Per tutte le triple I, K e K' tali che K è diverso da K'. Che cosa abbiamo? è che se q è vero, allora Q di I K' deve essere falso. È chiaro il significato di questa implicazione? Cioè, qui stiamo prendendo tutte le triple di indici I, k e k' e le stiamo infilando questa lista lunghissima dentro la formula. Ok? Il significato di quelle implicazioni è se q è è vero, allora q i k' dove k' è diverso da k deve essere falso. È chiaro il significato? Quante sono quante sono queste clausole? Sono polinomiali o più di polinomiali? Polinomiali. sono polinomiali perché i gli I, gli indici I sono bound da PD N, k e k' sono bound da una costante, quindi il numero di clausole è polinomiale, ok? E dobbiamo fare una cosa simile per la testina. Questo me lo dite voi. Cosa scriviamo? Vi ricordo che le variabili, guardiamola assieme, le variabili per la testina sono le Hij in cui Hij vale true se al passo i la testina si trova sulla cella J. Quindi quello che noi dobbiamo andare a specificare è che non può accadere che a un certo passo la testina si trovi in due celle diverse. Ok? Come lo scriviamo a formula? Nello stesso modo I J' con J diverso J'. Sì, abbiamo che H implica not di H. Esattamente. Chiaro? Quante ne abbiamo là? Quante clausole ci sono? Polinomiale è un p n qu. Ok? Quindi questa formula continua a essere polinomiale. Ok? Quali sono? Qual è l'altra famiglia di variabili che abbiamo? T. Quindi dobbiamo imporre dei vincoli su T. Cosa facciamo? Vi ricordo il significato T di IJL. Al passo I. Sulla cella J ci sta il simbolo L. Sì, aveva scritto prima IJ. Ah, Jimo. Sì, prego. J e L I J. Poi L sì L' sì, con L'O diverso sì. E ci sarà T I J L. Sì. Eh, se è vero, allora sarà falso eh TDJ. Esattamente. Ok. E anche queste sono il numero polinomiale. Ok. Quindi il primo pezzo della formula, abbiamo detto la formula è fatta da quattro pezzi. Consistenza, consistenza stato di partenza. Next step stato finale. Ok? Questo è il pezzo della formula che si occupa della consistenza. Ok? Come vedete non è particolarmente difficile da scrivere. Il significato dietro è questo. Adesso guardate la formula così come è stata definita. Questo pezzo Cosa sta imponendo nello specifico? Sì, che solo uno della clausola è vero. Attenzione come tutte vere. Sì, ok. Tutte le implicazioni devono essere vere. Ma che cosa possiamo dire sul valore di verità di queste variabili? Per esempio, prendiamo Q di I K. Questo pezzo di formula sta dicendo che la macchina in un dato passo deve stare esattamente in uno stato o sta dicendo altro? Sta in al più uno stato. Sta in al più uno stato. Ok. Le gli altri pezzi della formula imporranno che la macchina deve stare in almeno uno stato e da cui otterremo che la macchina starà in esattamente uno stato. Ok? Quindi, se vogliamo essere proprio pignoli, questo pezzo di formula codifica che la macchina ogni passo sta in al più uno stato, la testina ogni passo sta in al più una posizione e che ogni cella del nastro per ogni passo contiene al più un simbolo. Ok? Poi gli altri pezzi della formula faranno sì che qualcosa ci sarà, ok? E i conti poi ci torneranno. Vabboh. Ok, vediamo se c'abbiamo spazio. Sì, scusi. Sì, quindi eh facendo una summa, la consiste sì si può definire che eh va a denunciare come la macchina un passo a un certo passo. Guardi soltanto uno stato e basta. sia in alpù uno stato, cioè che siccome noi abbiamo messo quella cosa là Q di K implica not QD K'nifica che un qualsiasi assegnamento di verità per F di V se vuole soddisfare file di W se sta assegnando vero a Q di 00 non può assegnare vero a Q di 01 Q di02 Q di03 quindi Quindi tutti gli assegnamenti di verità candidati a soddisfare file di W devono assegnare vero a un solo Q di K per ogni QDI per ogni I. Un solo HIJ vero per ogni I. Ok? Questo però ancora non ci sta dicendo quale farlo. Ci dice se la la l'assegnamento di verità vuole essere un assegnamento che soddisfi la formula, condizione necessaria e che rispetti questi vincoli. Chiaro? Scusi, ma noi con la forma di file Q andiamo a definire la forma di F oppure no? Noi stiamo descrivendo cos'è la formula F di W sputata fuori da F. Sì, F a ha tira fuori una formula fatta in questo modo. Sì, presentati un attimo M non deterministica. Sì, non posso che arriva a ogni passimo passo sono in due stati diversi, no? Perché se noi andiamo a vedere il computation tree di una macchina non deterministica e consideriamo uno specifico stato, una specifica configurazione, la macchina in quanti stati è? Uno. Quindi noi stiamo semplicemente dando la possibilità di codificare una qualsiasi computazione fra tutte le possibili. Però mentre la macchina tra virgolette processa, sappiamo che questa macchina in realtà non c'è, però in un branch della computazione la macchina in ogni istante si trova in un solo stato, non in più uno. È chiaro? Qui un un branzo 70. Noi dobbiamo codificare in questa formula tutti i possibili branch la macchina può mai eseguire. è quello che noi ci andiamo a chiedere se ce ne sta uno accettante fra i tutti. È chiaro? Chiaro per tutti come stiamo procedendo? Alright, quindi andiamo a la parte start della formula. Come vi dicevo, questo pezzo di formula fai deve codificare che la macchina si trova nello stato iniziale all'inizio che su nastro ci sta la stringa W per la lunghezza di W e poi tutto il resto. Una cosa che vi faccio notare è questi qua. Guardate le variabili T i JL. Ok? Come vedete quell'indice J può variare può tra 0 e PDN perché una macchina che compia al più P di N, cioè significa che noi stiamo andando a guardare un nastro la cui lunghezza è PDN. Questa cosa è sufficiente perché una macchina che compie PDN passi non potrà mai vedere nulla oltre quell'orizzonte. Quindi tutto quello che c'è sul nastro, al di là di quella finestra non potrà mai influenzare il funzionamento della macchina perché la macchina non avrà il tempo di andarlo a vedere. Ok? Quindi abbiamo necessità solamente di guardare un pezzo di nastro, un pezzo di lunghezza polinomiale. Perché? Perché in tempo polinomiale la macchina non avrà mai il tempo di essere influenzata da qualcosa che sta al di fuori di questa finestra. Ok? Quindi tutto quello che ci interessa della computazione della macchina sta fra la cella numero zero e la cella PDN. Quando perciò noi codifichiamo la configurazione iniziale della macchina in cui diciamo la macchina al passo zero sta nello stato zero, nella porzione iniziale di nastro ci sta w e in tutto il resto che ci sta? Ci sta un bl. Quindi questo lo dobbiamo scrivere in S. Come me lo scriviamo. Come lo scriviamo? Tipo dobbiamo dire che la macchina al passo zero sta nello stato zero, che è lo stato iniziale. Come lo scriviamo? Q00 Q00. Quindi questa variabile proposizionale sarà vera solamente se l'assegnamento di verità gli davvero, non c'è non si scappa. Quindi se mettiamo questo in endro, l'assegnamento di verità, condizione necessaria per l'assegnamento di verità che soddisfa file di W è dare vero a Q di 00. Ok? Poi dobbiamo dire che il resto del nastro nel all'inizio del nastro ci sta W, al resto del nastro ci sta ah blanc. Ok? Quindi al passo zero lo stato è q0. Al passo zero dove sta la testina? Zer nella cella zero. E come lo scriviamo? H H. Dopodiché dobbiamo dire che nella cella 0 ci sta la il primo simbolo w V alla cella 1. Ok. Come facciamo? Sto dando la soluzione. Quindi dobbiamo dire che al passo zero in posizione 0 ci sta il primo carattere di W, chiamiamolo V0, per esempio. Come lo possiamo scrivere? T 0. Per semplicità scriviamo V0. Ok. Lì dovremmo scrivere l'indice del simbolo. Ci scriviamo V0 intendiamo che è il simbolo che appare in zeresima posizione di W. Dopodiché cosa avremo? t 1 v1 and t di 02 v2 bla bla bla fino a t di 0 n - 1 V n - 1. Ok? Dopodiché cos'altro ci sta? T di 0 di N che ci sta in posizione N al passo zero sul nastro blank. è in posizione n + 1 black. Fin fin dove dobbiamo arrivare? T di 0. Qual è l'ultima cella? Pn. Pdn che ci sta in posizione PDN. Leng. Ok. Quindi questo è il pezzo S. Questo pezzo S, come vedete, è una formula un po' particolare, è una formula CNF in cui tutte le clausole hanno taglia uno, hanno un solo letterale. Ok? Quindi cosa significa questa formula? che al passo zero siamo nello stato Q0, che al passo zero la testina sta in posizione 0, che al passo zero abbiamo eh che al passo zero in posizione zero sul nastro c'è la il zeresimo lo zeresimo simbolo di w così via fino a n - 1 e poi abbiamo tutto il resto blend. Ok, spazio ne abbiamo non a sufficienza. Andiamo all'altra pagina. Oplà. Next. Next step. Ok. Quindi ora dobbiamo codificare che la funzione Tempo ne abbiamo. Sì. Dobbiamo codificare nella funzione che i prossimi next passi seguono la funzione di transizione. Ok? Allora, vi guido io. Qua ci sono un po' di cose a cui si deve stare attenti. Questa è la parte un po' più sofisticata della funzione. Eh, fatto questo, è finita la riduzione. Allora, la parte n della funzione f si deve occupare di alcune cose. si deve occupare appunto dell'evoluzione del contenuto del nastro della macchina in dipendenza della sua funzione di transizione. Ok? Sul nastro possiamo distinguere sostanzialmente due aree: la cella dove è collocata la testina e le celle dove non è collocata la testina. Ok? Quindi guardiamo prima le celle dove non sta la testina. Da un passo all'altro che succede al contenuto di queste celle? Scusla. Nulla. non succede niente. Cioè, quindi un pezzo di questa formula dovrà descrivere che le parti di nastro dove non c'è la testina da un passo all'altro devono mantenere lo stesso contenuto. Un altro pezzo di n dovrà descrivere che i pezzi di nastro dove c'è la testina cambiano secondo la funzione di transizione e quello sarà il pezzo un po' più sofisticato. Dopodiché avremo un pezzo Next Step da codificare. È quello che dicevamo all'inizio che la macchina deve computare in esattamente PDN passi. Quindi un pezzo di N si dovrà occupare di far sì che i branci di computazione abbiano tutti lunghezza PDN. Quindi una volta che arriviamo in una configurazione finale, questa configurazione viene ripetuta di passo in passo fino a quando si arriva a PDN. Ok? Però questo lo vediamo dopo. Concentriamoci prima su la parte dell'inerzia. Lo chiamiamo inerzia e sostanzialmente le parti di nastro lontane dalla testina. rimangono invariate da un passo all'altro. Ok? Quindi dobbiamo codificare questa cosa qua. Lo chiamiamo N di. Come lo possiamo definire? Quindi ora dobbiamo scrivere a formula questa cosa qua. Se al passo I la testina non sta sulla cella J, il contenuto della cella J al passo D + 1 lo stesso di quello che era al passo D. Come lo scriviamo a formula? Ripeto, dobbiamo scrivere a formula questa cosa qua. Andate a guardare che variabili proposizionali disponiamo. Noi dobbiamo descrivere a formula questa cosa qui. Se al passo I la testina non sta in posizione J, allora il contenuto del nastro in posizione J al passo I sarà lo stesso che avremo al passo I + 1. Come si scrive? Not Hj. Not H i J implica. Attenzione, quindi con not H i J stiamo sc stiamo dicendo la testina al passo I non sta in posizione J. Adesso dobbiamo scrivere che il contenuto del nastro in posizione J al passo I viene replicato al passo di I + 1. Come facciamo? Sì. Alla prima parte mettiamo T I B J L. Sì. Noi implichiamo sì che eh TD I J T di al passo successivo I + 1 J vir L. Che significa sta formula? Riguardiamolo assieme. Se la testina al passo I non sta in posizione J e inoltre al passo I in posizione J abbiamo il simbolo L, l'ellesimo simbolo, allora al passo I + 1 in posizione J il simbolo deve essere lo stesso. Ok? È chiaro il significato di questo pezzettino? Ovviamente questa cosa deve valere per tutte le triple I, J. Eh, andiamo qua. Quindi per tutte le triple I J L. Chiaro? È chiaro il significato di sto pezzo? Sto pezzo semplicemente sta dicendo se la al passo I la testina non è in posizione J e inoltre al passo I in posizione J ci sta l'ellesimo simbolo, allora al passo D + 1 in posizione J sul nas ci deve essere nuovamente l'esimo simbolo. È chiaro? Quello è il significato di quella formula, di quel pezzo. Ok? Questo gestisce solo l'inerzia, cioè le porzioni di nastro lontane dalla testina rimangono invariate da un passo all'altro. Ora ci serve un pezzo di formula che codifica la funzione di transizione. Ok? Questo lo facciamo facciamo un esempio perché è un po' più difficile. Allora, diamo un semp un esempio. Poi ovviamente è una cosa ci mettiamo in questo pezzo di formula è una generalizzazione di questo che vediamo, ok? per ogni pezzo della funzione di transizione del tipo delta Q di K alfa L. QK' alfa L' destra oppure QK' alfa L' sinistra, eccetera. Quindi noi quello che dobbiamo andare a fare ora che cos'è? Noi dobbiamo andare a guardare la funzione di transizione della macchina. La funzione di transizione della macchina a questa struttura per ogni coppia stato simbolo ci dà una serie di triple, diciamo una serie perché la macchina è non deterministica. Quindi per ogni coppia stato simbolo la funzione di transizione ci dice quale, come l'avevo chiamato questo qondo. Vai, chiamo k second così. Ok? Per ogni avremo cose di questo tipo. Data la coppia stato simbolo, la macchina andrà in uno stato, scrive un certo simbolo e muove la testino a destra o a sinistra. Ok? Quindi noi dobbiamo andare a codificare dentro un pezzo di formula questa cosa qua. Ok? Questo è solo un esempio perché ovviamente può essere più ricca, però l'importante è dare un'idea. Ok? Quindi avremo next step H che codifica il funzionamento sulla testina. sarà qualcosa di questo tipo. Quindi dobbiamo dire codifichiamo questa cosa qua che al passo iesimo, questo lo scrivo un attimo meglio, che era una virgola, questa è virgola. Ok, dobbiamo scrivere questo pezzo di formula. Se al passo i la macchina sta nello stato cappesimo, la testina sta in una certa posizione J e in quella cella c'è il simbolo ellesimo. Allora, andiamo nello stato K' scriviamo il simbolo L'O e spostiamo la a sinistra a destra di di un passo la testina. Come possiamo scriverla questa cosa? Quindi dobbiamo dire che al passo I la macchina si trova nello stato K. Come lo scriviamo questo? H. Attenzione, attenzione, partiamo. Prima la macchina al passo I si trova nello stato K. Q. Q. Ok. Poi dobbiamo dire che la testina al passo I sta in una certa posizione J. H. Poi dobbiamo dire che al passo I in posizione J ci sta il simbolo esimo. Come facciamo? T i j. Quindi questo pezzo di formula ci dice se al passo i, se al passo I la macchina si trova nello stato K, al passo I la testina si trova in posizione J e al passo I in posizione J abbiamo il simbolo alfa L. Allora, in che stato saremo? al passo i + 1 m k' quindi saremo come q I + 1 K' dove sarà la testina al passo i + sarà in J + 1. Quindi cos'è? Hi + 1 J + Cosa ci sarà al passo i + 1 in posizione J sul nastro? L'fa l' quindi è T I + 1 J L'. Sì, scusi, la testina al passo + 1 non sta in posizione J diverso da J' perché può essere o a destra o a sinistra rispetto alla posizione della testina al passo in. Non ho capito. Ripendi. Allora, quando noi muoamo la testina andiamo naturalmente destra e sinistra. Sì. In questo caso, come sta considerando il caso iniziale, qui sicuramente non devo per forza andare a destra, no? Quindi quando eh vado a costrellare la seconda parte di implicazione, lei ha messo H, appunto, si va a costare la testina 1, jo, quindi vuol dire che io vado necessariamente a destra. Sì, ma non voglio indicare che vado o a destra o a sinistra. Questo lo dobbiamo scrivere ora. Ah, scusa. Ok, però buona osservazione. Questo pezzo di di di formula sta codificando solamente questa cosa qua. Ok? Però la macchina è non deterministica, quindi può avere un'altra scelta. Come gli diamo un'altra scelta? Semplicemente ci mettiamo un OR qua. Quindi, qual è l'altra opzione? Che al passo i + 1 la macchina si trova in quale stato? K second. La testina dove si troverà? al passo i + 1 J - 1 J - 1 e su nastro al passo i + 1 in posizione J avremo L second. Ok? Quindi abbiamo questa regola di implicazione che ci sta. È un esempio di codifica di funzione di transizione. Se la funzione di transizione ha più scelte, questa cosa c'ha più roba inor in testa. Ok? Qui abbiamo fatto solo un esempio. Ovviamente questa cosa va definita per tutte le triple IJL. Sì, non anche, però diciamo che può andare da un lato o dall'altro. Ok? È la stessa cosa. La macchina fa destra sinistra in caso gli serve. Ok? Se diciamo che la testina sta ferma hi + 1 j. Ok? E poi questo va definito per tutte le triple IGL. Ok, ci siamo quasi, resistete. Ok, quindi e questo è il pezzo di next step che gestisce la testina. Poi ci serve, quindi uno era questo qua, l'altro è questo qua, poi ci serve che cosa? ci serve la parte del padding, cioè tutte quei passaggi fittizi che ci siamo inventati che la macchina deve compiere per fare esattamente PDN passi. Ok? Questa è una cosa che ci serve a semplificare la parte f della formula, ok? Quindi n di padding. Allora, quello che noi dobbiamo dire sostanzialmente è questo è che se a un certo passo i la macchina entra nello stato Fale, allora al passo successivo la macchina sta nello stesso stato e il nastro è invariato, la testina non si sposta e il nastro è invariato. Come lo scriviamo? Quindi a un passo i la macchina entra nello stato finale che lo chiamiamo F. Quindi se è al passo i la macchina entra nello stato F e inoltre al passo I la testina sta in posizione J e inoltre al passo I in posizione J sul nastro c'è il simbolo esimo. Allora al passo i + 1 la macchina sta nello stesso stato. La testina al passo i + 1 non cambia di posizione e al passo I + 1 il contenuto del nastro è lo stesso identico. Ok? E questo va fatto per tutte le triple IJL. Sì, non ho capito la tipa di padding nel senso. Ok. È questo, è questo il padding, è questa cosa qua, sono i passaggi rossi, nel senso se arriviamo a una configurazione finale, indipendentemente se sia accettante o meno, noi facciamo questi passaggi fittizzi che replicano il contenuto del nastro, in maniera tale che per vedere se la macchina ha accettato o meno, andremo all'ultimissimo passo, al pdesimo, per vedere se c'è lo stato accettante o meno, in maniera tale che non ce lo dobbiamo cercare in mezzo all'albero dov'è l'accettazione. Ok, andiamo in fondo. Questo è giusto un trucchetto. Dove sta? qua. Quindi questo pezzo di formula ci dice che se la macchina M al passo I entra nello stato finale, la testina al passo I stanno in posizione J e al passo I la posizione J sul nastro c'è il simbolo esimo, allora al passo di dopo la macchina sta nello stesso stato, la testina sta nello stesso posto e il contenuto del nastro è lo stesso. Ok? Questo però gestisce che cosa? Solamente gli stati accettato accettante. Serve un pezzo di formula che fa il padding quando entriamo in stati non accettanti, ok? Cioè, quindi entriamo in una configurazione in cui siamo in uno stato, leggiamo un simbolo per i quali la funzione di transizione non è definita. In quel caso dobbiamo far sì che la macchina rimanga nello stesso stato, la testina rimanga nello stesso posto e sul nastro non succede niente di strano. Ok? Questa cosa la facciamo così, ve la scrivo io, molto simile per tutte le triple I, JL. E inoltre per tutti gli stati QK appartenenti a Q e tutti i simboli alfa L appartenenti a gamma tali che la funzione Q alfa di L è vuota. No, non è definita, abbiamo la stessa identica cosa, cioè Q di I K and H I J and T I J L implica Q di I + 1 K and H di I J and T I J È chiaro? È la stessa identica cosa, solo che è definita per tutte le coppie stato simbolo dove la macchina si blocca. Cioè, quindi che cosa ho scritto là? per tutte le triple IJL e tutte le coppie stato simbolo tale per cui la funzione di transizione non è definita su quella coppia. Allora, se al passo i la macchina sta in quello stato, la testina sta in posizione J e in posizione J sul nastro c'è il simbolo ellesimo, quella cosa viene replicata al passo successivo. Sì. Domanda. Eh, ma il parking noi l' andiamo a spiccare soltanto nei rami che vanno eh diciamo e nelle configurazioni finali. una configurazione finale se la macchina non può o entra in uno stato accettante o si sta andando a inceppare in uno stato non accettante. Però siccome la nostra definizione, per esempio, se andrete a vedere gli appunti di Calautti lì lui ha uno stato rifiutante. Noi stati rifiutanti non ce l'abbiamo. Per noi è uno stato rifiutante quando c è uno stato in cui la testina legge un simbolo per il per la quale non non ci aspettiamo di vederlo in quello stato e quindi la macchina si ferma là. Quindi lì che cosa scriviamo là? Che quando siamo in uno stato e leggiamo un simbolo tale per cui questa cosa non è prevista dalla funzione di transizione, allora noi lo replichiamo il passo successivo. Tutto qua? Ma scusi, quando arriviamo alla fine dell'al stato finale, cioè noi applichiamo la parte dello stato accettante, cioè nel senso noi non possiamoare questa cosa per ogni stato. Attenzione, noi non lo stiamo facendo, noi stiamo inserendo nella formula FW le possibilità, sarà l'assegnamento di verità che che si dà alle alle proposizioni, no, alle variaboli proposizionali che sarà un assegnamento di verità true false che va a specificare cosa esattamente sta succedendo nella computazione. Ma noi non lo stiamo non sappiamo quale sarà questo assegnamento. Stiamo costruendo una formula il cui assegnamento di verità che la soddisfa deve soddisfare dei vincoli che vanno a simulare il funzionamento di una macchina di Turing. Ma quale sia? Mica noi lo sappiamo, perché se lo dovessimo calcolare quello prenderebbe tempo esponenziale. Ma una domanda stupida. Ma nessuna domanda è stupida. Eh, ma in questa fase, cioè questa fase noi stiamo già dimostrando oppure siamo in predimostrazione? No, qua siamo solo stiamo mostrando che cosa spunta fuori la funzione di trasformazione. Poi è ovvio che questa funzione di trasformazione tira fuori una file talmente rifinita che si sta portando appresso la ragione per cui funzionerà. Questa è la questione, però finora stiamo descrivendo solamente che fa F e non abbiamo nemmeno finito perché manca un pezzo, ragazzi. È chiaro? Cioè, che fa sta F, guys? Gli ultimi 5 minuti? Pensavo di finire prima e invece no. Allora, questi quindi li sfruttiamo. Sì, dell'ultima che scritto sarebbe al Yes. Yes. Quello è sbagliato. Sì. Questo è hi + 1 j e questo è ti + 1 j. Ok. Alright. Siete sopravvissuti, ci siete? dell'ultimo pezzo. Ok, quindi la funzione next step, wow, è pieno, è fatta da next step, è fatto next dell'inerzia and next gestione della testina and next per il padding. Ok. Alri, lo mettiamo qua perché è inutile mettere una pagina nuova. Cosa ci manca? Ci manca F. F. Dobbiamo dire che all'ultimo passo che è il p di ennesimo, quindi finish che f all'ultimo passo lo stato è accettante. Come facciamo? [Musica] Attenzione, attenzione. Noi dobbiamo semplicemente dire che al p di ennesimo passo lo stato e lo stato fin è lo stato accettante che è QF lo chiamiamo. Ok? Che scriviamo? Eh, Q di P. Finita è questa. Ok? Questa variabile per essere vera va assegnato vero a questo. È chiaro? Quindi la formula fai di docchia B è la congiunzione di tutta sta roba qua che abbiamo scritto DC, DS DN D. Ok? Questa formula. Prego. Gli stati finale c'è uno solo, quindi quello Sì, sì, possiamo assumere che va tutto in uno stato soltanto. Ok. Senò sarebbe l'or degli stati finali della macchina. Ok. Ok. Allora, ultime considerazioni. La funzione f, quello che abbiamo detto, la funzione f, sputa fuori fai di w che ha è questa formula mostruosa che è, sebbene sia enorme e comunque di taglia polinomiale. Questa formula descrive tramite delle variabili proposizionali opportune il funzionamento di una macchina M. fissata che decide se W appartiene ad L o meno. Per come è stata definita la la formula in cui sostanzialmente stiamo andando a imporre dei vincoli a queste variabili proposizionali tali per cui gli assegnamenti veri falsi deve per forza replicare cosa fa la macchina M sul W. Di conseguenza, per come è stato definito file di W, W appartiene ad L. Se solo se la macchina M accetta W. Se che è se solo se la formula F di W è soddisfacibile, non si scappa. Questa formula è in CNF perché, come avete visto, abbiamo usato solo implicazioni e quindi un qualsiasi linguaggio di NPL che non conosciamo ammette una riduzione di questo tipo verso SAT da cui un qualsiasi linguaggio di L di NP si riduce a SAAT e quindi SAT è NPO. Avevamo già visto nelle lezioni passate che SAT è anche l'NP perché basta diessare l'assegnamento di verità e quindi SAT è NP completo. Infatti SAT è uno dei problemi che si usa per codificare altri problemi NP. ci sono dei solutori, si chiamano SAT solver programmi, il cui scopo è data una formula buleana mostruosa, cercare di vedere se sia soddisfacbile o meno. Perché esistono questi software? Perché tanti problemi in NP, tutti i problemi in NP in realtà, però spesso si usa proprio in pratica, vengono trasformati in formule buleane enormi che vengono dati impasto ai salver e il salver cerca di capire se la formula sia soddisfacibile o meno. Ci pigliamo la risposta e sappiamo se la distanza del problema di partenza era sì o no. Ok? E va bene, con questo chiudi diamo anche per Grazie per essere venuti.