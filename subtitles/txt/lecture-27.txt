Ok, ultimissima lezione. Ultimissima lezione. Domani, domani facciamo una prova di esame. Ok? Allora, cosa vediamo oggi? Oggi vedremo un ultimo topic in linea con quello che abbiamo visto l'ultima volta che quindi è macchine oracolo, funzioni da calcolare, eccetera. Come l'altra volta abbia come Sì, la scorsa volta abbiamo visto il problema di eh calcolare la taglia del minimo vertex cover in un grafo. Abbiamo visto che si può fare tramite un trasduttore che chiama un oracolo, eccetera e ci permetteva di collocare quel problema in fp^ np o di log n che vi ricordo cos'è FP. ft è l'insieme delle funzioni che possono essere calcolate, ok? Funzioni calcolate da trasduttori deterministici in tempo polinomiale. FP^ NP significa che il trasduttore ha accesso a un oracolo. Intuitivamente, cos'è un oracolo? Un oracolo è una sabrutin che è in grado di risponderci a costo un passo delle quiri rispetto riguardo l'appartenenza o meno di stringhe al linguaggi. Ok? Noi gli chiediamo "Ma questa stringa fa parte del linguaggio?" E l'oracolo ci dice in un passo solo s No, l'oracolo può essere molto potente, può essere in NP, può essere in NextP, che ne so, ci sono classi tipo P alla next per dire, ok? Sono classi molto esotiche, però per farvi capire che l'oracolo può essere qualcosa di molto potente. Ok? L'oracolo calcola la propria risposta, decide l'appartenenza o meno della stringa di quiri alla alla al linguaggio e non ci costa niente, ci costa un passo, cioè il passaggio dallo stato domanda allo stato risposta. Ok? Dopodiché avevamo visto che sì, siamo Sì, sostanzialmente sì, cioè l'intuizione dietro è che noi possiamo fare delle chiamate a sabrutin, che è qualcosa che in genere facciamo. Però quello che si è visto è che in realtà queste macchine oracolo permettono di definire gerarchie, tipo la gerarchia polinomiale che ci dà la possibilità di stabilire la complessità specifica di problemi che space è troppo potente per loro ed NP non è sufficientemente potente e sta in mezzo. sostanzialmente no. Sono macchine che noi le usiamo per concettualizzare la la per dirvi, no, a che cosa serve. Abbiamo definito la gerarchia polinomiale, no? Abbiamo visto che sigma p2 è il secondo livello della gerarchia polinomiale in cui sono praticamente i linguaggi che possono essere decisi da macchine in NP con oracoli in NP. Ok? Questo è sigma P2. Ci stanno un sacco di problemi interessanti là dentro, alcuni problemi su grafi particolari, vari problemi di teoria dei giochi, cioè quando ero uno studente dottorato io mi occupavo di quella roba e stanno in sigma P2. Adesso che cosa ci dice? Come lei diceva, ma noi una macchina del genere non la possiamo usare. A che ci serve sapere che un problema è sigma +2 completo? Significa che è un problema tosto per quella classe, perché poi abbiamo la definizione di completezza per tutti questi livelli che stanno in mezzo, come abbiamo NP completo, P spazio completo, Nextp completo, ci sono i sigma P2 completi, sigma P3 completi, eccetera. Che caratteristica ha un problema sigma P2 completo? un problema sigma P2 completo intuitivamente sono quei problemi, ad esempio, un problema in NP sono quei problemi che ci serve una procedura in backtracking per risolverlo. L'avete visto? Algoritmi e strutture dati, no? Che dobbiamo il problema delle otto regine pa pa, facciamo in in backtracking per riuscire a collocare i pezzi su. Non l'avete visto? Otto regine, abbiamo una scacchiera, ok? Immaginatevi una scacchiera, dobbiamo mettere otto regine sulla scacchiera senza che si mangino. Ok? Questo è un problema tosto, è un problema combinatorico. Come si fa? si fa in back trading, cioè si fa a prove, cioè io provo a metterla là, poi ne provo a mettere un'altra e mi chiedo è sensato quello che sto facendo fino a fosse simile per il progetto che fare era l'anno dopo non so qualè, era forse fatto prima. Sì, le robe che si risolvono in backtracking generalmente sono NP completi. Come facciamo? tentiamo di assemblare una soluzione, dopodiché facciamo un check polinomiale. Per esempio, le otto regine. Ci chiediamo "Ma si mangiano o non si mangiano?" Il test è polinomiale una volta che stanno là perché basta controllare i i rami di attacco. Fatto questo, se non si manda c diciamo sì, questa è una posizione coerente. Se no diciamo no e dobbiamo tornare indietro e e spostiamo, per esempio, l'ultima che abbiamo collocata, finite i tentativi per l'ultima regina e se non abbiamo trovato niente andiamo alla penultima e iniziamo a fare queste cose. Ok? Quindi questi sono gli algoritmi backtracking che sicuramente avete visto. Che caratteristiche hanno quindi questi questi algoritmi back trading? Che noi tentiamo di costruire la soluzione per verificare se la soluzione sensata facciamo un test di tipo polinomiale. Ok? Questi sono i problemi in NP. i problemi sigma P2 completi. L'intuizione. Quando noi sappiamo che un problema è sigma P2 completo, noi sappiamo che per risolverlo un algoritmo in back tracking pla, cioè servono due livelli di backtracking innestato, nel senso che io faccio tramite backtracking [Musica] colloco la prima la soluzione, ma poi per sapere se la soluzione è corretta io devo lanciare un altro algoritmo di backtracking, cioè quindi abbiamo due fonti di complessità ortogonali tale che per cui significa che non è che posso fare un gess e me la risolvo. Devo fare tentativi per una parte, ma pure il check va fatto a tentativi perché è talmente complicato. Sigma P3 tre sorgenti di complessità ortogonali e sign significa mi serve una procedura di backtracking che per testarla la la validità devo far partire un'altra procedura di backtracking che utilizza un'altra procedura di backtracking. C'è quindi queste sono per esempio procedure che su macchine deterministiche prendono tempo doppiamente esponenziale perché mi serve un num devo esplorare un numero esponenziale di soluzioni candidate e ogni test mi prende No, no, è sempre esponenziale, ok? Mi prende il tempo esponenziale, ok? 2^ 2 2 sì, rimane esponenziale perché 2^ n * 2^ n è ancora esponenziale, non è doppiamente esponenziale, ok? Quindi sono sapere che un problema è sigma pk completo sigma p2 completo. Noi non abbiamo delle macchine che facciano queste cose qua, ma ci danno degli indizi su che faccia ha l'algoritmo che lo risolve. Cioè, noi non potremo sperare di risolvere un un problema sigma P2 completo con un algoritmo playing back tracking. Non ce la fa, a meno che non vogliamo dare una risposta approssimata. Cioè questa è la cosa per definire definire questi problemi per risolvere in maniera Esattamente. Perché nel momento in cui diciamo, guarda, questo problema è difficile per due ragioni, cioè ha una sorgente di complessità esponenziale in due parti, significa che io non me la non me la sbroglio con una semplice ricerca esponenziale, mi serve più tempo. Quando appronto l'algoritmo per un problema sigma +2 completo, qua c'è questo bellissimo algoritmo playing plain backtracking ed è sigma P2 completo. Sicuramente quell'algoritmo non funziona perché sappiamo che il problema è piuttosto di quello là e non può essere risolto in così poco tempo. Questa è l'intuizione. A che serve studiare la complessità? Serve a vedere ok, ma quali algoritmi mi risolvono questi problemi? Oppure nel momento in cui scopro che un problema ha due fonti di complessità, quindi è sigma +2 completo, quello che mi potrei inventare è ok, siccome ha due sorgenti di complessità, una delle due la posso semplificare, posso fissare delle cose in maniera tale che una se ne va via e il problema così semplificato non diventa polinomiale, ma almeno diventa in NP e ce la faccio con un algoritmo più banale, capito? cose di questo tipo. Quindi non ci interessa tanto la macchina che lo risolve, ma come diceva lei è stabilire quanto è difficile il problema, come lo risolvo. Questo è il senso del dello studio della complessità. Eh, ok. Quindi, macchina, oracolo, trasduttore, abbiamo detto pla. Quello che facciamo oggi è vedere un altro problema che quasi sicuramente avete già visto e lo vediamo sotto la doppia natura di problema di calcolo e problema di decisione. Ok? Il problema che vediamo oggi è il TSP Traveling Sales nel Problem nella sua versione computazionale. Allora, diamo prima altre definizioni, ok? Eh, grafo pesato. Sapete tutti cos'è un grafo pesato. Lo scriviamo giusto grafo pesato. Per avere una definizione comune. Un grafo pesato è un grafo orientato o meno, quindi è un g fatto da vertici archi. è una funzione lambda di labeling che una funzione lambda è una funzione che mappa archi su interi, cioè è una funzione che associa un peso agli archi del grafo. Questo è un grafo pesato, è un grafo con nodi, archi, è una funzione che assegna pesi agli archi. Ok? Questo è un grafo pesato, questo riorientato meno. Oggi vedremo grafi orientati e grafi non orientati. Ci serve eh dopodiché, cos'è uniltonian cycle? Unemzione in un grafo orientato o meno è un ciclo, quindi è un percorso che parte da un nodo e arriva allo stesso nodo, tale per cui visitiamo, a parte il nodo di partenza e arrivo che è lo stesso, visitiamo tutti gli altri nodi del grafo esattamente una volta. Ok? Questo è un Hamiltonian Cycle. Il peso di un pat o di un ciclo è semplicemente la somma dei pesi degli archi percorsi in questo percorso. Ok? Ok. Come definiamo FTSP? Functional traveling salesmell problem. Allora, a parole è semplicemente dato un grafo non orientato, vogliamo calcolare in questa variante lo vediamo più semplice, eh, però comunque sempre problema di calcolo è vogliamo calcolare il peso delle miltonian cycle di questo grafo. peso minimo. Ok? Quindi è una funzione è dato dal minimo di cosa? Sul lambda di pi dove pi è un Hamiltonian cycle di G che è V è lambda. Ok? Quindi ci danno un grafo. Questo è non orientato. E ci danno un grafo non orientato, pesato sugli archi. Noi vogliamo calcolare il peso dell'emiltonian cycle più leggero. Questo è Ok. Dell'Emiltonian Cycle. Ottimo. Ci occuperemo prima della della questione appunto della funzione di calcolo, poi andremo a guardare la hardness come abbiamo fatto la volta scorsa. Ok? Supponiamo di disporre, quindi risolveremo questo problema tramite una macchina oracolo, come abbiamo fatto per il problema del minimal vertex cover. Supponiamo di avere un oracolo per TSP, che è la versione di decisione di questo problema che dato una coppia GK dove G V è un grafo non orientato [Musica] e G ammette [Musica] un Hamiltonan cycle di peso al più K. Ok? Quindi cosa sono le istanze S di TSP? Sono le coppie GK, dove G è un grafo non orientato e K è un intero. Eh, sorry, qua è sbagliato. Eh, ovviamente il grafo deve essere pesato. Quindi G è un grafo pesato, non orientato e noi ci chiede e K è un intero. È vero o no che esiste un Hemiltonian cycle in Geso al +K? Questo è il problema. Ok? La versione di decisione di FTSP che è quello, sì, lo vedete, visto doando. Alrght, allora noi ci chiediamo come possiamo risolvere FTSP tramite chiamate a un oracolo per TSP. Sì. Eh, potremmo chiamare TSP su K sempre precotteniamo la prima soluzione. Quando otteniamo la prima soluzione. Ok. semplice questa macchina, quindi la puntiamo qua perché ci dobbiamo ragionare. Quindi prima soluzione. Professore, grafizzato avete anche presa negativa? Per semplicità facciamolo solo pesi positivi. Ho messo qua lambda che mappa su n, quindi è positivo. Ok? Sì, perché ovviamente se poi abbiamo un ciclo negativo succede un casino. Ok. Alri, prima soluzione, chiamiamo l'oracolo per TSP su istanze GK con K = 1 2 3 bla bla bla bla. Ok? Fino a quando? Riceviamo sì dall'oracolo. E se il grafo non ha unemtonian cycle che succede? Che non termina non termina proprio o abbiamo un limite in cui ci possiamo arrestare? Ah, beh, quando K è maggiore del numero di noi nel grafo, attenzione, K. Sì. Ok. Quindi noi facciamo k bla bla bla 1 2 3 bla sum dove per sum intendo la somma di tutti i pesi di tutti gli archi nel grafo. Se arriviamo alla fine, quindi se arriviamo a Sam e l'oracolo risponde ancora no, allora G non ammette un Hamiltonian. Cycle. Ok, è chiaro? Prima domanda. Questa procedura in quale classe ci permette di collocare FSP all MP. FPduttore, perché calcoliamo alla NP. Siete sicuri? Questa è una parte Ricky. Quanto tempo ci mette il trasduttore a fare tutte ste domande? Ce ne fa poche o tante? Quella è la questione. Poche. Tante o tantissime? Tante. Tante o tantissime? Ne fa logaritmiche? No. Ne fa polinomiali? No, no. E di più perché sulla taglia del Esattamente. Ne fa un numero esponenziale. Ok. Questa procedura non colloca il problema. Mettiamo un bel colore rosso così non ci confondiamo. Questa procedura non colloca il problema in FP all NP perché è la macchina che fa testa K1 e poi testa K2 e 3 e 4 e va avanti. Qual è il problema? che il limite massimo a cui devo arrivare è la somma di tutti i valori su tutti gli arti che stanno in quel grafo. Ok? Quindi noi lo prendiamo, lo sommiamo e abbiamo un upper bound verso il quale possiamo arrivare e poi fermarci. Il problema qual è? E con questi numeri, se scritti in binario, nell'input, noi facciamo un numero di chiamate pari al valore della somma di questi numeri e il valore della somma di questi numeri è esponenziale nella taglia per rappresentare in binario la somma di questi numeri. Quindi la complessità, che vi ricordo è una funzione della taglia dell'input, non una funzione del valore dell'input. Questa procedura esegue un numero di chiamate esponenziale nella taglia dell'input, ok? Quindi questa procedura non colloca il problema in FP alla NP, ok? è troppo lento, non ce la facciamo. Il trasduttore gli serve più tempo, gli serve tempo esponenziale. Potremmo definire una classe di complessità FXP e dire che questo problema sta in fp np? No, in quel caso non è necessario perché nel momento in cui abbiamo un trasduttore esponenziale chiamare l'oracolo non ci serve. In tempo esponenziale qua sto un po' facendo una digressione un po' sofisticata. Comunque questa procedura non ci dà la garanzia, cioè non non ci colloca il problema in FP alla NP. Ci serve una seconda soluzione. Come facciamo? Come facciamo? Sì, facciamo una ricerca binaria. Facciamo una ricerca binaria. Ok, quindi come primo passo testiamo se G SAM, dove SAM è la somma di tutti i valori bla bla appartiene a TSP. Se l'oracolo risponde no, allora G non ha un Hamiltonian cycle. Quindi questo è il primo test che facciamo, altrimenti procediamo con una ricerca. binaria in quale dominio? sul dominio G come G anche 0 Sì e poi 1 Sam è Z tra zero e SAM perché noi non sappiamo se cioè quando noi facciamo la prima domanda l'oracolo ci dice sì esiste un Hemiltonian cycle di peso al più sum che è la somma di tutti i numeri su tutti gli archi, però noi non sappiamo se sta vicino a Sam o lontano da Sam, ok? Quindi facciamo una ricerca binaria su questo intervallo. Una volta che lo sappiamo, sappiamo come muoverci. Becchiamo là la metà, scartiamo una metà, andiamo avanti fino a quando troviamo il valore minimo. Ok? Questa procedura in quale classe ci colloca il problema? Quante domande facciamo all'oracolo? comearmiche logaritmiche nella dimensione del dominio. Ok? Quanto è grosso il dominio rispetto all'input esponenziale? Quindi noi facciamo un numero di domande logaritmiche nella dimensione del dominio di ricerca. La dimensione del dominio di ricerca è esponenziale nella taglia dell'input. Di conseguenza il numero di domande che facciamo all'oracolo è polinomiale nella taglia dell'input. È chiaro questo passaggio? Il fatto che noi facciamo una ricerca binaria non determina che questo problema sia in FP all NP lo perché perché il dominio di ricerca è enorme. Ripeto, il dominio di ricerca di questa ricerca binaria è zero s. questo dominio è enorme rispetto alla taglia dell'input, cioè il numero di elementi che stanno in questo dominio è esponenziale nella taglia della rappresentazione dell'input. Quindi se io faccio se noi facciamo un numero di chiamate all'oracolo che è logaritmico nella dimensione del dominio di ricerca e questo dominio di ricerca ha una dimensione che è esponenziale nella taglia dell'input, allora un numero logaritmico di una dimensione esponenziale è un numero polinomiale nella taglia della rappresentazione dell'input. Ok? È chiaro questo passaggio? Di conseguenza noi abbiamo che il problema sta in FP alla NP, ma per la seconda procedura, non per la prima. La prima ci mette troppo tempo, ok? La prima ci collocherebbe il problema in fx. Chiaro? Ok, quindi quello che ora noi vogliamo fare, come siamo messi a tempistiche? Bene, direi. Allora, quello che noi vogliamo fare ora è se ci chiediamo se il problema fts functional tspenga ad fp. Ok? Cioè, ma a noi sta sto st'oracolo ci serve o non ci serve? è indispensabile avere l'oracolo per rispondere oppure esiste un algoritmo deterministico polinomiale che è in grado di risolvere il TSP? Sì, non può appartenere qui perché sennò e il nostro oracolo non sarebbe più in NP, ma sarebbe in P a quel punto. Ecco, però non lo sappiamo ancora. Allora, giusta l'osservazione che fa la nostra collega, noi dobbiamo l'appartenenza a Attenzione qui, eh è una cosa che abbiamo visto già la volta scorsa, la ripetiamo. l'appartenenza di FTSP [Musica] a FP. Finora abbiamo visto che functional tspartiene a FP alla NP, cioè un trasduttore polinomiale deterministico, semmai avesse accesso a un oracolo per il problema del TSP, lui saprbbe risolvere il problema TSP in tempo polinomiale. Ok? Questo è quello che abbiamo dimostrato finora. La nostra domanda è: ci serve o non ci serve l'accesso all'oracolo? Cioè, siamo in grado di risolvere questo problema in tempo polinomiale plain senza avere aiuti da casa? La questione, come ci sottolineava la nostra collega, è questa cosa qua. Dipende dalla complessità di TSP, della versione decisionale del problema. Perché se tsp np completo, cioè se tsposto, allora noi potremmo risolvere fts, cioè la la versione funzionale di quel problema, in tempo polinomiale solamente se t fosse uguale NP. Perché se noi fossimo in grado, seguitemi qui, se noi fossimo in grado di risolvere functional tspinomiale, noi potremmo risolvere TSP, la versione di decisione in tempo polinomiale. Come ci calcoliamo il peso del Hamiltoni Zyigolle più leggero che stiamo assumendo essere fattibile il tempo polinomiale. Una volta che abbiamo questo numero, lo confrontiamo con il K che ci passano input e stabiliamo se quella è un'istanza sì o no di TSP decisionale. Quindi se FTSP fosse risolvibile in tempo polinomiale deterministico, allora il TSP, la versione decisionale sarebbe risolv sarebbe in P. Ok? Cioè questa è la conseguenza. Se noi dimostriamo che TSP invece è un problema n completo e che quindi il sunlight, cioè è poco probabile che sia un problema P, allora a quel punto noi sapremmo che anche F TSP, la versione di calcolo del TSP con bassissima probabilità sarà risolvibile in tempo polinomiale, a meno che NP non collassi su P, che è è una cosa che non ci attendiamo che accade. Ok, è chiaro il ragionamento? Quindi ora noi possiamo spostare il nostro focus attentivo. Noi stiamo partendo da questa domanda: ma il TSP funzionale lo posso risolvere in tempo polinomiale? La nostra considerazione ci dice possiamo farlo solamente se TSP non è NP completo. Quindi la domanda ora è: "Ma TSP è NP completo?". Quindi quello che ora faremo da qui al resto della lezione è mostrare che TSP, che il problema del traveling problem è un problema NP completo, cioè un problema tosto della classe della classe NP. Ok, chiaro per tutti? Al come siamo messi? Ora sarà un pochino lunga, eh. Quindi noi dobbiamo dimostrare che TSP è NP complete. Vi ricordate quali sono i due elementi per dimostrare che è un problema NP completo? Comeare una macchina che risolve il problema? Sì. E questo per dimostrare cosa? La ANP. Ok. Poi l'armes. E poi l'armes. Ok. membership. Qua sto scrivendo male oggi. Membership. Voi direte quando mai scrivi sempre male. Lo so. Allora, dobbiamo dimostrare che TSP è in NP. Membership in NP. Ok? Andate a guardare la definizione del problema. Quali sono le istanze del problema TSP? Eh, mettiamolo un po' assieme, vi diamo un'occhiata. Ok. TSP che sono coppie grafo numero, dove graf G è un grafo non orientato pesato. K è un bound. Dobbiamo decidere se esiste un miltoni cycle dipeso al + k dentro G. Questa cosa si fa in NP? Sì, come adesso la cycle. Sì, laudero. La mentoria di peso minore NK. Sì. E poi altro check che dovrebbe essere minore. Sì. Ok. Ok. Quindi si fa così. Gessiamo l'emiltoniano. Questo ciclo che ci gessiamo è polinomiale o è più grosso di polinomiale? Ha lunghezza esattamente pari al numero di archi, quindi di di di nodi. Sì, sì, sì. Ok, però non più degli archi presuizione è corretta, non più degli archi presenti sul grafo. Quindi è polinomiale o più di polinomiale? Polinomiale. Quindi abbiamo un guess polinomiale. Ok? Perché per mostrare la membership in NP vogliamo un guess polinomiale e un check polinomiale. Il guess è polinomiale. Check che dobbiamo verificare una volta che gessiamo un paquenza di nodi. Siamo un c effettivamente. Quindi che gli che i nodi siano effettivamente attaccati l'uno all'altro e non siano uno a Roma e l'altro a Trapani. Ok? Quindi che ci sia una strada che collega questi nodi, che sia un ciclo, quindi che non la che che partiamo e arriviamo allo stesso nodo. Poi cos'altro dobbiamo testare? Questa cosa è fattibile in tempo debo polinomiale finora? Sì. Altra caratteristica che dobbiamo testare che il peso sia come che il peso complessivo sia. Che il peso complessivo sia non eccè K. Cos'altro? che tutti i nodi siano contenuti all'interno del cibo per un esattamente una volta. Quindi dobbiamo assicurarci che non stiamo lasciando nodi per strada e che li stiamo visitando esattamente una volta. Tutto ciò è fattibile in tempo polinomiale? Sì. Ok. Quindi il problema TSP è un problema in NP. Ok. Allora, facciamo un introduzione a questo e poi [Applauso] No, non voglio spezzare l'argomento, facciamo pausa ora e poi riprendiamo fra una decina di minuti, sennò dobbiamo lasciare la cosa a metà. Ok. Mes Alri, quindi abbiamo dimostrato che TSP sta in NP. Quello che noi dobbiamo ora dimostrare è che TSP [Musica] NPR. Ok. Come le dimostriamo le hardness se non vogliamo sbattere la testa con la riduzione da tutti i linguaggi NP? Facciamo una riduzione da un problema che conosciamo essere NP arduo. Ok? Allora, la riduzione non la facciamo direttamente perché è complicata, faremo dei passi intermedi. Partiremo da tre sat. che lo riduciamo polinomialmente a DHC, dove DHC è directedonian cycle, che è un problema intermedio. Vedremo che cos'è questo. Lo riduciamo poi a HC che è non directed Hamiltonian Ziguciamo a TSP. Ok? Quindi dobbiamo fare un po' di passi. La riduzione complicata è quella da tre sat a DHC. Le altre sono abbastanza semplici. L'ultima è banale. Da HC a TSP è banalissima, un po' non dico rognosa, ma ci ci darà un attimo da pensare. DHC verso HC. Quella costa è trasformare tre sat in DHC direct del Newton Cycle che adesso definiamo. Ok. Cos'è DHC? DHC è l'insieme dei grafi G. G è un grafo orientato che ammette un Hamiltonian cycle. Ok? Quindi problema abbastanza semplice. In input abbiamo una cosa soltanto che è un grafo orientato. Noi ci chiediamo se questo grafo abbia o meno un ok? Riduzione da 3 SAT e ci dobbiamo inventare un po' sta cosa. Quanto spazio c'è a sufficienza? Quindi problema di partenza tre esat. Problema di arrivo DHC. Cos'è un'istanza di tre sat? Una formula F. Una formula fai. Cos'è un'istanza di DHC? È un grafo. G. Quindi ci dobbiamo inventare. Questa si ottiene tramite la trasformazione, ci dobbiamo inventare una funzione calcolabile in tempo polinomiale deterministico che prende in input una formula F, che è una sarà una formula in 3CNF e tira fuori un grafo orientato. che ha un miltonio anziché solo se la formula di partenza insoddisfacile. Ok? Un po' una rogna, ok? Perché ci dobbiamo adesso inventare strutture di grafi che simulino il fatto se la formula o le sue clausole siano soddisfatte o meno. Ok? Che cos'è un'istanza? Sì, per F per TRSAT. Attenzione, un'istanza. Sì. Sì, è una formula che ammette un assegnamento per le sue variabili di verità che la soddisfa. Che cos'è un'istanza Sì per DHC? È un grafo orientato che ammette un Hamilton cycle. Ok. Bene, focalizziamoci sul problema del Tresat. Secondo voi, nel momento in cui ci passano una formula buleana e noi dobbiamo decidere se sia soddisfacbile o meno, l'intricasi di questo problema, cioè la parte tosta che ci richiede tempo nel momento in cui volessimo decidere se una formula buleana è soddisfaccibile o meno, quale sarebbe? trovare la combinazione che la soddisfa, trovare la combinazione che la soddisfa, cioè se ci danno una formula per stabilire se sia soddisfaccibile o meno, la parte tosta è data una variabile, ma a questa gli do vero o gli do falso? Ok? È chiaro questo? Perché adesso questa cosa la dobbiamo appare da un'altra parte. Supponiamo. Quindi, ora, invece che ci cambiamo contesto, qua ci stanno i grafi, ci danno un grafo, dobbiamo stabilire se questo grafo ha un Emiltony o meno. Ok? Secondo voi, mentre andiamo a tentare di costruire questo emiltonian cycle dentro C per sapere se ci sta o no, la parte difficile qual è? un punto di partenza. Quello non tanto perché se è un ciclo e quindi io attraverso tutti i nodi e torno a capo, io li avrò visti tutti, quindi io posso partire da qualsiasi punto. Quindi non è tanto il punto di partenza o di arrivo. Prego. Evitare di passare più alto su Evitare. Ok. Quindi ve la pongo io. Lei eh scegliere quale arco seguire. Scegliere quale arco seguire perché se un nodo ha un solo successore la scelta è obbligata. Intro presso siamo un incrocio. Che facciamo? Andiamo a destra o a sinistra? Quindi da un lato abbiamo dato una variabile, ma io gli do vero o gli do falso? Questo rende difficile il problema, rende il problema combinatorico. Dall'altro lato, dato un nodo che c'ha due uscite, ma io vado a destro a sinistra e questo rende il problema combinatorico. Quindi quello che noi dovremmo fare è mappare, fare una metafora tale per cui scegliere vero o falso sulle variabili buleane sarà scegliere strade particolari sul grafo. Se andremo su una strada sarà come scegliere vero su una variabile. Se sceglieremo un'altra strada sarà come scegliere falso su una variabile. Ok? È questo l'impianto che vogliamo dare. Quindi da un lato quello che rende difficile il problema è dato una variabile, ma questa è vera o falsa dall'altro lato. Ma se io sono di fronte a un incrocio, dove me ne vado? A destra o a sinistra? Quindi dobbiamo mappare queste due cose. Il grafo, oltre a dare la possibilità di codificare gli assegnamenti di verità, eh rispetto alla formula buleana da cui partiamo, dovrà avere una struttura che ha a che fare con le clausole della formula, perché il grafo deve ammettere un Emiltonycle se la formula di partenza è soddisfacile. Quindi da un lato questo grafo dovrà dare la possibilità di codificare assegnamenti. Dall'altro questo grafo deve codificare pure il clausolo di questa formula. Ok? Ok, abbiamo grandezza. Provate a pensare, prendiamoci qualche secondo per pensare questa cosa. Che struttura di grafo. Ok. Date, date una variabile buleana. Quanti sono gli assegnamenti per questa variabile buleana? Due. Date due variabili buleane, quanti sono i possibili assegnamenti? Quattro. Date n variabili buuleane. Quanti sono i possibili assegnamenti? 2^ n. Quindi il numero dei possibili assegnamenti cresce esponenzialmente col numero delle variabili. riusciamo a inventarci la struttura di un grafo, che poi arricchiremo. Eh, è giusto per avere un'idea di massimo, come deve essere fatto un grafo che possa mimare il fatto che noi abbiamo un numero esponenziale di assegnamenti, cioè un grafo con un numero esponenziale di percorsi. Come può essere fatto? devono essere un numero esponenziale di pere. Prendetevi qualche secondo per pensare, poi lo facciamo assieme. Ha già la risposta. Ok, possiamo prendere un nodoare, diciamo, basso. Sì, poi lo Sì, esattamente. Questa è un'idea di massima su come possa essere organizzato. Guardate qua che è quello che ci suggerisce il nostro collega. Noi a noi servirà un grafo che ammette un numero esponenziale di PA a un certo punto perché dovremmo mimare che abbiamo un numero esponenziale di assegnamenti per le variabili partenze. Uno di questi grafi ha questa formula. Allora, mi serve un verde decente. Quello è tremendamente brutto. Questo qua mah, meglio. Ecco qua. Sembra di tornare all'asilo. Ecco qua. Guardate qua. par questa struttura di grafo, che poi può essere replicata. Eh, quanti path ci stanno da S a T? Ce ne stanno quattro perché possiamo prendere una volta quando siamo su S, abbiamo due scelte o arco rosso o arco verde. Una volta che abbiamo scelto l'altro è fissato. Ecco perché li ho colorati neri. Quindi poi una volta che siamo nel nodo intermedio, andiamo o sul verde o sul rosso. Ok? Qui possiamo fare un'altra cosa. Possiamo averlo di nuovo. Avere questo qua, questo qua, questo così, questo così, questo qua, questo qua. Quindi a ogni livello noi stiamo moltiplicando per due la quantità di parti che ci stanno. Ok? Quindi noi sfrutteremo un grafo con quella forma in maniera molto più sofisticata. Questa era solo per darvi l'idea, per codificare assegnamenti di verità. Cioè la strada che prendiamo ci dice se stiamo dando vero verde o falso, rosso. Ok? Questa è l'idea che ci inventiamo ovviamente. Quindi, però questa cosa andrà che questa dege qui andrà fatto per all'interno della formula è molto più grossa. Ok? Allora, iniziamo così. sia fai una formula C1 and bla cm. Ok? Quindi fai è una formula con m clausole dove una clausola vi ricordo che è una cosa del tipo x8 or not x10 or x2 ad esempio. Ok? Questa è una clausola, eh. Quindi abbiamo m clausole su n variabili. Le variabili x soprasegnato sono x1 bla bla bla xn. Ok? Facciamo questa assunzione semplificatrice. Nelle clausole non appare mai un letterale e il suo negato. Tipo non è che c'è a or not a perché perché quella clausola è trivialmente vera, quindi possiamo non considerarla. Ok? Quindi le clausole sono fatte in maniera tale che i letterali al loro interno sono letterali di tre variabili distinte. Ok? Questa è una assunzione semplificatrice che facciamo sul tutto. Ok? Allora, facciamo questa cosa qua per ogni x con i appartenente a x soprasegnato. Quindi per ogni variabile buleana di fuiamo [Applauso] una catena di nodi. Costruiamo in G una catena di nodi e la facciamo così. Facciamo x1 x1 1 second x1 2' x1 2 secondo bla bla fino a dove? fino a X1 m' X1 m. Ok? Quindi abbiamo tante coppie di nodi. Adesso vi faccio vedere come le colleghiamo. Tante coppie di nodi. Quindi preso X con i. Ah, scusate, questo è x con i, eh? X con i, x con i, x i, x con i, x i x con i. Quindi per ognuna delle variabili buleane x con abbiamo m coppie. Queste qua vanno assieme, eh? Prima coppia, seconda coppia, terza coppia. Ok? Quindi abbiamo m coppie dove M è il numero di clausola. Va bene? Ok. Tolgo questo, giusto per non fare la figura troppo incasinata. Ok, quindi abbiamo m coppie, aggiungiamo dei nodini intermedi, questi pallini più piccoli, eh prima e dopo le coppie. Ok? Quindi le coppie sono inframezzate da questi nodi più piccolini. Dategli il nome che volete. Non so che come che nome inventarmi. L'importante è che noi visualizziamo che ci sono sti palletti piccoli. Ok? E poi abbiamo un nodo a rombo all'inizio inizio e un nodo a rombo alla fine fine. Ok? E questo avviene per ogni s per ogni x con i. Ok? Quindi so tanti nodi per ogni x con i. Adesso li dobbiamo collegare e li colleghiamo così. Verde, verde, verde, verde, verde, verde, verde, bla, bla, bla, verde, verde, verde, verde. Quindi c'è una catena in quella direzione di archi verdi. Al contempo mettiamo una catena in direzione opposta di archi rossi. Rosso, rosso, rosso, rosso, rosso, rosso, rosso, rosso, rosso, rosso e rosso. Ok? Quindi o per ogni x con i abbiamo questa catena di nodi di m coppie inframezzate dai pallini. Poi abbiamo i quadratini alla fine sono tutti i nodi e sono collegati con archi verdi andando verso destra e con archi rossi andando verso sinistra. Ok? Gli mettiamo il colore solo perché ci serve per ragionarci su. Ok? In realtà sono archi, non sono archi etichettati o colorati, sono archi che li coloriamo perché così ci viene più facile ragionare. Ok? Adesso noi dobbiamo replicare quella struttura che abbiamo visto prima, che è questa, per riuscire ad avere un numero esponenziale di percorsi. Ok? E facciamo così. Quindi, vi è chiara questa questa catena? Perché ora questa catena la riutilizzo in un altro modo. Ok? Allora, la struttura generale del grafo è questa qua. C'abbiamo un nodo S, poi abbiamo un arco verde in questa direzione, un arco rosso in questa direzione. Come particolarmente grande. Sì, sì, sì, sì. Fai bene, fai bene. Ok, quindi abbiamo S. L'arco che va di là è verde che mimerà vero? L'arco che va di là che è rosso che mimerà falso. Dopodiché qua in mezzo che c'abbiamo? C'abbiamo la catena di nodi relativi a x1, ok? Che è quella che abbiamo visto prima, eh? Quindi ora l'ho fatto così per dire là in mezzo c'è la catena che abbiamo visto prima, poi abbiamo questo qua e questo qua che partono dai dai nodi diamante. Eh, andiamo su un nodo intermedio. Sì, sì. i nodi estremi, quelli là, i quadratini, noi li prendiamo e li colleghiamo a questo nodo che sta in mezzo. Dopodiché facciamo la stessa cosa. Verde, quindi verde di qua, rosso di qua, dove vanno? Vanno verso i quadratini, eh, che li avevamo visti. Questi vanno verso un pallino e qua in mezzo, che c'ho? Ho la catena per X2. È chiaro? Questa cosa va avanti fino a dove? Fino a che abbiamo la catena per Xn. Questo qua e su questo qui. Poi abbiamo il quadratino qua, il quadratino qua. Da qui a qui a un nodo che chiamiamo T e qua in mezzo c'è la catena di Xn. Dopodiché colleghiamo. Eh, nemmeno io mo ce la faccio. Vediamo se va su. No. Oplà. E ritorno a capo. Ok. L'ultimo nodo è T e colleghiamo T a s. Ok? Quindi guardate questo grafo. Questo scarabocchio che ho fatto lì in mezzo è la catena che abbiamo visto prima, eh? Quindi il grafo, se noi partiamo da S, quanti percorsi ci stanno? 2^ n perché ogni volta che abbiamo la scelta, come vedete, verde e rosso, poi il resto è forzato perché la catena va se abbiamo scelto verde la catena la dovremo attraversare sugli archi verdi, senò ci blocchiamo. Se scegliamo rosso la catena la dobbiamo attraversare sugli archi rossi. Quindi la scelta si fa S1 2. Una volta che è scelto il resto è determinato fino a quando arriviamo nuovamente al palletto qua in mezzo. Lì abbiamo un'altra scelta. Quindi qua scegliamo, qua scegliamo, faremo tante altre scelte fino alla fine arrivati a torniamo dietro. Ok? Quindi questo grafo ha 2^ n cicli emiltoniani. Questo la presenza o meno di cicli emiltoniani in questo grafo dipende o meno dal fatto se la funzione f sia soddisfacibile o meno. No, ancora no. Abbiamo costruito un impianto di grafo solamente per avere la possibilità di mimare gli assegnamenti di verità. Ma questo grafo ancora non codifica niente di file se non il numero di variabili. Tutto qua. Ok? Però sulla struttura delle clausole di file dentro questo graf ancora non ci sta assolutamente niente. Allora, prima di dirvi come si fa, vi do l'intuizione. Sostanzialmente avremo C1, C2, bla bla bla C, avremo questi nodi aggiuntivi che sono i nodi per le clausole. Ok? E ne avremo tanti quanti sono le clausole. Questi nodi qui verranno agganciati a queste catene. Ehi, quindi questo lo agganciamo qua, qua o qua indipendenza della struttura delle clausole. Ok? Quindi gli archi che andremo a mettere tra qui e qui, tra qui e qui e qui e qui, dipende da come sono fatte le clausole, ok? È quello che renderà il grafo una replica della funzione fché al momento non lo è. Eh, questo grafo, così come è stato progettato al momento, questo grafo ha sempre un viltoni cycle, indipendentemente dal fatto se la formula F di partenza fosse soddisfacbile o meno. Ok? Alrght. Quindi finora è chiaro? La l'impianto del grafo è questo qua, è questo lunghissimo percorso su cui avremo dei nodi di lato clausole che verranno agganciati a agli scarabocchi, alle catene, in maniera tale da replicare il eh la struttura della formula f. Ok? Come agganciamo i nodi clausola al resto del grafico? Questo è l'ultimo pezzo che manca. Fatto questo, la costruzione è finita. Finora vi sto ancora spiegando che cosa? La funzione f trasformazione. Cioè preso in input fai il grafo che sputiamo fuori? Questo stiamo facendo al momento, stiamo descrivendo f. Ok? Allora, quindi sia x con i una variabile buleana. Poi se guardate sugli appunti di Calauti, io ve lo sto spiegando in modo leggermente diverso. La dimostrazione che vi faccio è leggermente diversa, ma è più o meno là. Però sui suoi appunti, per esempio, vedete il grafo bello pieno, quindi potete vedere alla fine che cosa si ottiene, perché io ve lo ve lo do a pezzi, ok? Allora, sia x con i una variabile buleana ci ci sono, consideriamo, supponiamo, ok, se x con i, quindi la variabile buleana x con i appartiene alla clausola CJ, cioè quindi la variabile X con i appare come letterale positivo dentro la variabile CJ aggiungiamo questi archi qua. Quindi se X con i appartiene a CJ, allora facciamo questo x con i jo. Vi ricordo che abbiamo questi elementi, no? nella catena X con i J second com'erano collegati. Sopra avevamo il verde, sotto avevamo il rosso. Facciamo così. C con J sta qua e lo colleghiamo così. Ok? Quindi, se x con y è una variabile buleana che appare come un letterale positivo dentro la variabile, dentro la clausola CJ, prendiamo la coppia Jim X con i J' X con J X con i J e mettiamo un arco da X con i J' a CJ che è coloro verde solo per farvi capire il senso ci entriamo tramite un letterale positivo e il ritorno, come vedete, è rosso. Ok? Quindi abbiamo un detour. Il il colui che sta percorrendo il ciclo in quel momento potrebbe decidere, ma invece di andare direttamente da x con j i j' a x i j secondo direttamente, mi faccio un giro per il nodo clausola. Ok? Cioè, faccio questo giro. Se x con i, se not con i appartiene a CJ, allora abbiamo un'altra cosa. Quindi, se x con i appartiene come un letterale negativo alla variabile alla clausola CJ, avremo questa cosa qua. X con i jo, X con i j secondo, ok? CJ. E che cosa avremo? Avriamo verde, verde, rosso e rosso. Ok, vedete? Cambia il verso in cui possiamo percorrere CJ. È l'unica cosa. Chiaro? Quindi noi avremo, per ritornare qua, giusto uno schizzo che questi nodi clausola sono agganciati a pezzi qua, a pezzi qui. Questo sta qua, questo sta qui, qui e così via. Ok, questo per avere un'idea di massima. Il modo in cui è agganciato è questo qua che vi ho scritto qui. Ok? Questo è il modo in cui i nodi clausola sono agganciati alle catene. Ok? Questo conclude la costruzione, cioè quindi il grafo è fatto così, c'ha tante catene fatte in quel modo, quante sono le variabili buleane. Ha tanti nodi, poi è tutto messo con questa cosa, scaletta eccetera. Ha tanti nodi clausola. Quanti sono le clausole di fai? Le i nodi clausole sono agganciati alle catene con quelle regole. Come? Un attimo. Un attimo. Su, su. Ok, prego. Ma noi questa abbiamo messo che in ogni clausola abbiamo tre sì e per ogni catena abbiamo tre no di clausola oppure di presente questo? Per le catene abbiamo tante cocchie quante sono le clausole. Se le clausole sono 25 abbiamo 25 cocche. Xi1 prim X1 second. Tante clausole? No, le clausole sì, le clausole sono cinque, quindi abbiamo tanti no di clausola quante sono le clausole della formula. L'unica limite che abbiamo dato è quanti letterari appaiono nelle clausole che sono più tre, anche se non è essenziale questa cosa. Il vincolo cheediamo è che in una stessa clausola non può fare un letterale e un somato, cioè non c'è dentro una clausola a or not a perché quella è una clausola vera e non c'è bisogno proprio di considerarla. Ok? Dobbiamo ora dimostrare che quanto tempo abbiamo? Ma sì, ce la dovremmo fare. Dovremmo ora dobbiamo ora dimostrare che che cosa dobbiamo dimostrare che questo grafo ha una ha un emiltan cycle se è solo se, cioè la formula file è soddisfibile se è solo se il grafo, così come è strutturato ha unemiltonian cycle. Ok? Alright. Supponiamo, primo verso della dimostrazione, dimostriamo che se la formula fai è soddisfacbile, allora un grafo con questa forma ammette unemintonian cycle. Eh, vi ripeto, formula soddisfacile. Il grafo fatto così ha unemtonian cycle, non un grafo a caso, un grafo con questa forma, ok? È il risultato di f. Quindi quello che noi dimostriamo è che se f r ricevi in input una formula fai soddisfaccibile, sputa fuori un grafo con questa forma che ammette un elemento in. Ok? Supponiamo che la formula fai sia soddisfacbile, ok? Dobbiamo e sia sigma un assegnamento che soddisfi dobbiamo dimostrare che G di f, chiamiamolo G dif, il grafo ottenuto da F in questo modo, ammette un Hemiltonian Cycle. Come lo facciamo a mostrare? Lo facciamo esibendone uno. Vi faccio vedere che se la formula f è soddisfaci, allora un grafo con questa faccia c'ha un Hemiltonian cycle. Il Hamiltonian cycle è fatto così, parte da S. Se x 1 in sigma è vero, noi percorriamo il rango verde. Se x 1 in sigma è falso, noi percorriamo il ramo rosso. Ok? Quindi, partendo da sigma, che è una che è un assegnamento di verità che soddisfa la formula, noi seguiamo le istruzioni di sigma. Se sigma assegna vero a x con 1, al scaletta ce ne andiamo a destra. Se sigma segna falsa ad x con 1 alla prima parte della scaletta, cioè questa qua, ce ne andiamo a sinistra. Ok? Una volta che scendiamo, supponiamo di essere scesi da qui, percorriamo la catena, lo percorriamo seguendo gli archi verdi perché stiamo scendendo dal verde. Ok? Seguiamo gli archi verdi. Se abbiamo la possibilità di fare un detour in questo modo che invece di fare un salto così facciamo una cosa così, lo facciamo. Ok? Tutte le volte che possiamo fare un detur sensato verso un nodo clausola lo facciamo tendiamo più possibile Sì. Prendiamo più C possibili quando possiamo. Ok. Sì. Sì. Ok. Una volta, per esempio, andiamo di qua, andiamo di qua, poi andiamo di qui, torniamo indietro, poi potremmo andare da un'altra parte, torniamo indietro e così via. Fino a quando arriviamo al diamantino. Dopodiché scendiamo, andiamo all'altro punto di decisione, lì guardiamo nuovamente Sigma. Se sigma ci dice falso, andiamo di qua. Se sigma ci dice vero, andiamo di qua. Ok? A un certo punto arriveremo fin qua, torniamo indietro e andiamo a S. Allora, noi sappiamo che le catene possono essere attraversate in questo modo perché sono strutturate. Dobbiamo avere in questo modo. Dobbiamo avere la certezza di poter attraversare tutti i nodi clausola. Come facciamo a essere sicuri che noi possiamo attraversare tutti noi di clausola? Io parto da un assegnamento che mi soddisfa e fai. Di conseguenza io, visto che ogni volta che faccio il detour e lo faccio quando per tutte le variabili che io a segno vero s di conseguenza tutte le mie clausole saranno Esattamente. Esattamente. Cioè il no di clausola siamo in grado di osservarli tutti. in questo giro perché sigma soddisfa fai e vuol dire che esiste almeno un letterale vero causa sigma in ogni clausola. Quindi avremo a un certo punto, magari non sappiamo dove, ma avremo a un certo punto dentro questo percorso la possibilità di vedere C1, C2, C3, bla bla C. Quindi, se la formula fai è soddisfacbile, allora il grafo ammette un cycle. È chiaro? La parte difficile della dimostrazione è se il grafo ammette un Hemiltonian cycle. È vero che la formula è soddisfacbile? Ecco qua. Su questo dobbiamo essere un po' più precisi. 1 B e 2. Sì. Ok? Supponiamo che la formul la la funzione f devo tenere sott'osto l'orologio. A sto punto supponiamo che la funzione f in caso io prendo 520 extra. Eh, allora, supponiamo che la la funzione f abbia tirato fuori, partendo da fai, questo tipo di grafo. E assumiamo che il grafo che ha sputato fuori f è un grafo con questa faccia che abbia nel vettorial. Ok? Allora, noi dobbiamo dimostrare che se siamo arrivati a un grafo così che ha un Hemiltonian Cycle era perché stavamo partendo da una formula F che era soddisfacile. Ok? Quindi l'idea sarà sostanzialmente far vedere che da uniltonian cycle all'interno di un grafo fatto così siamo in grado di tirare fuori una un assegnamento di verità che soddisfi la formula. Ok? È chiaro l'intuizione? L'intuizione è questo grafo ammette un Hemiltonian cycle. Ah sì? Ok. Ti mostro che dallle miltonian cycle di questo grafo io sono in grado di generare un assegnamento sigma per foddisfi è chiaro? Questo è l'intuizione del passaggio che vogliamo fare. Prendiamo unan cycle a caso di questo grafo. Ok? Benissimo, noi dobbiamo trasformare questo emitori ancle adesso dentro un assegnamento verso un assegnamento per fil. Il problema è questo. Se prendiamo un emitori ancle a caso di G può essere un emitorian unemitoni ancyle a caso. Ok? Quindi potrebbero accadere cose strane in questo Hamiltonio anco, tra cui parto da qui, me ne va me ne vado, che ne so, parto da qui, me ne vado qui, arrivo qua, vado su questo nodo clausola e poi scendo qui. Ok? Cioè, siccome noi stiamo prendendo Hamiltony con a caso, eh uno qualsiasi, ok? Prendine uno. Allora, quel giro, ma potrebbe essere il giro delle fiandre, potrebbe essere qualcosa che non c'entra assolutamente niente. Che ne so, va qua, va qua, poi se ne scende sotto, poi va qua, torna qui, va su. Cioè possono succedere cose strane. Allora, il primo nostro obiettivo è mostrare che unemiltonian cycle in questo grafo ha delle proprietà tra cui se raggiunge un certo nodo clausola non salta il piano, cioè ritorna a posto. Prima proprietà e seconda proprietà che quindi quello sarà importante per escludere Meltoni Ancyle che facciano salti. vado qua e poi me ne vado sotto che quello è un problema. Ok? La seconda proprietà degli Hamiltonian Cycle che mostreremo è che una volta che me ne vado in un nodo clausola e quindi sono costretto a ritornare sulla stessa catena perché escluderemo la possibilità di fare salti, mostreremo che i detour che si fanno verso le clausole sono in linea con i colori dei degli archi. Cioè, se stavo percorrendo la catena sul verde, nel nodo clausola ci andrò da qui, dall'arco verde. Se stavo percorrendo la catena sul rosso, al nodo clausolo ci andrò da questa parte. Ok? Quindi la il nostro primo obiettivo è sì prendiamo un Hemiltonian Cycle a caso di questo grafo, però questo Hemtonian cycle ha due proprietà che gli danno una struttura molto specifica dalle quali poi tirare fuori l'assegnamento sigma sarà facile. Ok? Alright. Ok. Prima proprietà che dobbiamo dimostrare sia un Hamiltonian Cycle Hamiltonian Cycle DG P a due proprietà. La prima 1 che è fatta di due sottocasi A e B. Quindi proprietà 1A proprietà 1 B. proprietà 1 a se in pi al nodo cj si arriva da x con i j allora dopo cj 6 si va in x i j second scritto. Sì, se in pi a si arriva da x i prim, in realtà forse la seconda proprietà nemmeno vaha dimostrata. Ok, era ieri notte quando l'ho fatto. Ok, allora se in ACJ si ci arriva dal nodo X i J', allora dopo CJ in pix. Cioè, una cosa strana non può succedere. Non è che ce ne abbia andiamo da x con 1 ce ne andiamo a x 4. Si deve andare al successivo b similare. Se in pi a cj si arriva da X i J second. Allora, dopo CJ in pi si va in x con i j'. Ok? Mi sa che la seconda proprietà nemmeno serve. Quindi queste sono le due cose che dobbiamo dimostrare. Vediamole con uno schema. X con i J'. Vediamo la parte a X con i j secondo. Qua c'ho CJ. Quindi che cosa avrò? Qua c'è il verde, qua c'è il verde, qua c'è il rosso, qua c'è il rosso. E poi che cosa abbiamo? Ci sono i due palletti piccoli, eh, qua verde e qui verde, qui rosso e qui rosso. Ok, guardate questa casistica. Allora, il primo caso ci dice che nel percorso PI siamo prima andati qui, poi siamo andati in questa direzione verso CJ. La prima proprietà ci dice che noi dobbiamo tornare verso X second. Supponiamo che questo non sia il caso e che invece ce ne andiamo di qua. Ok? Allora, affinché P sia un Hemiltonian cycle, dovrà prima o poi passare, guardate la figura, da X i J second. Ok? Chi sono i nodi adiacenti di X I J second? sono X I Jo, che stiamo suppendo di averlo già visto, CJ che stiamo suppendo di averlo visto e poi il pallino piccolino. Quindi se c'è una deviazione strana CJ vuol dire che nel percorso miltoniano per vedere X i J second si arriva dal pallino. Ok? Quindi andremmo sul pallino prima di andare qua e poi come ne usciamo non se ne esce. Quindi se cj in piel percorso pi è preceduto da x i j'o per forza andare in x i j second. Ok? Questa cosa simmetricamente vale per l'altra proprietà come Sì, il problema sarebbe simile. Non ve lo dico perché non abbiamo tempo, dobbiamo vedere un'altra cosa, però è simmetrico. Cioè noi che cosa avremmo? il pallino, poi avremmo X primo, X i Jo, un altro pallino. Quindi avremmo una cosa così, questo così, questo così e questo così. Poi avremmo questo, questo qua. Allora, se volete vederla da da voi la proprietà è simmetrica. Il problema sta su questo pallino, nel senso che lui non lo osserviamo e quindi poi per tornarci ci blocchiamo. È la stessa cosa. Dimmi il cit Sì. collegato ai alle trezion tre coppie. Sì, sì, sì. Ma quindi noi non possiamo succere una No, una volta che ci passa una volta quello è fatto. Non c'è bisogno di passare il passo per la prima posizione alla seconda. Sì, sì, sì, sì, sì, sì, sì. Ok. Allora, questa proprietà che cosa ci dice? ci dice quindi che non possono succedere cose strane. Quindi la seconda proprietà che vi dicevo prima in realtà è già sussunta da questa. Questa proprietà ci dice che uno se facciamo un detour verso un nodo clausola non cambiamo piano, cioè non è che ce ne andiamo a finire un'altra parte di quella scala, dobbiamo ritornare alla stessa. secondo. Se CJ viene visto dopo XJ', allora stiamo percorrendo sugli archi verdi. Se X se CJ viene visto dopo X second, allora lo stiamo percorrendo sui nodi rossi, sugli archi rossi. Ok? Quindi abbiamo questa struttura molto particolare. Ciò significa che un Hemiltonian cycle sensato qua dentro andrà prima da un lato, poi andrà qua, vede una clausola, torna indietro, va avanti, scende giù, fa una scelta, va al contrario, vede un'altra clausola, torna indietro, va avanti e così via. Quindi da questo Hemtonian cycle noi possiamo ricavare il sigma. Come facciamo? Andiamo ai nodi di scelta. Questo è il nodo di scelta per x1. Questo è il nodo di scelta per x2. E così via. Se andiamo sull'arco verde in sigma a x1 diamo vero. Se andiamo sull'arco rosso a sigma e a x1 in sigma diamo falso. Questo ci permette di assegnare tutti i valori di verità a tutte le variabili. Siamo sicuri che soddisfa la formula fai? Sì, perché? Perché se quello è un Hamiltonian cycle e questi nodi clausola li vediamo tutti e abbiamo detto che la visita dei nodi clausola è coerente sul colore degli archi, allora se lo vediamo arrivando da rosso è perché abbiamo assegnato falso a un letterale a un letterale negato. Se ci arriviamo da vero è perché abbiamo assegnato vero a un letterale positivo. Quindi noi avremo che tutte le clausole sono verificate da quell'assegnamento di verità. Ok, è chiaro? Mancano ancora un po' di pezziamo di fare. Quindi in questo modo cosa abbiamo mostrato? Abbiamo mostrato che tre Sat si riduce a directed Hamiltonian Cycle. Ok, ci manca l'altro altro pezzo. Alri, lo facciamo in un'altra pagina. Ok. Dobbiamo adesso ridurre directed Hemiltonian cycle a Hemiltonian Cycle, che è la stesso problema in cui il grafo, quindi partiamo da G, un grafo G, andiamo a un grafo H. L'unica differenza è che H è non orientato in questo caso, ok? La costruzione avviene così. Supponiamo di avere due nodi, cioè ci saranno in Gi. Dobbiamo ottenere i nodi in H. Per ognuno dei nodi in G mettiamo tre nodi in H. Lo chiamiamo A in A middle. Eh sì. A middle. A out. B. B middle B out. Ok? Quindi ogni nodo in G diventa tre nodi in H. Quindi avremo il triplo dei nodi. Come sono collegati? Prendiamo ognuna di queste triple, attacchiamo in a mid e mid a out. Quindi facciamo così. Quindi queste triple sono collegate in questo modo in H. Dopodiché guardate qua c'è un arco da A verso B. Questa cosa viene ripata con un arco da A out a B inentato. Non orientato. Ok? È chiaro? Quindi ogni nodo di Gventa una tripletta su H. I nodi in H sono collegati in questo modo, in verso mid e mid verso out. Poi, se c'è un arco in Go A a un nodo B, colleghiamo A out uscita verso B in entrata. Ok? Questo ovviamente va fatto per tutti i nodi che stanno qua. Ok? Questo era giusto per farvi capire come viene trasformato. È chiara la trasformazione? Ok. Prego. Middle. Middle rimane così. È contento così a tenere le mani a quei due. Ok. Alri. Dobbiamo dimostrare che abbiamo un Hemiltonian cycle orientato in G. Se solo se c'è un Hemiltonian cycle non orientato in H. Supponiamo che ci sia un Hemiltonian cycle orientato in G, chiamiamolo Pi, che ha una sequenza di nodi tipo V1, V2, V3 e così via. Secondo voi, quale può essere un Hemiltonian Cycle in H che è speculare di V1, V2, V3 e così via? Faccio una scelta, cioè se cycle compar un altro da A B da out faccio in poi seguo mid out e poi vedo che andava via. Sì. Quindi da questa sequenza pi posso costruire una sequenza, chiamiamolo gamma su h che è fatta così. V1 in, V1 mid, V1 out e poi V2 in, V2 mid, V2 out e poi V3 in, V3 mid, V3 out. Come faccio a sapere che io posso andare da V in, da V1 in a V1 mid e da V1 mid a V1 out? Perché sono stati costruiti così? Chi mi dà la certezza che posso andare da V1 out a V2 in? Perché poiché questo è un Hemiltonian cycle in G, ci deve essere un arco da B1 a B2. Quindi nel grafo H ci sarà un arco da V1 out a V2 in. Ok? È chiaro? Quindi io posso prendere un Hemiltonian cycle diretto di orientato in G e trasformarlo in un e mostrare che esiste un graf orientato, l'emiltonian cycle non orientato in H. Vi chiaro? Come faccio a Adesso noi dobbiamo dimostrare che Ok, 5 minuti extra me li prendo, senò dobbiamo arronzare. Dobbiamo adesso dimostrare che se c'è un Hemiltonian cycle in H, allora ci deve essere per forza un Emiltonian Cycle anche in G. Questo un pelino più trile. Guardate i nodi di H che forma hanno. I nodi di Hono che i nodi con l'apice mid sta in mezzo ai nodi con apice in e out. Di conseguenza, preso un qualsiasi ancycle DH, gli apici dei suoi nodi dovranno essere per forza in, mid, out in mid out, in mid out. O se lo percorriamo al contrario, out mid in. Out mid in e così via. Perché il grafo h è non orientato. Ci scegliamo la variante in mid out. In mid out. A quel punto cosa avremmo? Avremo V1 in, V1 mid, V1 out, V2 in, V2 mid, V2 out, V3 in, V3 mid, V3 out e così via. Io da questo posso ricavarmi un Hemiltonian con l'in V2, V3. Io ho la certezza che c'è un arco fra V1 e V2 perché c'è un arco fra V1 out e V2 in o c'è un arco fra V2 e V3 perché c'è un arco fra V23, V2 out e V3. Ok, chiaro? Quindi questo ci dimostra che se H ottenuto ha unemiltonian cycle era perché G di partenza aveva un Hemtonian cycle. Ok, gli ultimi 5 minuti e chiudiamo. Riduzione da HC a TSP. Ok. Cos'è un'istanza per Emiltony? Un grafo non orientato. Cos'è un'istanza per che è uguale a V? Ok. Cos'è un'istanza per TSP? È una coppia G è una H che è W. è una funzione di labeling. Ok? Quindi noi dobbiamo trasformare il problema di decidere se un grafo G ha unan cycle nel problema di se un grafo H pesato ha un emiltonian cycle di peso al + k. La trasformazione è estremamente semplice. H uguale a G, quindi tutti i nodi sono gli stessi, tutti gli archi sono gli stessi. La differenza è che gli archi in h vanno pesati. Mettiamo peso uno a tutti gli archi e K è il numero degli tra. Ripeto, partiamo da G. Dobbiamo ottenere K. H. H è ugale per ogni nodo in G ci sarà un nodo in H. Per ogni arco in G ci sarà un arco in H. Però H è un grafo pesato rispetto a G, che G non lo è. Che pesi ci inv? Mettiamo peso 1 su tutti gli H. Dobbiamo generare K nella trasformazione. Che mettiamo a K? mettiamo il numero di nodi che appare nel grafo. Quindi intuizione velocissima, avevo detto 5 minuti, quindi ne abbiamo altri due. Se il grafo G ha untonian cycle, allora anche il grafo H avrà un Emiltonian Cycle, perché la struttura dei grafi è la stessa. Come facciamo a sapere che il grafo Hemiltonian cycle di peso al + k? Per forza, perché tutti gli archi gli pesano 1 e K è pari al numero dei nodi. E noi sappiamo che l'emiltonian cycle attraversa un numero di archi pari al numero dei nodi, quindi avrà un Hemiltonian cycle di peso K. Come facci? Supponiamo che il grafo H abbia un Hemiltonian cycle di peso K. È vero o no che G ha un Hemiltonian cycle? Per forza, perché G ha la stessa struttura di H. Inoltre G non è nemmeno pesato, quindi il peso nemmeno ci importa. Ok? Quindi se G ha un Hemiltonian cycle, Hemiltonian cycle di peso a + K. Se H ha ha un emonian cycle di peso al + k, allora G ha un emiltonian cycle. Ok? E con questo chiudiamo gli argomenti del corso. Grazie mille per essere venuti. Ci vediamo domani con il Mok.