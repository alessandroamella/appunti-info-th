Ok, iniziamo. Ok, ok, ok. Ultime due lezioni espressamente su NP. Poi ovviamente avremo altre cose, però ultime due lezioni che faremo sulla espressamente sulla classe NP, poi iniziamo a vedere classi strane diverse. Oggi per la vostra gioia riduzioni, vediamo altri problemi NP completi e prossima volta teorema di Cook. Tutto tutto quello che abbiamo fatto finora partiva dall'assunzione che SAT era NP completo. Ancora non l'abbiamo dimostrato, l'abbiamo assunto, lo dimostreremo la prossima volta. Ok? è un teorema molto lungo, cioè la dimostrazione è molto lunga, non è particolarmente intricata, però è lunga e richiederà una lezione intera riuscire a a vederla assieme. Dopodiché inizieremo a vedere classi oltre NP, cose che non sono in NP, cose che stanno dentro P. Poi vedremo nelle lezioni successive introdurremo complessità spaziale perché ancora non l'abbiamo vista. Ci siamo semplicemente occupate di quanto tempo ci mette la macchina, però non ci siamo mai chiesti quanta memoria usa la macchina, ok? Quella è una cosa che vedremo poi nelle nelle prossime lezioni, ok? complessità spaziale. Poi dovremmo farcela a vedere in tempo oracoli, classi di funzioni, ma velocemente, che finora ci siamo sempre occupati di decidere se bla. Ok, ma se invece noi vogliamo proprio calcolarli il risultato, qual è la classe di complessità? Quindi una lezione sarà dedicata a quello, ma molto veloce. E poi credo che ultima lezione, ultima lezione facciamo un mok exam, vediamo una traccia assieme e la la svolgiamo assieme, ok? Così vediamo un po' come come si fa. Come tutto nelle prossime? Perché per programma dobbiamo fare 56 ore, quindi 28 lezioni. Otto lezioni compresa questa. Quindi se guardate l'orario, le prossime otto lezioni sono tutte quelle che abbiamo, non ne posso saltare nessuna, quindi ci sarà la lezione prima del primo maggio. Sì, cioè ci dobbiamo vedere anche settimana prossima perché purtroppo non mi hanno dato margine, sono stato male e quelle due lezioni sono andate. Sennò queste qua ve le abbonavo, eh. ce ne andavamo tutti quanti allegramente in vacanza, purtroppo non abbiamo potuto. Ok? Ehm, alright. Quindi questo è il programma. Quindi no, quante lezioni sono? Sono otto lezioni. Le faremo tutte. Tutte quelle che vedete in orario. Purtroppo ce le dobbiamo fare tutte fino alla fine perché non ne possiamo saltare. Alrght. Ok. Quindi vedremo oggi due problemi. Un problema, due problemi NP completi. Un problema prima della pausa, un problema dopo la pausa. Vedremo le loro riduzioni. Uno di loro credo che il problema che vediamo dopo la pausa lo conosciate già. L'avete visto in altre salse. Oggi vedremo che è un problema NP completo. Ok. Il problema del Napac, probabilmente l'avete visto in ottimizzazione o ricerca operativa, la la programmazione lineare intera è un problema NP completo. Oggi vedremo vedremo come si fa. Si fa una riduzione si fa una riduzione da un problema NP completo e mostreremo che Napsak e quindi tutta la programmazione lineare intera, perché Napsak è un caso di programmazione lineare intera, è NP completa. Ok? Alright. Allora, il primo problema che vediamo è exact. Il nostro intento è, come al solito, mostrare che sia NP completo. Vi ricordate la definizione? Quand'è che un problema è NP completo? Quando appartiene NP ed è NP. Quando appartiene NP ed è NP hard. Quindi quando è appartiene ad NP NP hard significa che almeno tosto quanto tutti i problemi di NP. Non so se non mi ricordo se questa domanda ve l'avevo già fatta. È vero o no che il linguaggio universale è NP argo? Sì, il programma il linguaggio universale è NP arduo perché esiste una riduzione da tutti i linguaggi di NP verso Lu. Ok? Quindi NP arduo non è problema tosto di NP. No, NP ardo significa al meno tosto quanto tutti i problemi di NP. Per stare dentro NP è una condizione aggiuntiva cheediamo. Quindi se un problema è NP ardo e sta dentro NP, allora è un problema tosto di NP e chiamiamo NP completo. Ok? Vi ricordo nuovamente che tutti questi problemi, la classe P, la classe NP, i problemi NP ardui, i problemi NP completi, cioè tutto quello che abbiamo visto fino ora, Lu, alt, alt per ogni alt, tutte queste cose qua sono problemi di decisione. Quindi è vero, no, che la somma sommare due numeri sta in P? No, non è vero, perché sebbene possiamo farlo in tempo polinomiale, non è non è un problema di decisione. Il problema di dato una tripla di numeri, è vero che il terzo numero eguaglia la somma dei primi due, quello sta in Pch? Perché è un problema di decisione che può stare che si può risolvere in tempo polinomiale. Ok? Allora, definiamo questo problema exacto cover da cui poi faremo la riduzione verso Napsa. Quindi Napsac sarà mostrato NP hardware tramite una riduzione da exact. Ok? Allora, che cos'è exact? L'input per exact è un insieme U di oggetti che chiamiamo universo. È l'oggetto U1 Un. E poi c'è una famiglia F di sottoinsiemi S1 SM dove gli S con I sono sottiniemi di U. Ok? Quindi l'input di questo problema sono due insiemi. Un insieme U di oggetti che chiamiamo universo, una famiglia f di sottoinsiemi di U. Ok? Scusa, due su due entrambi M. Se m o N No, quello è eh Sì, po un casino. Allora, questo è N è N di Napoli e questo è M di Messina. Ok? E noi abbiamo che tutti gli S con I sono sottoinsiemi di di U. Ok? Questo è l'input, l'output. Se essendo un problema diisione è un problema si no. Quand'è che rispondiamo sì? Rispondiamo sì. Quindi unistanza sì fatta di exact UF è un'istanza sì di exat cover se esiste tra gli insiemi di f una partizione di U. Ripeto, un'istanza Sì di exact cover è una coppia UF tale per cui tra i sottoinsiemi di U che compaiono in F, alcuni di loro possono essere selezionati per costituire una partizione di U. Per partizione intendiamo che questa selezione dei degli insiemi S con i sono insiemi disgiunti, quindi non hanno niente in comune e la loro unione somma a u. Ok? Quindi un'istanza sì è un'istanza in cui si può selezionare da f un insieme. di S con I tali che siano una partizione di U. Ok? Chiaro per tutti il concetto di partizione? Cioè noi prendiamo questi s con i, questi s con i non devono avere un'intersezione non vuota. E se noi li uniamo dobbiamo ricostruire. Ok? Allora, noi vogliamo mostrare che questo problema è un problema NP completo, ok? Quindi è uno dei problemi tosti, non conosciamo nessun algoritmo polinomiale che lo risolve, eccetera. Quindi dobbiamo mostrare membership membership e hardness. Ok. Per la membership come facciamo a dimostrare che questo problema è infisi nella definizione dizione gli elementi di S devono essere Sì, cioè io da F devo prendere S4, S5 S9, S12, tale per cui se faccio l'intersezione a coppie non c'è niente in comune e se li sommo tutti, se faccio l'unione di tutti questi qua, io ottengo U. Ok? Questo è il concetto di partizione. Ok? Quindi sembra un problema abbastanza semplice, ma in realtà è un problema NP completo, è un problema inerentemente combinatorico, cioè significa non abbiamo strategie migliore che provare di provare fare tutti i tentativi. Questo è quando un problema n è più completo significa che noi ci possiamo inventare le uristiche che vogliamo, ma non avremo mai un taglio sostanziale del tempo peggiore di esecuzione. cioè male che va noi ranniamo in tempo esponenziale perché non possiamo far altro che provare tutte le combinazioni. Quello è problemi NP completi. Sono problemi inerentemente combinatorici, ok? Problemi per i quali non abbiamo soluzioni polinomiali e non ci aspettiamo che ne esistano, sebbene nessuno abbia mai mostrato che non sia possibile farlo. Eh, ok. Come facciamo a dimostrare che exact cover è in NP? Sì, indoviniamo quali insieme possono formare Sì, indoviniamo la soluzione. Cioè questo un problema sta in NP quando sostanzialmente possiamo individuare possiamo indovinare la soluzione. Questo nella stragrande maggioranza dei casi. Eh ah mi pare che lo facciamo la prossima, no, fra due lezioni, ok? primes. Il problema della primalità, per esempio, è un problema che sta in NP. In realtà, come vi ho detto, poi fu dimostrato che prime si sta actual in polinomial time, cioè un algoritmo tostissimo per riuscire a rispondere il problema al problema. Però quel problema sta in NP, però come si fa a dimostrare che un un numero è primo? Eh, il guess da fare è molto più sofisticato. Lì entra in gioco il concetto di certificato polinomialmente eh di certificato conciso, cioè abbiamo un certificato che in realtà è più grande dell'input. Uno può gessare una serie di cose. È il teorema di Prat degli anni 70 mi pare, 75 se non mi ricordo male, in cui si mostra che Primes è in P e lui si era inventato sto certificato strambissimo per le istanze CD primes. Era una cosa bella lunga, però aveva mostrato che era comunque bounded da un polinomio e ce l'avevano solo i primi. Ok? Quindi negli esempi che vediamo noi, noi in genere gessiamo le soluzioni, ma non tutti i problemi di NP sono così semplici, tra virgolette, che si gessa la soluzione, appunto. Alle volte uno si deve ghessare qualcosa di più grosso. In questo caso noi gessiamo una soluzione, verifichiamo che la soluzione che stiamo ghessando è in effetti una partizione di U e rispondiamo sì. Ok? Quindi membership è facile. Quello che dobbiamo vedere ora è l'hardness. L'hardness è un po' più sofisticata. Ok, abbiamo spazio. Abbiamo spazio. Riduzione. Riduzione da 3 SAT. Come vedete SAT lo stiamo usando moltissimo. [Musica] Ok. Che cos'è un'istanza di SAT? Una formula. Esattamente. Ok. Cos'è un'istanza di exact? Una coppia. U. Una coppia UF. Esattamente. Ok. Quindi noi ci dobbiamo inventare una trasformazione F che input questa F prende una formula fula in 3 CNF, la prendiamo semplice e sputa fuori un insieme U di oggetti e una famiglia f di sottinsiemi di U. E questa cosa deve avvenire in maniera tale che la formula fai sia soddisfacbile se è solo se nella f nel nella coppia UF ottenuta dalla trasformazione in f appaia una partizione di U se è solo se fai e soddisfacile. Ok? Quindi sta funzione si deve inventare questa cosa qua. Ok? La funzione non può testare se fai sia soddisfa perché altrimenti non ci impiegherebbe tempo polinomiale perché la funzione f deve essere eseguita in tempo polinomiale, ok? Perché a questo punto sarebbe facile, no? La funzione guarda f decide se sia soddisfacile. Se è soddisfacbile sputa fuori un'istanza sì di Exat Cover. Se fai non è soddisfacebile, sputa fuori un'istanza no di exat cover, ma questo non si può fare in tempo polinomiale. Quindi f deve essere una funzione che trasformi f guardandone solamente alla struttura e preservandone la proprietà di istanza sì, istanza sì, istanza no, istanza no. Ok? Domande? M no. Ok. Allora, noi abbiamo che la formula fai ha questa forma, è una congiunzione di un certo numero di clausole C con1, C2, CON L, eccetera. Ok? E la clausola C con i è fatta dai letterari lambda i di 1 or lambda i di 2 or lambda i 3. Ok? hanno tutti questa forma qua. Allora, noi prendiamo e trasformiamo le cose in questo modo. Ok? Allora, l'universo U della trasformazione, chiamiamolo in questo modo, così è più evidente, dov'è la gomma? È più evidente che proviene dalla Quindi abbiamo Uf e F per dire che eh sono strutture, sono insieme che provengono da fai, ok? Cioè, non sono cose a caso, sono cose sputate fuori da f guardando fai. Allora, U di f è fatto in questo modo. Abbiamo un oggetto x con i con i che va da 1 a n, cioè abbiamo un oggetto x con i per ognuna delle variabili buleani buleanee che appare dentro fai. Quindi dentro fai che ci sta x 1, x con 2, x con 3, x con 4. Ok? Dentro U ci sta X 1, X 2, X3 e X4. Poi la questione è che noi con questo problema di partizionamento dobbiamo andare a replicare se la formula sia soddisfacibile o meno. Quindi ci dobbiamo inventare oggetti e sottoinsiemi di U in f tale per cui poi i conti ci tornano in cui possiamo simulare l'assegnamento di verità. variabili, eccetera. Poi che cosa ci servirà? ci servirà a stabilire, siccome noi vogliamo simulare se la formula sia soddisfacbile o meno tramite un partizionamento, ci serviranno oggetti dentro u che ci simulano se una certa clausola è stata soddisfatta o meno e quindi avremo un oggetto C i per ogni I o C jamiolo qua è J, ok? per ogni J che va tra 1 e L. Ok? Quindi avremo un oggetto per ogni variabile bureana che compare nella formula un oggetto C con I. Per ogni clausola che compare nella formula unito avremo oggetti che simulano le PJ K che simulano le letterale per ogni i lambda i per ogni lambda g. Oplà. J K. Ok. Quindi l'universo in questa riduzione, l'universo UDF ha oggetti di tre tipi. Un oggetto per ogni variabile, un oggetto per ogni clausola, un oggetto per ogni letterale che compare nella formula. Ok? G diamo questi nomi x con i con j lambda di JK. Ok? E questo è solamente udify. Dobbiamo ancora definire f dif. Allora, f dif è ottenuta in questo modo. Che cosa ci sta? Allora, lo descriviamo un po' più a parole. F di F contiene, senò usiamo troppi simboli, contiene un insieme PJK, quindi un insieme singleton che contiene PJK per ogni oggetto [Applauso] PJK. Ok? Quindi in F abbiamo questi singleton, poi abbiamo un insieme di altri insiemi che ci servono a fare il mimiing, la simulazione degli assegnamenti di verità. E allora abbiamo così per ogni variabile buleana x con i abbiamo due insiemi. Lo vedete? Sì. [Applauso] T di I true e T con i false. Come sono fatti? T. Sì, per ognuna delle variabili buleane che abbiamo nella formula x con i, adesso noi andiamo a costruire degli insiemi che stanno dentro falmente ci vanno un po' a stabilire, ma se diamo true a questa variabile, che cosa stiamo andando a soddisfare? Perché quello che dobbiamo fare è sostanzialmente rimappare la soddisfacilità della formula su un problema di partizionamento. Ok? Quindi ci dobbiamo inventare questi insiemi tale per cui noi partizioniamo u se abbiamo un modo di risolvere di di soddisfare la formula. Ok? Allora, per ogni varabile buleana x con i di f noi abbiamo due insiemi, t con i true e t con i false. In t con i true abbiamo l'oggetto x con i unito a che cosa? agli oggetti PJK tali che lambda di JK è uguale a not X con E. Allora, qui abbiamo un'inversione. Qual è il significato? In T con i true mettiamo l'oggetto X con i più tutti gli oggetti associati a quei letterali tali per cui quando assegniamo vero a x con i quelli vengono falsificati. Ok? Quindi t con i true. Facciamo questa inversione, mettiamo x con i più tutti gli oggetti letterali associati a quei letterali che quando diamo vero a x con i loro vengono falsificati. Ok? Facciamo il contrario. Va bene? Questo perché? Perché noi il nostro obiettivo sarà poi far sì che noi possiamo scegliere e Ok, c'è un altro pezzo, poi ve lo mostro. Ok, allora ci saranno degli oggetti per dire questa clausola viene soddisfatto da questo letterale. Ok? Quindi, mantenendo la stessa idea, abbiamo T con i false, è fatto da X con i unito T con JK tale che lambda di JK è uguale a X con i. Ok? Quindi anche in questo caso la semantica è quando scelgo questo insieme io prendo l'oggetto x con i più tutti gli oggetti letterali tali per cui quando do false a x con i il letterale è falsificato. Ok? Quindi stiamo facendo l'opposto. Qua il foglio è finito, serve un'altra pagina. Ok. Alri, quindi abbiamo che in F di F ci stanno [Musica] questi singleton, ok? Poi per ognuna delle variabili x con i di f abbiamo questo insieme e quest'altro insieme. Dopodiché ce n'è un altro che è per ogni clausola per ogni clausola CJ di F abbiamo le coppie C con J P dij J con J PJ2 C con J PJ3. Ok? Intuitivamente noi avremo che questi insiemi della partizione possono essere selezionati quando la variabile quando la clausola C con J viene verificata da quel letterale o da questo o da questo qua. Ok? Questo sarà un po' il significato. Benissimo, facciamo un esempio. PJ eh PJ PJ. Sì, la mia scrittura fa un po' pietà. TJ pigiama. Ok. Allora, facciamo un esempio, un esempio di trasformazione. Supponiamo che f sia Ah, qua l'avevo preso vario, vabboh. X con 1 or not X con 2 or X con 3 and not X con 1 or X con 2 or X con 4. Ok? Questo è x 1. Eh, allora udify in questo caso sarebbe x 1, x 2, x 3, x con 4. Poi no, mettiamoli assieme. Poi ci sarebbe C 1 e C 2 perché abbiamo due clausole e poi avremmo P di 1 P1 2 1 3 P2 P2 2 e P di 23. Ok? Questi sarebbero gli oggetti che andrebbero a finire in UDF. In F dif cosa avremmo? avremmo i singleton, abbiamo detto, quindi P di 1 P di 1 2, P di 1 3, di 2 1, di 2 [Musica] P di 2 3 P di 2 3. Ok? Poi avremmo gli assegnamenti, quindi avremmo T1 true che è dato da X1 più tutti gli oggetti letterali che vengono resi falsi quando assegniamo true a X con 1 e in questo caso è solamente lui, quindi è T Poi c'è T false che è X con 1 P1 1. Ok? Poi avremmo T2 true, T2 false, quindi avremmo X2. Quando assegno true a X2, P1 2 diventa falso e lì è a posto. Poi T2 false ci sta X2 e P2. Poi c'è T di3 true che è X di 3 [Musica] e basta. T di 3 false che è X3 P 13. Poi c'è T4 true che è X4 e basta perché mantenendo true non viene mai messo a falso, nessun letterare. T4 false e X4 P23. Ok? E poi ci stanno tutte le coppie. C1 P1 C1 P12 C1 P13 C2 P21 Scusate le zampe di gallina C2 P22 [Applauso] C2 P23 Ok. E questo chiude F. Dove? Dove? Terza riga dal basso. Terza riga dal basso. Quella è una F. È una F. Dovrebbero farli un po' meno sensibili sti aggeggi. Ok. Ok. Quindi questa, per esempio, è la trasformazione di quella istanza, no? In quello là. Ok? F chiuso se la pr eh dove, scusa? L'ff dif. F dif è questa qua. Sì, una cosa par è questa. Questa qua chiude questa. Chiude questa. Sì, sì, sì, sì, sì, sì. Ok. Perché è un insieme che contiene altri insieme. È un insieme di insieme. Ok? Alri. Quello che noi dobbiamo ora dimostrare è che una Sì, sì, sì, sorry. Ok, che metto un po' così. Ok, ho semplicemente dato un esempio, un'istanza particolare di file trasformata secondo questa regola. Ok? Quindi la nostra funzione f quando riceve una fa in questo modo sputa fuori una u con tutti quegli oggetti e una f con tutti quei sottiemi. Ok? Adesso noi quello che vogliamo dimostrare è che la formula fai è soddisfacile se è solo se ok? se e solo se la eh dentro f ci sta un partizionamento un partizionamento di u. Ok. Ok, posso vado. Ok. Dimostriamo questo verso, cioè se fai è soddisfacbile, allora in fzione di Udify. Ok? Supponiamo quindi che fai sia soddisfacile. Ok? Se fai è soddisfacbile esiste una un assegnamento di verità sigma per le variabili di file tali che f soddisfi, che sigma soddisfi ok? Per mostrare che in F dify c'è una partizione di UDF, la dobbiamo mostrare, la dobbiamo costruire. Come la costruiamo? La costruiamo partendo da sigma. Ok? Noi sappiamo che sigma è un assegnamento di verità per le variabili x con i tale che fai sia soddisfatta. Allora, noi per la partizione di eh per la partizione di eh di ufy, prendiamo questo se sigma di x con i è vero, prendiamo T con i true. Se sigma di x con i è falso, prendiamo t con i false. Ok. Inoltre prendiamo le C con JPJK tali che il letterale lambda JK è resovero. Eh, reso, no, reso vero in sigma. Qua mi serve spazio. Come faccio? Andiamo a salire e non appare nei ticoni true o ticoni false. Ok, qua sono un po' salito, non avevo spazio. Ok, allora come facciamo? Stiamo partendo da una foddisfacile. Siccome f è soddisfacbile, noi abbiamo noi abbiamo che cosa abbiamo che c'è sigma che la soddisfa. Noi partiamo da sigma per costruire una parrare che dentro f di f c'è una partizione di U di fi. Come facciamo? La dobbiamo mostrare. E adesso la mostriamo. La costruiamo in questo modo. Partiamo da sigma. Se sigma segna vero ad x con i, tipo x2, allora prendo t2 tr. Se sigma segna false a x con i, allora prendo t con i false. Ok? Sì. Scritto. Quale? Questo. Questa questo scarabocchio che ho scritto qua. Ok. Qua c'è scritto il letterale lambda jk è reso vero in sigma e non appare nelle t con i true o t con i false. Ok? I con o o t con i false. Ok. Manca un pezzo e mi serve per forza l'altra pagina. Ah! Ah! Ok, a sto punto poteva andare direttamente. Poi prendiamo i PJK rimasti fuori, ok? che sono sti PJK rimasti fuori perché tramite le Ticoni true, allora tramite queste qua, tramite o questo o noi andiamo a coprire gli oggetti X con i più parte dei P con JK K, quali? quelli resi falsi dall'assegnamento. Tramite questi mi vado a coprire gli oggetti C con Jc oggetti PJK che non erano finite qua dentro. Quello che può accadere è che altri oggetti PJK sono rimasti fuori dalla copertura. Abbiamo i singleton e in quel caso ce li andiamo a prendere uno per uno. Tutto ciò che è rimasto fuori lo andiamo a raccogliere così, no? Le briciole le ce le andiamo a raccogliere in quel modo. Sì. Ma è possibile che non venga preso nessuna coppia CJPJK? No, no, le prendiamo noi le coppie CJ PJK. Sì, però c'è come c'è scritto che la il PJK non deve apparire nelle Ok, adesso lo dimostriamo. Adesso qual è la questione? Come giustamente la nostra collega ci stava dicendo, no? Dice, "Ma siamo sicuri che una partizione del genere ci sta proprio in UDF?" Cioè, non è che stiamo andalasciamo qualcosa o non è che stiamo andando a sovrapporre insiemi. Allora, questi insiemi che noi stiamo andando a prendere partendo da sigma non si sovrappongono perché innan questione sta nel fatto che noi stiamo partendo da un sigma che è un assegnamento di verità coerente, quindi non è che prendiamo t con i true e t con i false assieme perché in sigma x con i o sarà vero o sarà falso. Quindi per ognuno di loro ne prendiamo uno solo. Quindi non avremo insiemi che contengono entrambi x con i perché ne viene preso uno soltanto. Poi nel negli insiemi che abbiamo chiamato t con i true e t con i false li compaiono che cosa? gli oggetti P con JK associati a letterali falsificati da quell'assegnamento. Ok? Con C. Quando invece prendiamo queste coppie qua, noi prendiamo la clausola, l'oggetto clausola CJ e ne prendiamo una sola coppia per ogni oggetto CJ e prendiamo la coppia CJ + PJK tale per cui quello è un letterale reso vero da sigma. Tale letterale deve per forza esistere perché sigma soddisfa fai e quindi soddisfa tutte le clausole tale per cui noi possiamo scegliere tutte coppie così per ognuno degli oggetti CJ. Prendiamo un t con i true o un t con i false per ognuno degli x con i e siccome l'assegnamento è consistente, quelli non si andranno a sovrapporre, cosa può rimanere fuori? Possono rimanere fuori oggetti PJK che sono rimasti un po' sparsi, no? Ecco, quelli le li copriamo andando a raccogliere le briciole, ok? Perché abbiamo dei singleton e quelli ce li andiamo a prendere così, ok? Quindi, se la formula è soddisfile, allora f contiene in effetti una partizione di udify. Ok? Quindi abbiamo dimostrato che se partiamo da una istanza s di SAT arriviamo a un'istanza s di Exat. Chiaro? Dobbiamo ora dimostrare l'altro verso e cioè se f di f contiene una partizione di Udify. Allora, fai è soddisfacile. Ok. Allora, supponiamo che P sottoinsi insieme di f di f. Quindi in P, in questo P, noi ci andiamo a mettere alcuni insiemi che provengono da f di f. Supponiamo che P proveniente da F di F sia una partizione di eh UDIF. Ok? Quindi qua dentro ci saranno un po' di insiemi che provengono da fd tra i quali ci saranno T quelli che noi abbiamo chiamato T con i true o T con i false. Poi ci saranno un po' di coppie CJ PJK, un po' di oggetti singleton PJK, insomma c'è qualcosa di vario. Ok? Quello che però sappiamo è che P, questa P qua costituisce una partizione di UDIF. Ok? Allora, per mostrare che fai è soddisfacbile, noi mostreremo che è possibile costruire un assegnamento sigma che parte da P che soddisfa la formula fai. Ok? E noi la facciamo così. Sigma di px i gli assegniamo true. Se t con i true appartiene a p, mentre sigma di p è false se t con i false appartiene a p. Ok? Quindi noi abbiamo questo insieme che stiamo chiamando P di Pippo. Là dentro ci saranno varie insiemi che provengono da f dif. Ci saranno tra questi anche T con i true e t con i false. E facciamo così. Se t con i true appartiene all'insieme Pippo, sigma di Pippo assegna vero ad x con i. Se t con i false sta dentro l'insieme p di Pippo a sigma di Pippo a X con i gli facciamo assegnare false. Ok? Quello che noi dobbiamo adesso mostrare è che così definita questa sigma di P soddisfa la formula f. Ok? Allora, la prima cosa che ci chiediamo è sigma assegna vero o false a tutte le variabili x con i? Sì, perché all'interno della Lauder lauder all'interno della F con Y FP. Sì, tutte le XY. Ok. Ma dentro P, dentro, ok, chiamiamolo Pippo questo, questo insieme. Va bene? P scritto in quel modo. Dentro l'insieme Pippo abbiamo una T con i true o T con i false per tutte le x con i. Può accadere che una manchi, no? Perché? è vero falso. Attenzione, noi stiamo partendo da P di Pippo. Non è che P di Pippo la stiamo costruendo partendo da sigma, noi stiamo facendo l'opposto. Partiamo da un insieme P di Pippo. Attenzione, questo questo è importante e nella struttura di questa riduzione. Un attimo. Quindi qua abbiamo P di Pippo e dentro c'ha roba. Dalla roba che c'è dentro P di Pippo tiriamo fuori un sigma di Pippo che sta da un'altra parte. Allora, quello che io mi chiedo, questa sigma che costruisco qua, assegna o non assegna un valore di verità a tutte le x con i? Se stiamo partendo da di Pippo, Sì. Assegna perché una partizione perché senò P di pip non sarebbe una partizione perché P di pip è una partizione, quindi deve coprire tutti gli oggetti x con i. Adesso noi non sappiamo se x con i sarà coperto da t con i true o t con i false, ma sarà coperto. Quindi sigma di Pippo che sta qua ed è sganciato dall'insieme Pippo assegna un valore di verità a tutte le variabili buleane di di F. Ok? Prim qui prima questione tutte le variabili hanno un valore di verità dentro sigma. Seconda questione. Questo questo assegnamento di verità sigma di Pippo è consistente o no? Nel senso, esiste una variabile buleana dentro sigma di Pippo che riceve vero e falso allo stesso momento. No, perché per abbiamo costruito sig. Eh, ma chi mi dice che non ci sia T con i true e T con i false dentro qui, Pippo. Sì, perché T come in intersezione, quindi esattamente avremo X con in intersezione, quindi non ci può essere. Ok? Allora, che cosa abbiamo? Che da P di Pippo, dall'insieme Pippo, la sigma di Pippo, ok? è un assegnamento di verità che assegna un valore di verità a tutte le variabili e è un assegnamento consistente, ok? Non è che può fare vero o falso. Alri? Adesso la questione è: ma questa sigma di Pippo la soddisfa fai o no? Lo facciamo, lo dimostriamo per assurdo. Supponiamo per assurdo che sigma di Pippo non soddisfi fai. Che significa che sigma di Pippo non soddisfa fai? che esiste una clausola CJ difti letterali sono falsi in sigma di Pippo, ma ciò implicherebbe che nell'insieme Pippo noi non stiamo coprendo l'oggetto CJ, ma ciò non può essere. Perché Pippo è una partizione di UDify, quindi sigma Pippo deve soddisfare per forza fai. Quindi se di se f dif contiene una partizione di ud era perché f era soddispacibile e questo ci mostra che le istanze no di sat vengono mappate su istanze no di exact cover. Quello che noi abbiamo più nello specifico visto è che se siamo arrivati a un'istanza sì di Exat cover non stavamo partendo da un'istanza no di sal. Sì. Ok. Allora, quello che noi ci andiamo a chiedere è che Ok, l'insieme P di Pippo, no? deve contenere una partizione di Udify e UDF contiene tutti gli oggetti C con1, CON2, CON3, C4 e così via, che sono oggetti associati alle clausole, ok? Quegli oggetti dentro fifono essere coperti solo da queste coppie che avevamo definito qua. Dove sta? da quest qua, vedi? Ok. Quindi, siccome dentro l'insieme P uno di quelli deve apparire perché mi deve coprire C con 1. Guardiamo C1. Siccome c con 1 deve essere coperto da qualcuno e può essere coperto solo da quelle coppie, io avrò una coppia o c1 + 1 +1 c1 o c1 2 o c1 p1. una di queste dentro P di P ci restare. Adesso quella lì, poiché non può avere una intersezione con altri insiemi che sta dentro P di Pippo, non può in particolare avere un'intersezione con gli insiemi Toni i true, toni i false. Tigoni tigoni false erano stati definiti per associare quali letterari diventano falsi con quel letterale. Quindi la coppia che mi che mi compare dentro Pippo mi sta dicendo quale letterale sta verificando la causa. Questo è un altro modo per dimostrarvi. Ok? Da cui sigma Pippo deve per forza soddisfare la formula fai. Ok? Chiaro? Alright, 10 minuti di pausa. [Musica] Ok, allora quello che vediamo ora è un problema che sicuramente avete visto, il problema della Bisaccia, che è una cosa classica in ricerca operativa, l'avrete vista o al corsi di algoritmi eccetera che è il problema del problema del NAPSAP. Ok, me lo sapete definire? Vi ricordate com'è definito il problema del NAPS? [Musica] trovare gli elementi con la dienti e la capmaile da elementi selezionati dal vale che superino la Esattamente. Sì, questo è il problema della Bisaccia classico. Ok, come le ho chiamate qua le cose, così non ci perdiamo. Ok. sia 1 n un insieme di oggetti. Per ognuno di loro abbiamo un peso Boni e doppia v con i e un valore con i e poi abbiamo una soglia w grande. Quello che noi vogliamo trovare è un sottinsieme di 1 n tale che la somma di i che appartiene a s di w con i non ecceda w e la somma per i che appartiene a s dei valori di quegli oggetti è massima. Ok? Vi ripeto, il problema del Napizzato. Abbiamo un insieme di oggetti 1 N. Ad ognuno di loro è associato un peso w di, ad ognuno di loro è associato un valore di con i e poi abbiamo una soglia di peso w maiuscolo. Quello che noi vogliamo trovare è un sottoinsieme degli oggetti tali per cui la somma dei pesi degli oggetti selezionati non ecceda w grande e la somma dei valori degli oggetti selezionati è massimo. Sì. La sommatoria cosa siè scritto? Come? Scusi. Sommatoria cosa cè scritto? Sommatoria per i che appartiene ad s di w con i e qui è sommatoria per i che appartiene a s di v con i. Questo problema sta in np? Sì. Sì, perché una volta che indoviniamo il eh il sottoinsieme basta verificare Massimo. Mh. Questo problema sta in NP. Ah, no, perché perché non è un problema di decisione, ok? Questo è un problema di ottimizzazione, così definito. Quindi a noi serve una variante di decisione. Ok? La variante di decisione la facciamo in questo modo. State attenti che quello è un errore comune. In NP e in P ci stanno solo i problemi di decisione. Problemi di ottimizzazione non stanno là, anche perché vi faccio notare, poi lo vedremo, spero che ci arriviamo in una delle lezioni. è difficile trovare gessare una una soluzione migliore che ce lo garantisce che che lo è. Cioè non c'è un certificato facile, ok? Cioè serve altro. Quindi in realtà il problema di ottimizzazione è più complicato. Quindi la versione che noi abbiamo è dato un insieme di oggetti 1 n per ognuno dei quali abbiamo un peso e un valore e due interi w e k. Vogliamo trovare un sottoinsieme di eh degli oggetti tale per cui il peso totale non eccede w e il valore totale è almeno K. Ok? Quindi questa è la versione di decisione del problema. Adesso questo sta in NP. Ok? Quindi noi vogliamo dimostrare che Napsa è NP completo. Membership. Come facciamo a dimostrare che la variante di decisioni di Napsac, quindi il NAPSAC, così come l'abbiamo definito, è in NP. E semplicemente troviamo sotto insieme, quindi poi verifichiamo che i valori la somma dei valori e che la somma dei pesi non eccetera W. Ok? Quindi la dimostrazione che il problema in NP è abbastanza semplice. Guess polinomiale, check polinomiale. Ok? La questione più spinosa è mostrarne la hardness. Ok? La hardness, come vi anticipavo, la mostriamo tramite riduzione da exact cover. Quindi riduciamo exact verso il Napsap. Ok? Ora vi faccio notare che appunto questa trasformazione è una cosa un po' strana perché che cos'è? Vi ricordate che cos'è un'istanza dell'exact cover? Una coppia U e F. F. Sì. Che cos'è un'istanza di Napsac? È tanta roba. Che cos'è? Un insieme di oggetti. un insieme di pesi. V1 pa pa VN, un insieme di valori e poi due interi w B grande e K grande. Ok? Quindi noi dobbiamo trovare una trasformazione F che dà una coppia universo, insiemi di sottinsiemi dell'universo, ci tira fuori un insieme di oggetti, dei pesi associati, dei valori associati, un target di valore e una soglia massima di peso, ok? Cioè sta F deve tirare fuori tutta questa roba qui, ok? e lo deve fare in maniera tale che dentro f ci sta una partizione di U. Se è solo se l'istanza di Napsac che generiamo ammette un modo di scegliere oggetti tale per cui la somma dei pesi non eccede w e la somma dei valori è almeno k. Ok? Quindi insomma questa funzione f deve fare un gran bel lavoro. Ok? Ci dobbiamo inventare una cosa un po' tricchy. Ok? Allora, vi do un primo un primo input, ve lo do io, dopodiché ci ragioniamo un po' assieme, ok? Allora, l'istanza che noi andremo a costruire di Napsac, guardate che queste questi oggetti qua che la formula F costruisce possono essere qualsiasi. L'importante è che rispettino il mapping di istanze sì su istanze sì e istanze no su istanze no. Ma non è che abbiamo dei vincoli che debbano avere, no, debbano o non debbono avere una forma particolare. Allora, fra tutte le istanze di Napsac che F può tirare fuori, noi ne costruiremo una molto particolare che ci permette di semp semplificarci un po' le cose. Nonostante questa riduzione costruisca un'istanza di Napsac molto specifica, quello non toglierà nulla alla difficoltà del problema Napsac se noi siamo in grado di evappare in ogni caso exact su NAPSAC. Ok? Cioè il fatto che noi costruiamo in maniera molto peculiar istanze del problema di di destinazione non significa nulla, significa che quelle stanze, quella classe di stanze molto limitata già dai loro è NP ardua. Ok? Tutto qua. Allora, nella riduzione fongo, noi avremo che w v I sarà uguale a V con I. per ogni i edoltre avremo che W grande sarà uguale a Kand, ok? Quindi sarà l'istanza che F costruirà sarà un'istanza molto particolare, un'istanza in cui ogni oggetto vale tanto quanto pesa e W sarà uguale a K. Come problema diventa possibilità. Mh. Allora, guardate la definizione voi la vedete là? Sì, vedete tutto? Ok. Sì. K. La F che noi costruiremo costruirà sputerà in output fuori un W = K. Avrà questa peculiarità. Possiamo decidere di farlo. Sì, gli elementi che poi cioè che si deve essere contemporaneamente. Esattamente. E questa l'osservazione che vi volevo fare. Il nostro collega è stato molto veloce in questo, ha individuato questa cosa. Siccome W grande è uguale a K e le W con I piccole sono uguali alle V, siccome noi dobbiamo verificare sia questo che questo, il tutto si riduce a Ma esiste un insieme delle w con i che sommate da esattamente w se noi andiamo a costruire, cioè se f tra tutte tutte le stanze di Napsak che può tirare fuori, sputa queste qui particolari. Queste stanze saranno istanze sì se esiste un modo di scegliere degli oggetti tale per cui la somma dei loro pesi è esattamente w. Ok? Quindi ci siamo andati a ridurre a ricondurre a un problema molto più semplice. Ok? È chiaro? Cosa? Cosa facciamo? il trucco e noi sfruttiamo questo per la riduzione da exact. Ok? Cioè se consideriamo questa cosa qua, la riduzione da exacterà una cosa aliena. Ok? Allora, il trucco è eh No, no, pensiamoci un po' assieme. Ok? Allora, quello che noi dobbiamo inventarci, quindi è chiaro? Quindi noi stiamo partendo, abbiamo il nostro programma di partenza che sta qua, bello, visualizzatelo. UF un insieme di oggetti che è l'universo, più una famiglia di sottoinsiemi e noi ci vogliamo chiedere se questa famiglia di sottoinsiemi contenga o meno una partizione di u. Quindi qua c'abbiamo la nostra istanza. Dall'altro lato, immaginate la bella separata, abbiamo un insieme di numeri più un numero grosso W. E noi ci vogliamo chiedere se esista un modo o meno di selezionare numeri da questa lista tale che tali che la loro somma sia esattamente W. Quindi da un lato mi chiedo se posso scegliere insiemi che partizionino u. Dall'altro mi chiedo, esistono numeri che sommati fanno w. Che numeri ci possiamo inventare? Io potrei partire da ho una partizione m ho n elemento nella parezione. Ah ah indice 1 n sono il numero di elementi che ho nella partizione. Il numero di insieme che ho nella parzione. Ok. Ok. Un attimo. Quello che voglio capire è lei sta le le hanno consegnato in mano una partizione e lei sta trasformando la partizione. Non si può fare perché noi dobbiamo trasformare UF, non l'insieme pippo. Ok? A noi ci danno U ed. Questi due cosi devono diventare un insieme di numeri, una lista di numeri e un numero w grande tale per cui dalla lista dei numeri noi possiamo sceglierne alcuni che sommino a w grande se solo se dentro f potevamo scegliere in qualche modo una partizione dello dell'insieme U. Chiaro? Come si può fare? Io tengo un occhio sull'orologio. Sì, prego. Eh, magari dat Q ed f per potremmo trovare insiemi eh di fsi compongono la partizione e quindi da lì, quindi verificando il polinomiale. Attenzione perché se lei mi sta dicendo io dentro f mi calcolo la partizione di u e quella cosa io non la so fare in tempo polinomiale perché perché exact cover è np completo. Quindi tirarmi fuori da f la partizione di u se c'è non lo riesco a fare in tempo polinomiale. Dobbiamo fare un'altra cosa che prescinda dal verificare se f contenga o meno una partizione, perché se io me lo chiedo ci impiego troppo tempo. Come la funzione f deve essere deterministica. deve essere deterministica e calcolarsi in tempo polinomiale. Sì, è un'idea che ma noi accettiamo tutto. E u io lo metterei come la nostra lista di oggetto essenzialmente. Ah, e poi per a partire da f per creare i che poi sono uguali ai valori per assunzione andrei a contare dentro fante volte appare il singolo oggetto del tipo m se ho l'oggetto uno che appare due volte quello è il suo valore, il suo peso. Ok? Eh, potrebbe essere una strada. Si tratta sì di trasformare, cioè l'idea da cui dobbiamo partire è più tipo questa che ci dice la nostra collega, cioè andare a guardare la struttura di f e tirarci fuori dei numeri. Non possiamo calcolarci la partizione, serve troppo tempo. Prego. Ho una domanda. Gli insiemati F. gli insiemi in fini insieme, scusi, l'insieme matematico di solito non possiamo usar Ok, no? Cioè dentro f ci stanno possibili sottoinsiemi di U che possono avere intersezione vuota o non vuota, eccetera. Perché la questione è: "Ma tra tutta la roba che ci sta in f io ne posso selezionare qualcuno che mi partizioni uno?" e dall'altro lato. Ma tra questi numeri che ho ne posso selezionare qualcuno? Alcuni che sommati fanno W? Ok, sta prendendo del tempo. Vi do un hint. Ok. Rappresentazione binaria dei numeri. Vi dice niente? Come il tutto si può partire. Ok, poi ci dobbiamo un po' lavorare su rappresentazione binaria di numeri. Rappresentazione binaria di numeri 01. quel 01 possono essere le cifre del numero binario oppure possono dirci che cosa? Appartenenza appartenenza o meno di che cosa? Come un attimo appartenenza a un sottoinsieme di un determinato un sottinsieme di cosa? Eh, dell IF. Ok, la sua idea. Ok. Allora, l'idea principale, poi la dobbiamo rifinire perché adesso vedremo un po' di cose, è che gli insiemi dentro f No, vi faccio un esempio specifico che poi ci servirà anche per dopo. Supponiamo di avere u in questo modo, 1 2 3 e 4. Ok? Ed f è fatto così. 2 3 e 4. Ok? Allora, l'idea e siccome questa U e questa F devono essere mappati verso una lista di interi e un numero w, allora come ci propongono i nostri colleghi è che questa f, quindi se questa è f1, f2 f3, questo qui diventa il numero w di La qui rappresentazione binaria è 001 1 in base 2. Da qui io ottengo w2 che è 01 in base 2 e da qui ottengo V3 che è 0 1 in base 2. Ok, peremp f1 come f3 con f160 cap3 sì in quel esempio in più di f1 e di f1 casistica? Ma perché no? È un caso del del problema di Exact cover. Noi dobbiamo essere in grado di di ah di essere dobbiamo essere in grado di trasformare qualsiasi istanza di exacto cover. Ok? Particolare questa che vi ho scritto qua è un'istanza sì o un'istanza no di exact cover? È un'istanza no perché possiamo inventarci quello che vogliamo. Noi l'oggetto uno non lo copriamo in nessun modo. Ok? Quindi questa è un'istanza no. Però l'idea che i nostri colleghi ci hanno dato è che noi partiamo da f1, f2, f3 e in base agli oggetti che stanno in f con i costruiamo il peso w con i in cui se c'è l'oggetto j mettiamo il digit, la cifra 1 nella rappresentazione binaria di W con. Se l'oggetto j non ci sta, noi ci mettiamo la cifra zero. Ok? Quindi questo qua che cos'è? Questo è 3, questo è 5 e questo è 7. Ok? Per W. W otteniamo da questo. W grande. Che cos'è? È tutti 1. Ok? Quindi questo quanto vale? Questo vale 15. È chiaro? Chiaro per tutti? Quindi l'idea di fondo è trasformare gli insiemi dentro fso numeri che in qualche modo codifichino cosa ci sta dentro f e cosa non ci sta dentro f. Ok? E lo facciamo andando a guardare la rappresentazione binaria dei dopp con. Se l'oggetto J c'è, usiamo la cifra 1, la corrispondente cifra 1. Se l'oggetto J non c'è, usiamo la corrispondente cifra 0. Ok? Quindi, sostanzialmente, se noi invece quelle stringhe binarie, quelle quei numeri in binario, le interpretassimo semplicemente come delle stringhe di bureani, staremmo riconducendo l'or logico di quelle stringhe di bureani a fare la somma di str di numeri rappresentati binari. Cioè, questa è la è il mapping che stiamo cercando di ottenere. Ok? Vi è chiara almeno l'intuizione? Questa cosa funziona così com'è o no? No. Perché? Perché in questo caso abbiamo un'istanza normale arriviamo a un'istanza sì. Arriveremo a un'istanza sì di questo Napsa perché perché quando facciamo la somma qual è il problema? Ah, ok. 0 1 che è quello là. che è il secondo + 1 1 uguale 1 1 1 1. Il problema dove sta? L'orologico non dà la stringa di buleani tutti uno, ma la somma dà la stringa la il numero la cui rappresentazione binaria è tutti uno. Dov'è il problema? È che corrisponde a W. Corrisponde a W. Ok, ma in questa somma, qual è il problema di questa somma che non ci permette di replicare l'or logico di queste? Se noi interpretassimo quelli come stringhe di buleani? È il riporto, ok? Cioè noi in questa somma abbiamo il riporto che ci crea dei problemi, quindi noi ci dobbiamo inventare dei numeri tali per cui il riporto non ci dia dei problemi. È chiaro? Tutto lì. Poi se noi riusciamo a superare questo ostacolo, il l'ostacolo del riporto, il gioco è fatto, la riduzione funzionerebbe. Ok? Allora, spostiamoci su un'altra pagina. Quindi noi abbiamo un'istanza U fatta di oggetti da 1 a n e un insieme ftoinsiemi di U che sono F1 FM. Quindi un pezzo noi già lo sappiamo, questa cosa qua deve essere trasformata in un insieme di numeri w con 1, w con m e poi un w grande. Ok? Questa è la trasformazione che vogliamo ottenere in maniera tale che è possibile selezionare nella lista W con1 W con m dei numeri da lì la cui somma sia w. Abbiamo visto che la codifica binaria del peso eh ottenere i pesi tramite la codifica binaria dell'appartenenza o meno di oggetti a F agli F con J è una buona idea. Il problema è il riporto. Ok? Quello è il riporto. Quindi dobbiamo inventarci dei W con i o W con J tali che il riporto sicuramente non ci dà problemi. Come facciamo? L'orologico perché l'orologico non lo possiamo usare perché nel problema di arrivo non stiamo facendo lor di stringhe e goleare, stiamo facendo somme di numeri. Quindi è la definizione del problema che ci costringe a guardare la somma. Allora noi dobbiamo inventarci però dei numeri tali per cui il riporto non ci dia fastidio. Quella è la è la questione. Come si fa? convertibile alla fine per riconvertire invece no perché quello che noi dobbiamo ottenere è una trasformazione degli f con j nelle w con j tale per cui il solutore del naps che di or logico non ne sa proprio nulla selezioni i numeri li sommi e ti dice sì riescono a sommare a doppio q ok Come possiamo fare a evitare che Sì, posso usare tipo il bit di parità, potremmo usare tipo un bit di parità oppure vi guido perché sennò non finiamo per tempo. Ok? In questo esempio specifico, in questo esempio specifico UF, quanti f Quanti F con hanno dentro f? Ciò significa che nella peggiore delle ipotesi noi avremo tre numeri da sommare. Ok? Come facciamo a essere sicuri che la somma di tre unità non generi riporto? Scegliamo tre. Che cosa? Togliamo togliamo tre. No, che quegli un Sì. al massimo cifre se un eh ok però una possibile soluzione potrebbe contemplare di prenderle tutte. Come facciamo a essere sicuri che la somma di tre unità non genne di riporto? Questo è proprio un volo di fantasia, eh? Ci prendiamo qualche secondo, poi ve la dico, perché senò non finisce. Sì, vado ad espandere il la somma dal punto di vista gli elementi. Quello lo potremmo fare, però poi a un certo punto avremo dei riporti che si vanno a collocare su colonne che noi non vogliamo. Se cambiassimo la base, in che base? E 13. Attenzione perché 1 + 1 + 1 in base 3 fa 0 e riporta di 1 in base 4. Noi interpretiamo questi uni in base Ok? E questi qua, siccome ne costruiamo m, li interpretiamo in base m + 1. In quello abbiamo la certezza che la somma di m unità in base m + 1 non genereranno mai un riporto. Ok? Quindi, e qua adesso vi scrivo la formulona che è questa qui. Noi abbiamo che W v con i è uguale a che cosa? Alla sommatoria degli oggetti jartono a f con i di 1 * m + 1 elev n - j. Questo questa cosa complicatissima che ho scritto è semplicemente questi numeri qui interpretati in base m + 1, in quel in questo caso 4. Quindi questa è la formulazione generica. W con i è il numero. Le qui cifre sono 0 e 1 e gli uni stanno in corrispondenza degli oggetti che stanno dentro eh l'insieme f con i, però interpretati in base m + 1. Ecco perché scriviamo questa cosa qua per semplicemente dire che quella è la cifra 1. Ok? Ovviamente dove non c'è sarebbe 0 per e auguri. Ok? Chiaro? Quindi W con i è interpretato in questo modo. A quel a quel similmente avremo che K è uguale alla sommatoria per J + 1 elev n - j. Questo cos'è? Questo K w ok? La stessa cosa. Che cos'è? è semplicemente il numero in base m + 1 fatto di tutte e cifre 1. Ok? Alrght ora noi dobbiamo dimostrare è che un'istanza C di Exact Cover viene trasformata in un'istanza C di Napsac in questo modo e le istanze Sì di Napsac ottenute tramite questa trasformazione partivano da istanze sì di exact cover. Ok? Alri, quindi se UF, non mi ricordo se usavo le parentesi angolari, ok? UF è un'istanza sì di exact cover. Allora, l'istanza F di UF di Napsak [Musica] questa è una unistanza. Sì. Ok. Come si dimostra? Supponiamo di star partendo da un'istanza sì di ah exact cover. Ok? L'istanza di Napsac, vi ripeto, non è un'istanza di Napsac a caso, è un'istanza di Napsac ottenuta con con questi numeri molto specifici, eh? Ok. Se partiamo da un'istanza s di exact cover, allora dentro f ci stanno dei sottoinsiemi di u che costituiscono una partizione di u. Ok? i numeri. Se io prendo le stringhe buleane che rappresentano questi insiemi, quali oggetti ci stanno o no, avremo che queste stringhe buleane non avranno uni in comune sulla stessa colonna e su ogni colonna ci sarà almeno un uno. Ciò significa che i rispettivi numeri w V con i ottenuti in quel modo là sono numeri in base m + 1 la cui somma è esattamente w v perché è il numero in base m + 1 dove c'è la cifra 1 a tutti colonne. Ok? Quindi se passo se parto da un'istanza sì di exact cover ottengo un'istanza sì. Quella è stanza di X. Ok. Eh? Sì, prego. Se io per la funzione fatto da tutti, cioè sono giunti non sono necessariamente giunti f la soluzione, cioè dentro f io devo trovare alcuni di loro che sono disgiunti e sommano a u, però dentro f gli f1, f2, f3 i lì principi possono sovrapporsi. sta al solutore decidere di non prenderli assieme, seò era facile, ok? Quello che rende il problema complicato, il fatto che dentro fgli f con i si sovrappongono in linea di principio. Quindi qual è che prendo? Quale questi due si sovrappongono? Quale dei due preferisco prendere? Perché lì dici magari uno mi preclude la costruzione della soluzione e l'altra no. Ma io non lo so da principio, devo semplicemente provare. Però quelli che prendono in distanza sì so che per sono quelli che prendiamo. Il discorso è un po' diverso. Se io parto da un'istanza, sì, vuol dire che esiste una soluzione. Ma chi sia, non lo so. So solo che ne esiste una la cui struttura sarà questa, cioè che le strano le stringhe buleane 01 degli fno parte di una soluzione che non conosco, non avranno uno in comune e copriranno tutte le colonne, quindi i rispettivi numeri in base a n + 1 sommeranno a quel w. Ok? Supponiamo di essere arrivati, quindi questo è il primo verso della dimostrazione. Supponiamo quindi questo l'altro verso è questo qua. Se f di UF è un'istanza sì di Napsak, no? Opsac. Ok. Allora, UF è un'istanza sì di exact cover. Mamma mia, non sapevo male. Ok, supponiamo di essere arrivati. Qui c'è il giochetto del riporto, eh. Supponiamo di essere arrivati a un'istanza sì di NAPSA. Vi ripeto, l'istanza sì a qui arriviamo non è un'istanza a caso, è quella, eh, cioè ha quella forma specifica. Supponiamo di aver costruito che f abbia costruito un'istanza dif che è un'istanza i allora vuol dire che fra tutti w con i, mettiamolo qua, ok? Fra tutti W con i che ha tirato fuori f ne esistono alcuni di loro che sommati fanno w. Ok? Guardiamo questo W. Questo W è il numero che in base m + 1 è formato da tutte cifre 1. Siccome io le W che ho sono al più m e le sto considerando come numeri in base m + 1 e sono numeri le cui cifre sono 0 1 ma in base m + 1, io non potrò mai generare un riporto nella somma di m numeri in cui la cifre sono 0 1 se sono in base m + 1. Quindi se la loro somma produce un numero che in base m + 1 è 1 1 1 1 1 1 1 1 1 1 e questa somma non ha mai generato riporto, allora vuol dire che in tutte le colonne deve comparire 1 e in tutte le colonne non deve comparire più di uno, senò alla somma avremmo un altro simbolo, ok? avremmo zero, avremmo un'altra cosa. Quindi che cosa avremmo? Che su tutte le colonne compare esattamente una cifra uno. Quindi quelle w con i che sommano a w grande provengono da f con i che sono una partizione dell'U di partenza. Quindi se abbiamo se F ha costruito un'istanza s di Napsa era perché partivamo da un'istanza s di Exact da cui Napsa è NP2 e poiché Napsa si può esprimere come un problema di programmazione lineare intera, non so se l'avete vista ricerca operativa, tutta la programmazione lineare intera è NP alua. La prova che sia in NP è abbastanza sofisticata, non la vediamo. Però una programmazione lineare intera, poiché può esprimere Naps e Naps di decisione e NPO, allora la programmazione lineare intera è NP ASA. Prego. La reazione da moltiplica Ok, ci serve su solamente Sì, che mi la parzione. Sì, perché io sto partendo da una partizione di quindi Sì. Se io dico suppongo di partire da un'istanza su UF, allora dentro f ci sta una partizione di U. Non devo cercare la No, io so che esiste. Questo è un passaggio fondamentale. Se volete andare andate, ci siamo. Però questo è è un passaggio fondamentale perché un conto è dire questa partizione me la devo calcolare. un conto e dire questa partizione esiste e ha queste proprietà, cioè non mi importa averla in mano, so che una c'è e ha una proprietà particolare, indipendentemente da chi essa effettivamente sia, quindi in quel caso non ho bisogno di calcolarla. In quel caso io dico ci sta e ha questa proprietà, tutto quanto. Quindi non è che mi serve ottenerla, mi serve sapere che c'è e che abbia alcune caratteristiche. Chiaro? Va bene. Grazie mille per aver per essere venuti a questa lezione il 24 di aprile e immagino avreste preferito fare altro. Ah.