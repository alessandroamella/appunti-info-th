Ok, allora introduciamo l'ultimo concetto, gli ultimi due concetti di questo corso. Non andiamo troppo nei dettagli, mai per darvi un po' un'idea. Vedremo oracoli, macchine a oracolo. Oggi è un'introduzione alle classi funzionali e poi prossima volta continueremo sulla cosa. quindi problemi di ottimizzazione eccetera. Ok? Allora, ci focalizziamo su questa cosa qua. Problema del vertex cover. Ve lo ricordate cos'è un vertex cover di un grafo? dato un grafo, un vertex cover e un insieme dei suoi nodi, tale per cui per ogni arco almeno uno degli end point dell'arco è coperto da uno dei dei vertici nel vertex cover. Ok? Chiara la definizione di vertex cover? E vi ricordate come avevamo definito il problema di decisione? Per vertex cover l'avevamo chiamato VC, mi pare. Che cos'è? Cos'era il linguaggio del vertex cover? Sì. GKF Sì. Tale per cui scorere in Italia. Esattamente. Taglia al + K. Ok. Vi ricordate la complessità di questo problema? è un problema NP completo. Ok, sto un attimo riacchiappando le nozioni che ci servono oggi. Mi sapete dire perché questo problema sta in NP? Ok? Questa è la cosa importante, cioè che per rispondere sì gessiamo un vertex cover, verifichiamo che la sua taglia non sia maggiore di K. verifichiamo che in effetti il set di nodi gessati è un vert e rispondiamo di sì. Ok? Quindi la ragione per cui questo problema di decisione sta in NP è perché noi abbiamo un certificato conciso per rispondere di sì. Lo che siiamo. In particolare il certificato conciso in questo caso è una soluzione candidata. Gessiamo la soluzione, la verifichiamo, se va bene diciamo sì, altrimenti tagliamo il branch. Ok? Vi ricordo che una macchina non deterministica accetta se ha un modo di accettare. Di conseguenza accetta se è in grado di trovare questo certificato che gli attesti che l'istanza che abbiamo sottomano è un'istanza sì. Ok? Chiaro per tutti questa cosa qua? Perché ora giochiamo su questa cosa qui, sulla definizione di NP con NP eccetera. È chiaro? Quindi perché è in NP questo problema? M vi ricordate intuitivamente la caratteristica dei problemi in CNP? Come? Scusi, sono complementi linguag Sono complementi dei linguaggini NP. E che caratteristica avevano? Per rispondere il no. Ok. Quindi i linguaggi in NP sono quei linguaggi per i quali noi possiamo ghessare la prova che l'istanza che abbiamo in mano è un'istanza no. Ok? Quindi problemi in NP sono quei problemi in cui gesso la prova che l'istanza più o mano è un'istanza sì. I problemi in cp i quali gessiamo la prova che l'istanza che abbiamo in mano è un distanza no. Ok? Chiaro? che ora iniziamo a vedere cose un po' strane. Definiamo quest'altro problema. min cover è l'insieme delle coppie GK tali che G è un grafo i cui vertex cover di taglia minima. anno taglia K. Chiara la differenza di definizione di questi due problemi? Il primo ci dice dato un grafo, un numero k, è vero o no che questo grafo ammette un vertex cover di taglia al + k? E noi rispondiamo sì, no. Questo è un altro problema di decisione leggermente diverso in cui dicevamo, dato questo grafo è un intero K, è vero, no, che i suoi vertex cover di taglia minima contengono esattamente K nodi e devono essere i vertex cover di taglia minima, eh non un vertex cover a caso. Quindi cover è definito come le coppie grafo numero tale per cui il grafo G tale per cui i verte cover del grafo G, i vertex cover minimi del grafo G hanno una taglia esattamente K. Eh, non è che dici almeno al + k, esattamente K. Ok? Taglia minima taglia K. Anno taglia K. Dopo taglia minima. Sì, sì, hanno cover di taglia minima. Hanno taglia K. Ok, prendetevi qualche minuto per pensare in quale classe di complessità potrebbe stare sto problema. Vi è chiara la differenza fra i due problemi? Quello fa la differenza. Sì. Non potremmo testare tutti i valori e calcolare eccetera se coper dà un positivo e se lo dà dà un riso. Quindi lei vuole testare tutti i valori perché tagli minima, quindi c'è uno inferiore. Esatto. Quello lì che è falso, giusto? Sì, noi cerchiamo, dobbiamo essere di Kor uguale. Io voglio che i vertex cover di taglia minima di G abbiano taglia esattamente K. Quindi sono inferiori che tend sono due. Mh mh. Quindi se consumiamo il cop per tutti i valori inferiori K mh e qui siamo sì second possiamo determinare se E quanti sono? Dipende con K. Le K10 sono nuove macchine cover. Sì. E rispetto alla taglia di K, questo è un numero, il numero di testa rispetto alla taglia di K, il numero di teste che facciamo è polinomiale o esponenziale? M attenzione perché K è un numero rappresentato in binario, quindi il suo valore è esponenziale nel numero dei bit che lo rappresentano. Se io mi metto a testare tutto quello che è più basso di K, cioè ci può sta, però lei mi sta dicendo che è exp time. Sì, sta in exp, sta in exp time. Possiamo abbassarlo un pochino? Sta in MP questo problema? [Musica] Abbiamo una procedura che gessando qualcosa, no? abbiamo la certezza che quel K è la taglia, ad esempio, no? Ci dice un grafo e ci dà 15. Se noi gessiamo un vertex cover di taglia 15, quello è effettivamente un vertex cover di taglia 15. Possiamo dire di sì, che quello è il verte cover di taglia mine. No, ok, il problema è questo, cioè noi possiamo gessare una cosa per tentare di rispondere sì. Ok? Cioè, noi che siamo un vertex cover di taglia K, quel set di nodi di taglia K è un vertex cover, però noi stiamo semplicemente dicendo che esiste un vertex cover di quella taglia, non abbiamo la garanzia che sia minimo. Possiamo gessare qualcosa che ci dia la garanzia che siamo in modo? M non si può fa'. Sembra che non sia possibile. Ok, quindi accantoniamo NP. Quali altre classi abbiamo visto? CNP. Proviamo. Questo problema sta in CONP. Pensiamoci un po'. Quindi devo poter ghessare qualcosa per rispondere di no. Sì, possiamo gessare con k - 1 per vedere se se esiste un vertex cover che sia più piccolo di K. Ok? Se ci risponde no, eh proviamo a pensare K. Ma quindi fa doppio di S? Eh sì. No, ne serve uno solo per QMP. Possiamo pensare in modo per dire no come più piccolo. Sì, per esempio, se ci danno in input GK e quel K non è la T è più grande della taglia minima, abbiamo un modo per dire di no, cioè che siamo un vertex cover di taglia più piccola, diciamo di no. Ma se in input abbiamo una coppia GK in cui K è più piccolo del per tex cover di Italian Mina, come facciamo? Come si fa? Si può? intuitivamente non si può nemmeno in NP, ok? Perché nel momento in cui gessiamo qualcosa per rispondere di no, noi non lo sappiamo se quella cosa che abbiamo gessata è un vertex cover di taglia minima o meno. Ok? Quindi pare pare che questo problema non stia né in NP né in QNP. Ok? Abbiamo detto che sta in ex time. Sì, perché possiamo testare tutto. Possiamo dare un bound migliore di exp time tra le classi che abbiamo visto. [Musica] Che classi abbiamo visto? Che ci sta sotto postanzi? Pi spazio. Secondo lei possiamo fare un p spazio? Sì, sì. Comeamo un solo tentativo tentativo di risponder in memoria alla volta. Sì, generiamo generiamo tutti. Esattamente. Ok. Quello che si può fare e per risolvere questo problema in P spazio è che praticamente noi testiamo tutti i i vertex cover candidati, quindi dobbiamo tostare tutti i possibili sottoinsiemi di V dell'insieme dei nodi e ne testiamo uno per volta. Ogni volta che facciamo il test lo scriviamo, lo scriviamo su nastro. Facciamo il test se quello è un vertex cover o meno. Ce lo troviamo, ci appuntiamo la sua taglia, insomma, andiamo alla ricerca della taglia più piccola. Il trucco dove sta? Il trucco sta che ogni volta che facciamo un attempt, poi cancelliamo tutto, manteniamo giusto il valore temporario nel minimo trovato e rigeneriamo un altro vertex cover. Quindi noi con spazio polinomiale, se lo riutilizziamo, siamo in grado di rispondere a questo problema. Ok? Quindi questo problema pare essere no è in ppazio. Quello di che ci vogliamo occupare oggi è dare un bound migliore a questo genere di problemi, ok? Perché questo problema non è, sebbene sia risolvibile in pi spazio, non è uno dei problemi più difficili di Ppace. Ok? In realtà questo problema sta in delle classi al di sotto di P spazio, ma al di sopra di NP che finora non abbiamo visto. Ok? Quindi quello che faremo oggi è introdurre queste classi intermedie che stanno fra NP e P spazio, ok? e caratterizzano problemi di questo tipo, no? Nel quale un gess soltanto non ci basta e pi spazio sembra sparare con un cannone a una mosca, ok? Cioè in P spazio potremmo fare una marea di cose che in realtà questo problema è molto più semplice. Ok. Ok. Allora, quello che noi possiamo notare è uno di voi l'aveva sostanzialmente detto prima, mi pare lei, quello che si può fare in realtà, come il nostro collega diceva, è che a noi bastano due test. A noi basta testare che esiste un vertex cover di taglia K e che non esista un verte cover di taglia k - 1. Ok? Quindi noi possiamo trascrivere il cambiare, ok? La definizione del problema in questo modo. Minco cover è l'insieme delle coppie GK tale che G, scriviamolo meglio, tale che GK appartiene a vertex cover. Gk - 1 non appartiene a vertex cover. Come? Eh, questo qua no, è solo una riscrittura di questo di questo problema. Vi rendete conto che abbiamo definito lo stesso problema? Ok? Quindi in realtà quello che qui ci sta dicendo è che a noi bastano un paio di test. Se noi abbiamo un decisore del problema di vertex cover, noi possiamo uscirne fuori facendo un paio di domande a questo decisore di vertex cover. Ok? Se quindi se noi avessimo una subrutine capace di risolvere vertex cover, noi avremmo semplicemente una cosa di questo tipo, no? Minan cover, prendiamo G e K come input, allora facciamo result. 1 uguale check di vertex cover di GK. Poi prendiamo result 2, facciamo check di vertex cover di G k - 1 e poi restituiamo che cosa? result 1 and not result Ok, questa sarebbe la procedura. Nel momento in cui ipotizziamo l'esistenza di qualcos'altro che è una sabrutin capace di risolvere il problema del verte, allora noi avremo un algoritmo semplicissimo per stabilire se K è la taglia dei vertex cover più piccoli di G. Chiediamo a questa sabrotin esterna, ma è vero che ci sta un vertex cover di taglia al + k? Se lui ci dice di sì, sappiamo che la taglia di del vertex cover su G, ci sono vertex cover di G di taglia al + k. Se ci risponde di no alla domanda gk - 1, è vero che c'è un vertex cover di taglia al + k - 1 quello ci risponde di no. Allora, vuol dire che i vertex cover che G ammette, i vertex cover più piccoli che G ammette hanno taglia esattamente K. Ok? Quindi, in qualche modo, noi vorremmo legare la complessità di questo problema al fatto che noi possiamo risolverlo in tempo polinomiale deterministico nel momento in cui disponessimo di una procedura che è in grado di risolvere il problema del vertex cover. Ok? Quindi ora stiamo modularizzando l'analisi del problema. Stiamo dicendo se nell'ipotesi di disporre di una procedura che risolva il la versione decisionale del vertex cover, allora noi siamo in grado di sviluppare un algoritmo deterministico che lavora in tempo polinomiale, che tramite chiamati a questa procedura esterna è in grado di risolvere il Questa è l'idea perché in NP non sembra possibile risolverlo. Minco cover in CNP non sembra nemmeno possibile risolverlo e di fatto vi dico che non è possibile a meno che non c'è un collasso di P np, cosa che non ci aspettiamo avvenga. Però quello che noi notiamo è che noi siamo in grado di rispondere al problema del min cover facendo semplicemente due domande a un decisore di vertex cover. Ok? Non ne dobbiamo fare tantissime, ne dobbiamo fare semplicemente due. Ok? Quindi magari pi spazio è una classe veramente troppo grossa per questo problema. Ok? E proprio per questo noi introduciamo un modello di macchina di Touring differente che chiamiamo macchine ad oracolo. Qual è l'obiettivo del modello delle macchine ad oracolo? Il modello delle macchine d'oracolo serve a catturare questa cosa che noi che che è un fenomeno per noi molto comune che è quello di chiamare le sabride. Ok? Quindi definiamo questa macchina, adesso daremo i dettagli di come è definita l'intuizione che è una macchina di Touring che è in grado di inviare di chiedere Quiri a un oracolo che gli risponde qualcosa. Nell'esempio specifico che avevamo su noi quindi avremo una macchina di touring che fa due domande a un oracolo per vertex cover. Gli dici "Scusa, ma mi sai dire se questa qui è un'istanza?" Sì. e gli dà una risposta. Poi dice, "Guarda, te ne faccio un'altra, ma mi sai dire se questa è un'istanza sì" e gli dà una risposta. In base alle due risposte, la macchina chiamante ricevute le risposte dall'oracolo, l'oracolo è la saping sostanzialmente la macchina chiamante è in grado di rispondere sì, no? Prego. Oracolo viene considerato grande costante. Adesso definiamo tutto tutto tutto in maniera precisa. Ok? Quindi l'intuizione è questa. Introdurremo per classificare questi problemi che sono problemi che stanno un po' in mezzo fra NP e P spazio e ce ne stanno tantissimi. Un sacco di problemi di ottimizzazione hanno questa faccia un po' strana. Noi definiamo questo modello di calcolo che è il modello delle macchine di touring ad oracolo che ci serve semplicemente a mimare il fatto che una macchina di touring possa chiamare una sabrutine esterna. Ok? Allora, vediamo se c'è spazio. Sì, c'è molto spazio. Allora, le macchine ad oracolo deterministiche o non deterministiche, perché possono essere o l'una o l'altra. Hanno questa, allora lo scriviamo. Possono essere deterministiche o meno. Quindi questa nozione di macchina oracolo si applica per tutti e due i casi. Hanno una serie di orpelli, hanno, dobbiamo fare la domanda all'oracolo, quindi hanno un nastro che noi chiamiamo ora tape che è un nastro di sola scrittura in cui la macchina d'oracolo scrive la propria domanda per l'oracolo. Ok? Allora, le macchine ad oracolo in genere le denotiamo così: M è il nome della macchina e all'esponente c'è un punto interrogativo. Poi vi spiego perché lo facciamo così. Ok? Allora, che fa questa macchina? Questa macchina ha un nastro aggiuntivo, quindi avrà il suo nastro di input come al solito, i nastri di lavoro come al solito, eccetera, che sono multinastro bla. Dopodiché fra i nastri di lavoro c'è un nastro particolare che noi chiamiamo ora tape, il nastro dell'oracolo. Che ci fa con questo nastro la macchina? La macchina durante la sua computazione sul nastro dell'oracolo, sull'oracle tape, lui può scrivere delle domande, delle istanze di linguaggi. Dopodiché chiede all'oracolo, scusa, ma la cosa che ti ho scritto ora sull'oracle tape è un'istanza sì o un'istanza no del linguaggio che tu decidi? Perché l'oracolo di una macchina d'oracolo è un decisore di un linguaggio. Ok? Quindi cosa abbiamo? La macchina d'oracolo ha un nastro particolare. Ah, la macchina d'oracolo interagisce con un oracolo. Che cos'è un oracolo di una macchina d'oracolo? è un decisore di un linguaggio. Quindi il chiamante è una macchina che fa domande all'oracolo. Il chiamato, che è l'oracolo, è un decisore di linguaggi. È uno che sa dire sì no per un certo linguaggio. Cosa fa il chiamante durante la sua esecuzione? Il chiamante può scrivere sul nastro dell'oracolo, sull'oracle tape, delle domande per il chiamato e gli dice, "Guarda, ti ho scritto una stringa su questo nastro. Mi sai dire se questa stringa è un'istanza sì o un'istanza no del linguaggio che tu decidi?" E l'oracolo gli risponde, gli dice sì, no, è chiaro il senso di come funzioni la cosa più nel dettaglio, come avviene? avviene così: la macchina chiamante ha tre stati particolari: Qunto interrogativo, Q yes, Q. Allora, il chiamante fa questo, scrive sul nastro della Quiri propria domanda, dopodiché transisce nello stato Q punto interrogativo. Ok? In quel momento il chiamato, l'oracolo, decide l'appartenenza della stringa che appare in quel momento sul nastro dell'oracolo e in un solo passo della macchina chiamante avviene la transizione verso Q yes o Q. indipendenza se l'oracolo sta rispondendo di sì o di no. Chiaro? È così che avviene la comunicazione fra queste due macchine. Ci sono questi tre stati particolari. La macchina, il chiamante scrive sull'oracle tape la propria domanda. La propria domanda è un è un'istanza per il linguaggio del chiamato. Scrive l'istanza lì, dopodiché transisce in Qunto interrogativo. Il passo successivo, cioè è un passo solo, ok? Non c'è perdita di tempo, conta uno. Il passo successivo all'essere entrati nello nello stato Q punto interrogativo è una transizione magica verso Q sì o Q in dipendenza se il contenuto del nastro della domanda è un'istanza sì o un'istanza no del linguaggio dell'oracolo chiamato. È chiaro come funziona questa cosa? Quindi l'oracolo mago per dirvi sì e no in tempo velocissimo. In tempo costante. L'oracolo lo possiamo immaginare come un oracolo, un mago. Noi gli diamo la domanda, one step, abbiamo la risposta. È chiaro come funziona? Insieme a questo succede che nel momento in cui riceviamo la risposta dall'oracolo, magicamente il contenuto dell'oracle tape sparisce. Facciamo questa assunzione. Si cancella il contenuto dell'oracle tape una volta che abbiamo la risposta. Ok? Quindi non dobbiamo perdere tempo a stare là a cancellarlo. Scriviamo la domanda, facciamo la domanda, one step, riceviamo la risposta. Magicamente il contenuto e l'oracle take non c'è più. Ok? Però l'esserci mossi in cui s qiamante la risposta che gli serve. Quindi come potremmo implementare questa procedura? con una macchina ad oracolo. Allora, semplicemente la macchina ad oracolo fa questo, scrive sul nastro il proprio input GK e fa la domanda all'oracolo. L'oracolo gli dirà sì o no. Se gli dice no, fatta, cioè non c'è bisogno che vada oltre. Ok? Dopodiché che facciamo? Prendiamo dall'input cap, gli sottraiamo uno, scriviamo sul nastro dell'oracolo la coppia GK - 1. T. Di nuovo domanda. L'oracolo risponde sì. No, in base alla risposta che noi riceviamo, le combiniamo e diciamo sì, K è la taglia del vertex cover più piccolo oppure no. K non è la taglia del vertex coder più piccolo. Prego. Ma adesso magari sono preso io, ma quando abbiamo parlato tipo di linguaggi tipo HT, alt per dimostrare che erano che non erano in R, avevamo fatto delle sorte dimostrazioni così prendeva delle macchine in cui ci mettevamo denti dei piccoli e se quello rispondeva sì, allora la macchina diceva no. in diceva no, faceva una cosa. Ok, questa è un'interessantissima osservazione. Allora, in quelle dimostrazioni noi avevamo proprio il plugging di una macchina dentro l'altra, ok? Perché era qualcosa relativa semplicemente a se i linguaggi fossero decidibili o meno, quindi non andavamo molto per il sottile su quanto tempo ci serve, eccetera. Era importante che le cose funzionassero. Allora, perché lì non posso infilare nella macchina che decide Min cover non posso infilare direttamente la funzione di trans, cioè il pezzo di grafo della funzione di transizione che risolve il problema del vertex cover, perché l'oracolo può rispondere sì o no e quel pezzo di funzione in transizione è strutturato per essere una macchina NP. P, cioè ha un bias verso il yes, lo yes. Quindi se a noi serve una risposta no, io devo poter avere che la macchina, che è un'entità separata da me, mi possa rispondere sì, no? E io quella risposta me la flippo come mi serve. Ok? Questa è la ragione per cui non posso fare un plug dentro la macchina e ho bisogno del chiamato fuori. È chiaro questa cosa? Allora, guardiamo questo esempio qua. Allora, una cosa che si potrebbe fare è: "Ma perché mai se io ho una macchina di touring che è in grado di risolvere il problema del vertiscover, non ne scrivo un'altra, no? Nella quale io ci metto direttamente il codice della funzione di transizione, ok? e dopodiché eseguo l'altro pezzo facendo nuovamente la funzione di transizione della macchina che risolve per textover. La cosa non si può fare perché allora il problema è che queste macchine non esistono, quindi è tutto un rigiro un po' particolare, però se voi vi ricordate noi avevamo usato come metafora il fatto che una macchina NP cerca di accettare la propria stringa. Ok? Quindi, nel momento in cui a me serve dall'altra parte una macchina che invece cerca di rifiutare la stringa, perché è una macchina con NP, perché noi stiamo cercando di rispondere a un complemento, queste due cose assieme non ci stanno, non si possono agganciare una presso all'altra. Quindi devo chiamare, l'intuizione è devo chiamare una sabrutina esterna in maniera tale che siano liberi di darmi la risposta che vogliono. Questa è l'intuizione. Ok? In realtà c'è una c'è una ragione più profonda che è la definizione tramite certificati che non è possibile avere un certificato che è in grado di rispondere, è in grado di testimoniare il fatto che un'istanza di quel problema c'è unistanza sì. Ok? L'intuizione è che io non posso mettere appresso una macchina NP e CMP perché una tende a dire di sì, l'altra tende a dire di no. Ma questa è una metafora per ragionare. La definizione formale ci dice il problema sarebbe in NP se ci sta un certificato conciso e polinomialmente verificabile. Per quel problema non c'è e quindi non si può fare. Ok? Cioè questa è un po' l'intuizione, eh. Alright. Quindi abbiamo definito questo bla. Quindi allora noi definiamo, quindi abbiamo detto che la macchina noi la denotiamo m di punto interrogativo. Perché la chiamiamo così? Perché il funzionamento della, cioè la funzione di transizione di m è indipendente dal funzionamento dell'oraccolo. Cioè, se noi guardiamo non guardiamo, se noi guardiamo il funzionamento da Ok, qua c'è tutto, c'è tutto. Se noi guardiamo il funzionamento di quell'algoritmo, quell'algoritmo è fissato. Cioè, non è che l'algoritmo cambia se l'implementazione del checker del vertex cover è diversa. In particolare, quella funzione che noi abbiamo chiamato check vertex cover potrebbe fare completamente altro. Ok? Quindi la macchina M punto interrogativo viene denotata in questo modo per sottolineare che i miei principio noi l'oracolo da m lo possiamo cacciare e ci agganciamo a un'altra cosa. A quel punto la sua esecuzione seguirebbe la propria funzione di transizione, però la risposta che dà a quel punto dipende da come si comporta l'oracolo. Ok? Quindi noi lo scriviamo M punto interrogativo per dire che la macchina è una macchina che accetta un oracolo. Quando vogliamo dire che la macchina sta facendo domande a un oracolo per il linguaggio L, lo scriviamo in questo modo, ok? Quindi M esponente L significa che la macchina M ha come oracolo un decisore del linguaggio L. [Applauso] È chiaro? Ok. Possiamo definire quindi pagina nuova. Possiamo definire quindi facciamo questa cosa e poi pausa. Una serie di classi. Definiamo le seguenti classi ad oracolo come Sì, queste qua che adesso vediamo è sotto Mah può essere vario. Allora, sia c una classe di complessità, cioè le definizioni che abbiamo dato per l'oracolo in realtà è generica, adesso ne vediamo un po'. Quindi sia C una generica classe di complessità come quella che abbiamo visto, può essere P, np, exp, next, ppace, whatever. P^ C è l'insieme dei linguaggi L tale che L può essere deciso in tempo polinomiale da una macchina. ad oracolo deterministica che interpella un oracolo per un linguaggio. L'O appartenente a C. Ok? Allora, P^ C che cos'è? è l'insieme di tutti i linguaggi che possono essere decisi in tempo polinomiale da una macchina d'oracolo deterministica che usufruisce del counseling di un oracolo per un linguaggio L'O che sta nella classe C. Ok? È chiara la definizione? Mh mh. Similmente possiamo definire NP^ C. Secondo voi, com'è definito NP^ C? non determine. Quindi L può essere deciso in tempo polinomiale [Musica] non deterministico da una macchina [Musica] ad oracolo. che interpella un oracolo per un linguaggio L'O appartenente a C. Ok? Quindi, dato l'algoritmo che abbiamo scritto, mettiamo tutti e due così vedete entrambe. Ok? Dato l'algoritmo che abbiamo scritto prima per il problema del min cover, in che classe sta il problema del min cover? P elevato all P elevato all NP, quindi min cover appartiene a P elevato all NP perché perché è un problema che può essere deciso da un decisore deterministico in tempo polinomiale che interpella un oracolo per NP di un linguaggio che sta in NP. Ok? P^ NP è qualcosa, poi vedremo dopo la pausa che sta dentro gli spazio. Ok? Allora, facciamo prima delle considerazioni. Relazione fra NP e P^ NP. Secondo voi come sono relazionate queste due classi di complessità? Un attimo. Voci nuove. Voci nuove. È chiaro? NP è la è la classe standard che abbiamo visto per settimane. P NP è questa cosa particolare, sono quei linguaggi che possono essere decisi da oracoli determin da macchine ad oracolo deterministiche in tempo polinomiale che fanno una domanda a un oracolo in Net. Sì, prego. Sì, cioè posso chiedere all'oracolo di decidere il brech giusto da scegliere di computazione? All'oracolo si chiede la domanda che si fa all'oracolo è passo un'istanza. Questa è unistanza sì o unistanza no? E l'oracolo mi dice sì. No, questa è la domanda che facciamo allora. da dire che Ah, prego. Da dire che è vista strettamente dentro P. strettamente non lo sappiamo, però sta dentro P^ NP perché eh allora appena esattamente eh cioè vabbè l'inclusione sta dentro di PLNP per semplicemente cioè prendono anche un oracolo del ciò che c NP c Ok io ho capito però allora il nostro collega ci dice ed è corretto che NP è contenuto in P^ NP P perché sia L sia L un linguaggio appartenente ad NP. Allora, per dimostrare che L appartenga anche a P^ NP, L appartiene alla P, alla alla NP, dobbiamo trovare una macchina ad oracolo che in tempo polinomiale, utilizzando un oracolo per NP, è in grado di rispondere a L. Ok? Questa macchina M fa questa cosa molto semplice. Il suo oracolo è un oracolo per L. Prendiamo l'input, lo copiamo su un nastro d'oracolo, gli facciamo una domanda, prendiamo la risposta, rispondiamo alla stessa cosa. Ok? Quindi questa è la ragione per cui NP è contenuto in P^ NP. Ok? Eh, vediamolo ora. relazione fra CNP e P^ NP. Secondo voi P^ NP contiene CNP? Non lo contiene. CNP contiene P^ NP. Sono incomparabili. Si fa una modifica del ragionamento che abbiamo visto prima. Ok. Come facciamo? Sì, il contr per quale domanda? Abbiamo fatto l'oracle. ci risponde. Ok. Sì. Allora, sia L un linguaggio appartenente a CNP. Ne esegue che L soprassegnato appartiene a NP. La macchina M fa questo. Noi gli diamo come ora L soprasegnato. La macchina M che fa? Fa la domanda all'oraccolo. L'oracolo risponde, la macchina M inverte la risposta e restituisce il risultato. Ok? Quindi noi abbiamo che co NP è un sottinsieme di P^ NP. Quindi che cosa abbiamo? E con questo poi facciamo pausa. Abbiamo P qua, NP sta qui, CNP sta qui e P^ NP sta qui. Ok, giusto un inciso prima di andare in pausa. In realtà il problema min cover non è un problema difficile per P^ NP. L'intuizione è questa. In P^ NP noi possiamo fare quante domande all'oracolo? Eh, ma ne possiamo fare un numero esponenziale? No, perché non abbiamo tempo. Quindi le macchine polinomiale con oracoli in NP, l'intuizione è possono fare un numero polinomiale di domande all'oracolo. Per risolvere in cover, quante domande abbiamo fatto all'oracolo? Costante due. Quindi l'intuizione è che quel problema in realtà non è uno dei problemi tosti di P all NP. Sta in via alla NP, però in realtà sta in un pezzettino molto piccolo che però è un dettaglio che non vediamo. Ok. Pausa. 10 minuti. Un quarto d'ora. [Musica] Ok, continuiamo a esplorare le classi ad oracolo. Ne vedremo ancora un po', daremo qualche intuizione, poi vedremo classi funzionali, problemi di ottimizzazione, eccetera. Allora, noi abbiamo introdotto prima le classi P^ NP, NP^ NP. Vabbò, lo vedete? Questa cosa può essere generalizzata e avere cose ancora più sofisticate. Per esempio, potremmo avere NP^ NP^ NP. Ok? Che cos'è questo? Questo sarebbe una macchina NP che ha come oracolo linguaggi in NP NP. Ok? Cioè la definizione è questa qua. Quindi noi possiamo fare delle catene molto lunghe, no, di tanti oracoli, però in genere il significato è in questo caso che la macchina NP, il chiamate ha come linguaggio dell'oracolo un linguaggio che sta in NP^ NP. Ok? Questa cosa si può generalizzare, avere 3 4 5 1000 livelli, eccetera. e dà origine a quella che viene chiamata la gerarchia polinomiale. Prima anche allincito, no? All'infinito no. E se ha un numero molto facile sempre cosa? Qual è il testimo di compulenza? Può può è unbounded può essere un qualsiasi numero finito. 3000 3000 un miliardo un miliardo. Se sta sotto sempre esponenziali costruire sta pire sopra cosa poi poi poi vediamo. Sì, quindi possiamo avere NP^ NP NP^ NP^ NP. Possiamo avere quanti ne vogliamo là, basta che sia un numero finito. Ok? Questo ci permette di definire quella che viene chiamata la gerarchia polinomiale. Ok? Ci sono tanti problemi interessanti nella gela vecchia polinomiale. Noi ve ne citerò qualcuno alla fine, non li vedremo nei dettagli perché, insomma, è eh un po' un po' tricky. Ci sono alcuni problemi un po' artificiosi, problemi abbastanza naturali e ne vedremo qualcuno. Come è definita la gerarchia polinomiale? La gerarchia polinomiale è, come dice il nome, un insieme di classi che stanno una sopra l'altra, ok? E le classi della gerarchia polinomiale si chiamano sigma pi, pi e delta pi con i mag> uguale 0. Adesso le definiamo. Quindi cos'è la gerarchia polinomiale? La gerarchia polinomiale è una gerarchia di classi di complessità al di sopra di NP che hanno questi nomi qua sigma piσ pi e delta pi dove i è maggiore o uguale a 0. La definizione è di queste classi è questa qui, sigma p0 e p. Ok? E quindi noi diciamo alla base c'è questa classe che chiamiamo sigma p0 che equivale alla classe p time deterministic polynomial time. Dopodiché per i mag> o uguale 1 definiamo sigma pi come np^ sigma pi - 1 è una definizione. Quindi che cosa avremo? Sigma p2 è uguale a np^ np. Sigma P3 è NP^ NP^ NP. Sigma P4 è NP^ NP^ NP^ NP e così via. Ok? Quindi noi definiamo sigma P come NP a eh una macchina non deterministic polynomial time che chiede ad oracoli in sigma pi - 1 di rispondere ad alcune domande. Ok? per i mag o ug di pi pi pi i è cosma pi, quindi pi i è l'insieme dei linguaggi complementi di quelli che stanno in sigma pi. Quindi abbiamo pi pebbe il complemento di sigma P2. P3 che è il complemento di sigma P3, π pemento di sigma P4 e così via. E poi definiamo delta di pi + 1 come piang come delta delta delta p = p^ sigma pi i + 1. Sì, sì, sì. Ok? Quindi queste sono definizioni di classi e la gerarchia è stata definita così. Quindi delta P2, che cos'è delta P2? Pla, delta P è Pla [Musica] alla NP perché per essere questo 2 qua lì sarebbe 1 e quindi avremmo p^ sigma p + 1 sigma P1 è NP. Ah, ok. Sigma P1 è NP perché avrei NP alla sigma P0 dove sigma P0 è P. NP^ P è NP. Perché se NP fa domanda un oracolo in P sono cose che in realtà saprbbe fare da solo, cioè non ha bisogno di un oracolo in P. Ok? Quindi delta P2 è P^ NP. Di conseguenza noi avremo ad esempio che e dai mean cover appartiene a delta P2 che è il problema che abbiamo visto prima. Adesso quello che noi vogliamo fare è guardare un po' di relazioni fra queste classi della gerarchia, ok? chi contiene cosa e come sono relazionate. Ok? Allora, guardiamo prima questo. Consideriamo un generico sigma pi e un generico delta pi La definizione sta qua. Ok? Le vedete? Le vedete? M mh mh. Ok. Che relazione c'è fra sigma pi e delta di pi i + 1? Innanzitutto delta di pi + 1 a che cosa è uguale? P^ sigma P^ sigma Pi. Ok? Allora, che relazione c'è fra sigma pi e delta di pi + 1 dove sappiamo essere p^ sigma p? Sì, sigma contenuto perché sigma p è contenuto in delta pi + 1 perché appartiene al sigma poo. Esattamente. È la stessa ragione per cui abbiamo detto che questo è simile a NP contenuto in P^ NP. L'abbiamo visto prima. Noi basta che usiamo un oracolo o una macchina d'oracolo che non fa nient'altro che chiedere al proprio oracolo di decidere il linguaggio in sigma. Qui prende la risposta e la diamo in output. Ok? Una domanda. Perché scriviamo i delta più invece che delta p e poi siamo del pi? Stessa cosa come uno vuole definirla. L'importante è che la relazione venga dentro. Ok? Le delta sì hanno un indice aggiuntivo rispetto alle sigma. Così vanno chiamate, eh, così ci atteniamo. Ok? Alri. Cosa possiamo dire di pi e delta pi + 1? In cui questo è pi? Un attimo, un attimo. Vi ricordo che questa cosa qua è uguale a co sigma pi, ok? Sì, prego. Sempre P è contenuto in delta. P Sì, è contenuto in delta perché eh per lo stesso motivo, perché bastava infirare il Sì, per la stesso ragionamento che abbiamo fatto prima per dire che co NP sta dentro pi np. Per un ragionamento molto simile possiamo dire che pi sta dentro delta pi + 1. Qua lo mettiamo simile a co NP incluso in p^ np. Ok? Altro? Cosa possiamo dire di delta pi e sigma pi? Dove questo è? No, pensateci voi. Allora, che cos'è delta pi? Che cos'è sigma pi? Qualche idea? Yes. E anche in questo caso delta è incluso perché sto considerando una classe deterministica. Ah ah invece che non deterministica. Sì. Delta P com'è definito? Eh, come p elevato all sigma di P - 1. Sì. E invece sigma P è eh NP elevato Sì. alla sigma. Sì, questa è la ragione. Noi abbiamo che delta P è contenuto in sigma pchui oracolo è sigma pi i - 1, però delta di pi il chiamante è deterministico, in sigma di piamante è non deterministico, quindi è più potente e perciò avremo questa inclusione. delta di pi è contenuto in sigma pi. Cosa possiamo dire di delta pi e pi? Questa cosa è un po' più complicata e ve la guido io, però nulla di trascendente. Quindi abbiamo delta pi e pi, ok? sia L un linguaggio appartenente a delta pi che è uguale pi Allora, che cosa cosa sappiamo se L è un linguaggio che appartiene a quella classe? Sappiamo che esiste una macchina M adoracolo deterministica che lavora in tempo polinomiale che facendo domande ad un oracolo per un linguaggio L in sigma pi - 1 è in grado di decidere L. [Applauso] È chiaro? Ma questa macchina M è deterministica, cioè il chiamante dell'oracolo è una macchina deterministica. Quello che noi possiamo fare di questa M punto interrogativo è trasformarla e scambiare gli stati di accettazione e di reject. Quindi se noi prendiamo questa macchina, chiamiamola M soprasegnato, che è la stessa di M, però i suoi stati di accettazione e reject sono swoppati, per il resto è uguale e chiama lo stesso oracolo della macchina M, andrà a decidere che cosa andrà a decidere L soprasegnata. Allora, avremo che L soprasegnato, notate che la macchina M è ancora una macchina deterministica polynomial time, perché siamo partiti da qui, abbiamo semplicemente invertito gli stati di accettazione e rifiuto. Ok? Quindi da questo, per il fatto che m soprasegnato con l'opportuno oracolo in sigma pi -1 è in grado di riconoscere L soprassegnato, abbiamo che L soprassegnato anch'esso appartiene a P sig P - 1 che è uguale a P. per il risultato di prima, che è questo, avremo che cosa? che questo è un sottoinsieme di sigma pi, quindi l soprasegnato appartiene a sigma pi da cui l appartiene al complemento di questo qui che è pi. Quindi cosa abbiamo? che se un linguaggio L appartiene a delta pi, lo stesso linguaggio L appartiene anche a pi, da cui abbiamo questa relazione di contenimento. Delta P è contenuto in pi p. Abbiamo fatto tutto sto gran casino per adesso fare un disegnino di come sono relazionate queste classi, ok? Posso andare avanti? Alri, pagina nuova. Come sono strutturate le cose? Qua c'abbiamo P. Ok. Allora, noi abbiamo NP, sta qui, NP è anche sigma +1 che è uguale a sigma +1. Qua c'è con NP che è uguale a pi P1. Al di sopra ci sta delta P2. Al di sopra ci sta sigma P2. Da quest'altro lato c'è pi P2. Al di sopra di tutto c'è delta P3. Dopodiché che ci sta? Ehi, sigma P3. Questo è sigma P3. Al di sopra di questo ci sta p a salire. Ok? Quindi queste sono le relazioni della classe della gerarchia polinomiale. Ok? Se lo vogliamo scrivere in una maniera un pelino più comprensibile, noi avremo che P è contenuto in NP e in coi due sono contenuti in delta P2. Questo è contenuto in piσ. Questi due sono contenuti in delta P3. Delta P3 è contenuto in pi, questi due sono contenuti in delta P4 e così via. Cioè, quella è la relazione di contenimento fra le classi, ok? Bla bla bla bla. Quante ce ne stanno? Ce ne stanno infinite. Dove si colloca? Delta P 0. Sono pien tutto pieno. Quale chiamiamo? Ok, questo è sigma +1, questo è pielta p0 che è uguale a p1 che è uguale a sigma p0 che è uguale a sigma a pi0. Va bene? Quindi cosa abbiamo? Abbiamo tutte queste stratificazioni di classi a pressa all'altra eccetera. Ok? Come vedete l'inclusione è questa. P sta dentro con NP ed NP. NP e con NP stanno dentro delta P2. Delta P2 sta dentro π P2 sigma P2. Pi P2 sigma P2 stanno dentro delta P3. Delta P3 sta dentro questa e quest'altra e così va. E si va avanti. Papà papà papà. Quanti livelli ci sono di questa gerarchia? sono infiniti, cioè ce ne stanno tantissimi, però sono infiniti. Infatti uno dei problemi aperti tra gli innumerevoli problemi aperti è stabilire se il numero di livelli della gerarchia polinomiale sia finito o infinito. Quello che riteniamo è che siano infiniti, nessuno è mai riuscito a dimostrarlo, eccetera. Che cosa ci sta qua sopra? Qua sopra ci sta pi spazio. Quindi questa gerarchia sono un insieme di livelli che stanno a metà strada fra NP e P spazio e la riempono. È proprio fitta, è tutto pieno là. Ok? fino a pi spazio. Non dimostriamo che dentro più pi spazio, prendetela per buono. Eh, questa gerarchia sta dentro più spazio. Cosa abbiamo sopra più spazio? Abbiamo expime. Al di sopra c'è next time. Ok. E dove sta R? R che è l'insieme dei linguaggi e sta sopra tutto. Ok? Anche sopra Exp, Nexp ci stanno altre gerarchie, non vediamo niente di tutto ciò. Sappiate che è pieno di classi fino ad arrivare a a R, che è l'insieme dei linguaggi decidibili. Ok, adesso queste sembrano tutte classi un po' strane e di fatto sono delle classi un po' strane. Cerchiamo di dare un'intuizione su quali problemi stanno là dentro. Allora, noi abbiamo visto il problema SAT. Il problema SAT, ve lo ricordate? Il problema SAT è il problema di dato una funzione una formula buleana stabilire se sia soddisfacbile o meno. Come la possiamo scrivere quel tipo di problema? può essere scritto così che esiste. È vero che esiste un assegnamento per le variabili X dove X bar è un insieme di variabili buleane X1, X2, X3, X4. Dice, è vero che esiste un modo di assegnare un valore di verità alle variabili buleane in x tale che la formula fai di x è vera. Questo è è lo standard problema sat. Ok? Non avevamo quel segno di esiste prima perché lo dicevamo a parole, dicevamo è vero che esiste un assegnamento di verità alle variabili buuleane che rendono la formula vera. Ok? Noi lo possiamo scrivere pure con un quantificatore e quindi dire ok, sostanzialmente il problema SAT standard è presa una formula quantificata in quel modo in cui c'è un esistenziale all'inizio e poi il resto della formula non quantificata, dobbiamo stabilire se quella formula sia vera o meno. Cioè ci chiediamo, esiste un modo di assegnare eh delle variabili dei valori buliani alle variabili X tale che e quindi la formula è verificata, per esempio, potremmo avere esiste x1, x2, x3 tale che ad esempio x1 or x2 and x3 implica not e or bla bla. bla bla. Ok, la formula F può essere qualsiasi in questo caso. Ok, questo è lo è il SAT standard. Ci siete? Allora, noi possiamo generalizzarla e per questa ragione lo chiamiamo esiste sat. Ok? Lo possiamo generalizzare a questa cosa qua. Guardate, considerate questa formula. esiste x1 e x2 tale che per ogni y1 y2 y3 abbiamo che x1 or not y1 or x2 and not y1 or not x2 Y3 e così via. Allora, che ci dice questa formula buleana? È una formula buleana un po' più sofisticata e il significato di questa formula è questo. Ci chiediamo se esista un valore, cioè un assegnamento di verità per le variabili x1 x2. tale che qualsiasi sia l'assegnamento di verità che diamo alle variabili y1, y2, y3, la formula è soddisfatta. Ok? Quindi questa è una formula un po' più complicata in cui abbiamo due gruppi di variabili. Abbiamo delle variabili che le chiamiamo x bla, delle variabili che chiamiamo y bla. La domanda è: è vero che esiste un modo di assegnare? valori buleani alle variabili X tale per cui qualsiasi cosa facciamo sulle variabili Y la formula è soddisfatta. È chiaro? Questo è un problema di soddisfacilità diverso e lo chiamiamo esiste per ogni SAT. Bene, noi possiamo si può mostrare, non lo vediamo, che questo è un problema sigma P2 completo, cioè è un problema tosto della classe sigma P2. Similmente possiamo definire esiste per ogni esiste sat e questo qua è sigma P3 completo. Ok? Quindi questi sono un po' di problemi tosti di questa di questa gerarchia, no? Più nel dettaglio di questo non andremo. Vi faccio notare che questo è meno alieno di quanto possa sembrare. È vero che esiste una mossa, consideriamo gli scacchi, è vero che esiste una mossa che io posso fare tale per cui qualsiasi sia la risposta del mio avversario esiste una risposta mia. Tale che qualsiasi cosa faccio il mio avversario esiste una risposta mia tale che bla bla bla bla e alla fine vinco. Questi sono i problemi di questa gerarchia, ok? C'è un'alternanza di giocatori in cui esiste una strategia vincente per me tale che qualsiasi cosa faccio l'altro ho sempre il modo di vincere. Questa cosa ovviamente va avanti all'infinito perché dipende da quanto si va avanti. Ok? Quindi, giusto per avere un'intuizione, questo problema stranissimo delle formule puleane quantificate in realtà, per esempio, è la complessità dei giochi. I giochi hanno quel tipo di complessità perché io mi chiedo se io ho un opponent intelligente, non uno che la butta a casa, no, esiste una strategia per me, una mossa che io posso fare ora, che qualsiasi cosa faccia l'altro, per me esiste un modo bla bla bla bla e alla fine vinco. Ok, questi sono è la complessità di questo genere di problemi. È chiaro? Ok, in questi ultimi minuti introduciamo l'ultimo concetto che sono problemi di ottimizzazione e classifale che sono legate agli oracoli. Ok, definiamo questo problema functional mean cover. che è molto simile a quello che abbiamo visto, però è un problema di funzione. F min cover che sta per functional mean cover. Dato un grafo G, noi in output vogliamo il minimo valore di un set V tale che V è un vertex cover. Ok? Quindi, dato un grafo G, noi vogliamo calcolare la taglia. In questo caso, attenzione, siamo su un problema completamente diverso. È il primo problema di calcolo che stiamo vedendo in questo corso. Dato un grafo, noi non vogliamo sapere se abbia un vertex cover o meno, noi vogliamo sapere la taglia del più piccolo vertex cover, ok? Quindi questa ha proprio un flavor completamente differente questa cosa qua. Ok? Alrght. Definiamo fpunal deterministic polynomial. è la classe delle funzioni calcolate da trasduttori deterministici in tempo. polinomiale. Ok? Quindi abbiamo questa definizione di classe funzionale e l'insieme delle funzioni che possono essere calcolate da trasduttori. Vi ricordo che il trasduttore è una macchina di touring che sputa fuori un output, ok? Che ha un nastro di output eccetera. Quindi FP è la classe cugina di P. P è l'insieme dei problemi di decisione decidibili da macchine di Touring deterministiche in tempo polinomiale. Il suo cugino FP functional deterministic polynomial time è l'insieme delle funzioni che possono essere calcolate da trasduttori deterministici in tempo polinomiale. Vi faccio notare quindi che le riduzioni polinomiali sono funzioni che stanno in FP. Ok? FNP sarebbe quello legato a NP. Non la vediamo perché è un macello. Ok? Quindi ci focalizziamo su FP che è facile e bella lineare. FP cos'è? È l'insieme delle funzioni che possono essere calcolate da trasduttori deterministici in tempo polinomiali. In soldoni sono quelle funzioni per i quali abbiamo algoritmi deterministici che le che le calcolano. Ok? Tutto qua. Ok. Supponiamo, ragioniamo assieme. Supponiamo che vogliamo risolvere questo problema qui e abbiamo a nostra disposizione un oracolo per il problema vertex cover decisionale. Ok? Quindi abbiamo una bella procedura in una in una libreria che date una coppia grafo numero è in grado di dirci se quel grafo ha un vertex cover di taglia al più quel numero. Ok? Quindi abbiamo una libreria che è in grado di fare questo. Noi vogliamo adesso risolvere il problema di calcolare dato un grafo, la taglia del eh del verte cover. minimo di quel grafo. Ok? Se sappiamo che abbiamo la libreria che ci risolve il problema di decisione, che algoritmo ci possiamo inventare per riuscire a calcolare il perfect cover di taglia minima? Un attimo, un attimo, diamo un po' di tempo alle persone per pensare. M Ce l'abbiamo il tempo? Sì. [Musica] Ok. Vi ho visto, vi ho visto. Cerco voci nuove. Tutto qua. Però un pochino prendiamo di tempo per pensare, così un po' ci pensano tutti. So che non me ne frega assolutamente niente. Vi ripeto lo scenario. Abbiamo una funzione che è in grado di risolverci. Abbiamo una procedura che è in grado di risolverci il problema decisionale del vertex cover. Come usiamo questa sabrutine per calcolare la taglia del vertex cover minimo di un grafico? Visto anche tre voci nuove? Ok, lei è il primo. Prego. E passiamo a chi è che decide il decide il problema. Lauder, quale problema? L'oraccolo. Attenzione, la macchina che decide quale problema. decisionale di GK. Ok, quindi il vertex cover decisionale. Ok, come facci date un grafo, come facciamo a calcolare la taglia del vertex cover minimo di quel grafo? Passiamo ogni K partire da K 1 numeri naturali. Sì, primo per l'Oracolo che siisce è Sì. Ok? Questo è un modo, ve lo ripeto se non avete sentito, questo è un modo abbastanza semplice. Se noi abbiamo un decisore del di vertex cover decisionale, vi ripeto che vertex cover decisionale è dato un grafo, è un numero, è vero, no che questo grafo ha un vertex cover di taglia al QK? Ok? Questa la usiamo come sabrutin per calcolare la taglia del vertex cover di taglia minimale di grafico. Come facciamo? Il nostro collega ci suggerisce iniziamo da k = 1 e iniziamo a chiedere all'oracolo. È vero che questo grafo ha un vertex cover di taglia uno? Che no. Ok, andiamo avanti di nuovo. Aumentiamo, passiamo a due. Ora, è vero, no, che questo grafo ha un vertex cover di taglia duo. Ok, andiamo avanti. 3 e 4 e 5 e 6 bla. Al primo che ci dice sì, ci fermiamo e restituiamo il K che eravamo arrivati fino a quel momento. Ok, questa procedura funziona. Funziona. Vedrete sugli appunti di Calaouti che lui va all'inverso, va dal più grande al più picco, è la stessa cosa, funziona. Ok, quindi una prima procedura che abbiamo in mente è questa cosa qua. sfruttiamo il decisore, quindi il nostro oracolo sta in NP perché risolve un problema di decisione e il trasduttore usa l'oracolo in questo modo: G1, G2, G3. Ok? Alla prima risposta sì dell'oracolo ci fermiamo e restutiamo la nostra risposta. Ok? Per questa ragione noi diciamo possiamo dire che cosa? che functional mean min cover appartiene a cosa? Adp alla np. Perché scriviamo questo? Perché un trasduttore deterministico in tempo polinomiale è in grado di calcolare il risultato se nella sua esecuzione chiede l'aiuto di un oracolo in NP e quindi lo scriviamo FP^ NP. Chiaro per tutti? Perché prende tempo polinomiale? Perché noi andiamo ciclando su tutti K. Passiamo 1 2 3 4. Male che va. Noi dobbiamo ciclare dove? Fino al limite del numero dei nodi. Perché al numero dei nodi riceveremo sicuramente risposta sì dall'oracolo, ok? Perché il verte cover di tutti i nodi è un vertex cover trivial. Ok? Quindi noi ci prendiamo tempo polinomiale perché facciamo quante male che ci va un numero di domande all'oracolo pari al numero di nodi del grafico perché i nodi sono esplicitamente rappresentati nell'input. Quello è un numero polinomiale di chiamate. Queste sono una cosa faremo la differenza al prossimo giro. Numeri cose bla. Oggi ci manteniamo sul semplice. Ok? Quindi andiamo e facciamo il test. Vertex cover taglia 1. Sì. No, vertex cover taglia 2. Sì, no, bla bla. C'è una procedura più efficiente di questa. Quale può essere? Prego. Possiamo fare la ricerca binari. Ok? Quindi la lo stesso oracolo, prendiamo la taglia del numero dei nodi n e iniziamo n/2 e chiediamo al nostro oracolo. È vero, no, che ci sta un vertex cover di taglial + n/2. Se quello ci dice sì, allora vuol dire che il minimo sta fra 0 ed n/2. Se quello ci dice no, vuol dire che il minimo sta fra n mezzi ed n. E ripetiamo, becchiamo a metà e facciamo di nuovo la stessa cosa. È chiara questa procedura? L'avevate vista tut informatici sicuro la ricerca binaria l'amista. I matematici pure, no? Ok. Quindi pa, becchiamo a metà e tagliamo di volta in volta. Quante domande facciamo all'oracolo? un numero logaritmico. Ok? Quindi questa procedura da un certo punto di vista è più efficiente perché il chiamante fa un numero logaritmico di domande. Ok? Come lo scriviamo questo? Siccome quindi esiste quest'altra procedura che è in grado di risolvere e functional mean cover e facciamo però meno domande all'oracolo, noi lo scriviamo così. F min cover appartiene a fp np e tra parentesi quadra o di log n che serve a dire che il numero di chiamate che noi facciamo all'oracolo è un numero limitato, è un numero logaritmico. Ok? Quindi la classe di functional mean cover è questa qui che è più piccolina. domanda per voi e con questo poi chiudiamo. A questo punto siamo in grado di stabilire la relazione che abbiamo detto proprio all'inizio del corso. All'inizio del corso abbiamo detto ci focalizziamo sui problemi di decisione perché i problemi di decisione sono più facili ma sono legati ai problemi di ottimizzazione e di ricerca. Ok? secondo noi. E qui a questo punto ora che abbiamo le definizioni FT bla, lo possiamo vedere in maniera più formale. Secondo voi functional mean cover, quindi calcolare la taglia del vertex cover minimo di un grafo G può stare in FP? Chiara la domanda? Adesso abbiamo visto che c'abbiamo delle procedure che tramite oracolo collochiamo questo problema in FP NP o NP^ o log n indipendenza se siamo furbi e gli facciamo una ricerca binari. Ma la domanda ora è, ma il calcolo della taglia del verte cover minimo di un grafo sta in FP? Può stare in FP? Prego. Direi di no Lauder direi di no perché perché si basa sulla funzione dello stato che noi possiamo sapere il tempo, cioè possiamo sapere la la taglia del minimo del scopo. Mh. Ma questo in realtà non è una cosa in tempo costante. No, no, non in tempo costante. Io mi chiedo, il calcolo della taglia del vertex cover minimo si può fare in tempo polinomiale? Cioè se F min cover appartiene a FP significa? Significherebbe che esisterebbe un algoritmo deterministico che in tempo polinomiale è in grado di calcolare la taglia del vertex cover minimo di un grafo. Questa cosa si può fare in tempo polinomiale o no? Secondo voi vi do un quindi cosa accadrebbe se fosse in grado? Prego. Potremmo abbassare la utilizzando cover. Sì. E quindi se fossimo in grado saremmo in grado di abbassare la complessità di min cover e saremmo in grado di abbassare la complessità di di di vertex cover. Se noi fossimo in grado di calcolare in tempo polinomiale deterministico la taglia del vertex cover minimo di un grafo, il problema del verte cover decisionale, quello sarebbe in P perché che faremmo? Calcoleremmo la taglia minima, lo confrontiamo col K che ci hanno passato in input, vediamo qui è più grande, rispondiamo si no. Ma ma noi sappiamo che il verte cover è NP completo e P sarebbe uguale a NP. Quindi calcolare la taglia minima del vertex cover di un grafo, riteniamo non sia possibile farlo in tempo polinomiale perché perché collasserebbe n P su P. Quindi il fatto che noi sappiamo che vertex cover, la versione decisionale, è un problema NP completo, ci dà un bound stretto, forte su qual è la complessità del calcolo. E qui ritorna l'osservazione che avevamo fatto, cioè il problema di calcolo e il problema di decisione sono legate perché se noi fossimo in grado di calcolare in tempo polinomiale anche il problema di decisione di decisione sarebbe deterministic polynomial e a quel punto avremmo che cosa? NP = P. Ma noi non riteniamo che questa cosa possa essere possibile. Ecco dov'è il link ora è esplicito tra problemi di ricerca, ottimizzazione e le loro varianti di decisione. Se un problema di decisione è tosto, la sua variante di calcolo non può essere semplice, senò P ed sarebbero uguali. Ok? E con questo possiamo chiudere per oggi. Grazie mille. All [Musica]