No, perché non va? Scusa. Ok, oggi vedremo vedremo vedremo un altro problema NP completo, così ne vediamo un bel po'. Ehm e poi una definizione della classe NP che è quella che più recentemente in genere si fa riferimento a cui si fa riferimento più recentemente. Eh, ok. Come sono and come'è andata la lezione di venerdì? È entrata in testa. Era difficile, facile. Intensa, eh. Ok, ok. era un po' intensa. Ok, il mio suggerimento di nuovo per quella lezione è riguardatevi il video perché, insomma, ci sono un po' le dimestrazioni da stare appresso, eh, perché lì si deve un attimo capire riduzioni eccetera. Oggi vedremo un'altra riduzione tra le varie cose, cioè vedremo riduzioni fino alla fine, purtroppo per voi. Quindi ve l'avevo detto che era un concetto che andava andava digerito per bene. Eh sì, avrei una domanda. Certo. Sì. E c'è una struttura generale da seguire quando siano queste dimostrazioni che abbiamo fatto prima scorso, nel senso io devo dimostrare che vabbè NP eh a parte NP logicamente ci sarà in maniera triviale poi NP no sempre dipende dal problema quelli che vedremo qua è super semplice ma c'è un problema adesso, per esempio, sappiamo che primes test di primalità è polinomiale Non ci sono arrivati novedità che 2003 2002-2003 il lavoro che dice che mostra che primes è eh in P. Ok. Ovviamente Primes è ok, ancora non l'abbiamo fatto quella classe, però il risultato precedente degli anni 70 era che Primes fosse in NP e non era così scontato, cioè il modo per dimostrare che è NP è primo un numero si devono fissare un sacco di cose, non è Quindi quelli che vediamo noi sì sono semplici, ma non è non è detto. Va bene, per fortuna. Sì. Quindi, passando a NTD, la dimostrazione. Sì. Ehm, cioè generalmente noi diciamo eh facciamo una dimostrazione come se fosse un sotto insieme, quindi da una parte e poi dall'altra, cioè noi abbiamo la tesi, no? Allora, allora, la questione è questa, non è che è come se fosse un sottoinsieme. Quando noi mostriamo una riduzione, noi dobbiamo mostrare che esiste un algoritmo che trasforma istanze s di un problema in istanze s di un altro problema. Supponiamo di ridurre A a B. Quando mostriamo una riduzione da A, poi noi dobbiamo dimostrare che cosa? che quella riduzione, che è un algoritmo di trasformazione prende le istanze S di A e le trasforma in istanze S di B. Prende istanze no di A e le trasforma in istanze n B. Cioè sono questi due pezzi che la dimostrazione mostra. Ci fa vedere, guarda che questo algoritmo non è che fa le cose a Muzzo, prende sì, arriva sì, prende no, arriva a no. oppure equivalentemente, come spesso abbiamo visto, è che se siamo arrivati a sì era perché partivamo da sì, quindi non succede mai che partendo da un'istanza no, l'algoritmo vi produce un'istanza sì. Quindi sicuramente due versi sono sono per mostrare che le stanze sì del problema A sono mappate su istanze sì del problema B e le istanze no del problema A sono mappate su stanze no del problema B. Questi sono i due versi della dimostrazione. Eh, non è una questione di contenimento di insiemi, come abbiamo visto in altre circostanze. E questa cosa qua dobbiamo dimostrare perché se vi ricordate la definizione di riduzione noi abbiamo che F è una riduzione dal problema Ama B. Se date una stringa w appartiene ad A, se è solo se f appartiene a B. È quel se è solo se che noi dimostriamo in due direzioni. È lì inipo, c'è una doppia implicazione logica ed è per quello abbiamo necessità di fare una dimostrazione nei due versi. Una l'unica domanda poi la faccio cominciare tranquillo. E certe volte mi sembra nel problemo del verted cover comunque sembra che quello precedente. Arriviamo a un punto in cui nella dimostrazione noi abbiamo ottenuti dei risultati e poi ci poniamo la domanda o è suff sufficientemente grande tipo del vertice cover oppure è soddisfacbile ciò che abbiamo dimostrato. Ok? Dipende dipendea su quali problemi stiamo lavorando. Cioè se io devo mostrare che ne so, che arrivo o stavo partendo da un'istanza sì di una formula buleana, allora le istanze sì di formule buleane sono formule soddisfacbili perché noi dobbiamo mappare sostanzialmente istanze sì del problema A in istanze sì del problema B e istanze no del problema A in istanze no del problema B. Se il problema a parla di formule buuleane, le stanze sì sono formule soddisfacbili e le stanze no sono formule insoddisfacbili. Se il problema è qualcos'altro è tipo un indipendent set, le stanze sì ci saranno grafichi con independent set grossi e le stanze no grafiche che non hanno indipendent set grossi, ma dipende sempre dal problema. L'altro potrebbe essere vertex cover. Le stanze sì sono grafi con vertex cover piccoli. Le stanze no sono grafi che non hanno vertex cover piccoli. Cioè se io vado alla ricerca di un set di insiemi o vado alla ricerca di una soddisfacilità di formula, dipende sempre su quale problema io sto ragionando. Se io devo mostrare che un'istanza sì sia una formula soddisfacibile, devo mostrare che un'istanza sì è un grafo con una certa proprietà. Oggi lo rivedremo di nuovo, penso dopo la pausa. Vi faccio un'altra riduzione in cui stavolta avremo una formula e un grafo, quindi andremo da una formula con una certa proprietà a un grafo con una certa proprietà. Una domanda stupida. Come faccio a capire eh quali sono appunto queste tipo di domande adattate al problema specifico a priori? Cioè se io riduco un problema ad un altro Sì. Ed è un problema specifico che non ho mai incontrato. Come faccio a capire che devo utilizzare una specifica domanda per capire se i risultati che ho dimostrato sono effettivamente corretti? Allora, la questione è che la domanda che si deve porre è questo. Se io parto da un'istanza del problema di partenza, e questo è un un auditivo digitale, cioè mi faccio la domanda dentro ed è sufficientemente generico da poter essere adattato a qualsiasi cosa. Se io parto da un'istanza sì del problema di partenza e a quel punto lo devo sapere io che cos'è un'istanza sì, posso essere certo che ho costru che la mia riduzione costruisca un'istanza sì del problema di arrivo e l'istanza sì del problema di arrivo dipende dal problema di arrivo. Ecco perché quando pensate alle riduzioni dovete fare quello che insomma quello che vi ho suggerito che io in genere faccio. Mi scrivo da un lato qual è il problema di partenza, dall'altro qual è il problema di arrivo, poi mi chiedo che cos'è un istanza del problema di partenza, che cos'è unistanza del problema di arrivo e poi mi chiedo che cos'è un'istanza sì del problema di partenza, che cos'è un'istanza sì del problema di arrivo, che cos'è un'istanza no del problema di partenza? Che cos'è un'istanza, no, del problema di arrivo. Una volta che c'ho questa descrizione esplicita, io a volte sui problemi più sofisticati, quando devo fare riduzioni più intricate, cioè io me lo scrivo a parole, stanza, sì, esiste, bla bla bla. Per esempio, no, io quando ho iniziato la mia carriera lavoravo su teoria dei giochi. Le istanze, sì, di quei problemi erano giochi nelle quali c'erano strategie vincenti o cose del genere e quindi che cos'era una stanza? Sì, un modo di distribuire la ricchezza fra i giocatori tale che bla cè. Quindi erano cose un po' distante dalla formula buleana di partenza e per essere sicuro di non perdermene per strada io me le scrivevo. Cioè questo è quello che vi suggerisco. Scrivete la cosa perché quando la vedete scritta è più semplice. Grazie. Nulla. Allora, allora come procediamo? Procediamo così. Quindi, vediamo prima una definizione differente della classe NP, poi vediamo un altro un altro problema NP completo che probabilmente già conoscete. Sì, l'abbiamo visto e oggi dimostriamo che è NP completo. Alrght, so definizione di classe NP. Da quello che abbiamo visto dagli esercizi fatti la volta scorsa, come diceva il nostro collega, non era molto difficile dimostrare che un certo problema fosse in NP. Sostanzialmente che facevamo? Dato unistanza per rispondere sìamente. Sì. E poiamo che c'era assolutamente Sì, sì, sì, sì, sì. Cioè quello che noi facciamo in genere per i problemi NP è un gess polinomiale, perché ovviamente la macchina non è che può perdere tempo, la macchina deve lavorare in tempo polinomiale, quindi non è che possiamo gessare il mondo, possiamo ghessare un una cosa piccolina, una cosa che è polinomialmente più grossa dell'input. In genere finora abbiamo visto dei guess che erano più piccoli dell'input, ma in linea di principio possiamo guessare cose più grandi dell'input, l'importante è che sia polinomiale, ok? Dopodiché c'è un check, anche questo fattibile in tempo polinomiale, tale per cui poi siamo in grado di rispondere sì. Un risultato interessante che però non vedremo è che si può dimostrare che questo check in realtà può essere molto più semplice di polinomiale. È una cosa che si può descrivere in logica del primo ordine, insomma, il test che si fa dopo è una cosa estremamente semplice, un risultato carino, però troppo intricato, non lo vedremo. Ehm, quindi, cioè, quello che possiamo pensare è che praticamente tutti sti problemi in NP noi li abbiamo sempre risolti allo stesso modo. am qualcosa, cerchiamo quel qualcosa, ok? E tutto ciò deve essere fatto in terminoniale. Però ve la ricordate la definizione che noi abbiamo usato della classe NP? NP. Eh, la scrivo io time. Eh, no. l'unione yes yes yes è l'unione su c magiore 1 di n time di n^ c. Ok? Questa era la definizione di di np. Ok? E vi ricordate che cos'è nc? Chi è? L'insieme insieme Attenzione attenzione l'insieme dei dei linguaggi dei linguaggi sì per cui esiste una macchina non determin non deterministica che ha un algoritmo che determina che che li decide che li decide in tempo big o dna la c. Ok, chiaro? Again, end time è l'insieme dei linguaggi, ragazzi. Vi ricordo che endime, NP, Pono tutte classi di problemi di decisione, ok? I problemi di calcolo là non ce ne stanno perché i problemi di calcolo hanno classi a parte che non forse vedremo alla fine functional classes, però al momento non ne abbiamo visti. Quindi end time è l'insieme delle classi, l'insieme dei linguaggi decisi da macchine di touring non deterministiche in tempo big o dall. Ok? In questa definizione la macchina di touring, no? che risolve, che decide questo certo linguaggio. I guess li può fare quando vuole o è costretto a farli all'inizio? Quando vuole. Ok? Cioè la definizione di questi linguaggi e delle macchine che li risolvono. Non è che ci dice "Guarda, è l'insieme di tutti i linguaggi per i quali puoi fare guess and check e via". No, la definizione che abbiamo dato è l'insieme dei linguaggi decidibili da macchine di Touring non deterministiche in tempo polinomiale e che fanno quello che gli gira, cioè la macchina il non determinismo lo può usare pure alla fine, ok? Eppure in tutti gli esempi che abbiamo visto, abbiamo sempre notato che ste cose, sti linguaggi si risolvono sempre facendo un guess preliminare e un check successivo. Ok? Allora, quello che noi ci chiediamo è: "Ma è solo un caso o tutti i linguaggi di NP possono essere decisi in questo modo? Cioè che il guess lo porto all'inizio e poi faccio una fase di check. Oppure ci sono linguaggi strani di NP tale per cui il gess necessità di farlo più in là nel calcolo. Questa è la cosa. Ok? Allora, a valle di questa considerazione in realtà possiamo addivenire a quella che sui testi recenti di complessità computazionale, tipo se leggete sull'Opcroft questa cosa non è riportata, però ci sta sul Aurora che vi ho segnalato credo pure sul Zippser, ma non ne sono sicuro. I testi più recenti di complessità computazionale definiscono la classe NP in un modo diverso rispetto a quello che abbiamo visto. Perché? Qual è l'ingippo? L'ingipo della nostra definizione è che noi stiamo basando la definizione di questa classe su una macchina che non c'è. Questo è il problema. Noi abbiamo i linguaggi in NP, i linguaggi decidibili in tempo polinomiali da macchine non deterministiche che nessuno sarà mai in grado di costruire. Ok? E quindi i teorici hanno detto, "Ok, magari questa definizione non è che è proprio furbissima, possiamo provare a inventarne un'altra qualcosa che faccia riferimento a altro, cioè vogliamo toglierci dalle scatole ste macchine non deterministiche perché queste macchine non deterministiche non le costruiremo mai." Prego. Qualcosa che abbiamo già in che senso? Cioè nel senso anche questi dovessare assumiamo di poter risolvere già in memoria che avreato. Sì, c'è una definizione DNP in questo modo che non mi ricordo come si chiama. Non è non è oracolo, è un'altra cosa, però sì, una cosa simile c'è. Ok? Advice con advice, cioè noi abbiamo l'advice che si materializza in memoria eccetera e di fatto la definizione che noi possiamo mettere in atto è questa qui. Ok? Allora, vi ricordo che sigma è il nostro alfabeto, sigma star è l'insieme di tutte le stringhe binarie sul nostro alfabeto. una relazione binaria R è su sigma star è semplicemente il sottoinsieme, no, del prodotto cartesiano di sigma star per sigma star, ok? Quindi che cos'è R? R è un insieme di coppie, ok? Quindi una relazione binaria, sto solamente dando nomi, eh una relazione binaria è su sigma star è semplicemente un insieme di possibili coppie di stringhe provenienti da sigma star. Ok? Allora, quello che noi vogliamo catturare è sostanzialmente questa intuizione. L'intuizione è questo, cioè nei nostri problemi che abbiamo visto, no, della classe NP, noi facevamo questo gess, dopodiché facevamo un check e noi che cosa gessavamo? Sostanzialmente noi gessavamo la prova che è l'istanza che avevamo in input. È un'istanza. Sì. Ok. questa cosa che gessiamo, questa prova che noi gessiamo, che è l'istanza che abbiamo in input, è un'istanza sì, noi lo chiamiamo certificato. È un certificato che ci certifica che una certa istanza è un'istanza sì. Ok? Allora, quello che noi faremo ora è combinare questa idea del certificato all'interno di questa nozione di relazione binaria e vedremo che relazione NP si può definire anche in un altro modo. Ok? Alright. Quindi la nostra macchina che fa la nostra macchina non deterministica in genere? che siamo un certificato. Questo certificato non può essere grosso perché non abbiamo tempo di ghessare un certificato più grosso di polinomiale. Quindi noi diciamo che questo certificato è conciso. Dopodiché, dopo aver gessato questo certificato conciso, la macchina che fa? fa un test per verificare la correttezza del certificato. Quanto tempo ci spreca a testare il certificato? tempo polinomiale e quindi noi diciamo che questo certificato è polinomialmente verificabile. Quindi cheessiamo un certificato conciso. Verifichiamo in tempo polinomiale la veridicità verità del certificato. Quindi, sostanzialmente quello che abbiamo fatto negli esempi della settimana scorsa, noi siiamo un certificato conciso è un certificato che deve essere polinomialmente verificabile. Ok? Queste sono le due proprietà del certificato che noi gessavamo con le nostre macchine. Quello che noi vogliamo andare a mostrare è che i linguaggi NP, a parte essere quelli per i quali esiste una macchina non deterministica che li decide in tempo polinomiale, i linguaggi NP sono quei linguaggi, quello che vogliamo arrivare a mostrare, sono i linguaggi NP, sono quei linguaggi le cui istanze si ammettono certificati concisi e polinomialmente verificabili. Ok? Questa è la cosa. Quindi noi vogliamo spostare la nostra attenzione a un tipo di computazione di macchina non deterministica in cui la fase di gess avviene tutta all'inizio. Ok? Quindi questa è la nostra intuizione sulle macchine, il fatto che noi gessiamo un certificato e poi lo verifichiamo. Giochiamo adesso su la nozione di relazione. Ok? Quindi abbiamo una relazione che è un sottoinsieme del prodotto cartesiano delle stringhe. Quindi noi avremo che una coppia X y che appartiene a R. Noi diciamo che R è polinomialmente polinomialmente se la taglia di Y è bound dalla taglia di X. per al eh elevato a un certo esponente C fissato. Ok? Quindi noi diciamo che è una relazione fra stringhe, una relazione binaria fra stringhe, quindi sono coppie x y. Diamo questo nome, la chiamiamo polinomialmente se la taglia delle stringhe in seconda posizione è limitata da un polinomio della taglia della stringa in prima posizione. Ok? Quindi noi semplicemente stiamo dicendo che R è una relazione polinomialmente bilanciata se le stringhe da nel parte destra della coppia in seconda posizione della coppia non sono troppo più grosse delle stringhe in prima posizione. Ok? Quindi r è polinomialmente se la taglia di quello che appare qui non eccede un polinomio della stringa in prima posizione. Ok? è giusto un nome. R è polinomialmente polinomialmente decidibile [Musica] se r si può decidere in tempo polinomiale. deterministico deterministico. Ok? Quindi r è polinomialmente decidibile se si può decidere in tempo polinomiale deterministico. Quando diciamo che R si decide in tempo polinomiale deterministico, significa che data una coppia XY codificata in un alfabeto opportuno bla bla, noi in tempo polinomiale deterministico siamo in grado di dire se quella coppia appartiene alla relazione o meno. Ok? Perché vi ripeto, R è semplicemente un setto insieme di tutte le possibili coppie di stringhe. Basi di dati relazionali le avete fatte, no? Le tabelle sono relazioni. Quindi quando noi diciamo sono relazioni ennarie, invece noi qua ci interessiamo di relazioni binarie, cioè relazioni tabelle con due colonne. Ok? Usiamo la metafora del database, forse vi torna più utile. Una relazione binaria che cos'è una tabella? due colonna. Una relazione è polinomialmente se le stringhe in seconda colonna no sono bounded da un polinomio delle stringhe in prima colonna. Ok? Diciamo che la relazione è polinomialmente decidibile se esiste una macchina di touring deterministica che in tempo polinomiale è in grado di stabilire se questa coppia fa parte di questa tabella. Ok? Adesso, ovviamente, se questa tabella è di taglia finita, il gioco è facile, la rappresentiamo, eccetera, noi dobbiamo pensarla in maniera un po' più estese. R è come una tabella infinita e quindi ci serve un algoritmo per stabilire se una certa coppia sta in quella tabella o quello che noi mostreremo è questo. Teorema sia L un linguaggio. abbiamo che L appartiene a NP se e solo se esiste una relazione binaria RL polinomialmente bilanciata polinomialmente [Musica] bilanciata è decidibile tale che per ogni stringa W vi appartiene eh No, ve la scrivo meglio, tale L è l'insieme delle stringhe X tali che X Y appartiene a R. Ok? Adesso vediamo un po' che cosa significa questa cosa qui. Ripetiamo la metafora del del database che forse è utile. Una relazione polinomialmente decid una relazione binaria è una tabella a due colonne. In questo caso è una tabella un po' particolare perché è una tabella infinita. Ok? Questa relazione ci dice polinomialmente se la il contenuto della seconda colonna non è è polinomialmente limitato in taglia dalla taglia del contenuto in prima colonna. Ok? Quindi non possiamo avere cose enormi in seconda colonna. Esiste una costante Csa quanto più grande può essere il contenuto della seconda colonna. Si dice che questa relazione è polinomialmente decidibile se data una coppia stabilire se quella coppia appartiene alla tabella lo si può fare in tempo polinomiale deterministico. Ok? Sia L un linguaggio, questo è il significato di questo teorema. Sia L un linguaggio. Il linguaggio L appartiene ad NP se solo se esiste una relazione binaria RL. polinomialmente decidibile, polinomialmente bilanciata tale che in prima colonna ci stanno tutte e solo le stringhe del linguaggio, ok? Cioè, quindi L è un linguaggio in NP se noi siamo in grado di inventarci una tabella tale per cui le stringhe in prima colonna sono le stringhe del linguaggio e in seconda colonna che abbiamo? In seconda colonna abbiamo i certificati, ok? Adesso mostreremo che queste y sono i certificati. Chiaro? Ripeto, una volta che definiamo una relazione polinomialmente decidibile, polinomialmente bilanciata, noi abbiamo che un linguaggio L appartiene ad NP. Se è solo se è possibile inventarci una relazione binaria in cui in prima colonna abbiamo le stringhe che appartengono al linguaggio e in seconda colonna abbiamo i certificati. che provano che questa stringa appartiene al linguaggio. Tutto qua. Prego. Scusa, ripetere la definizione di certificato? Certificato. Ok. Il certificato è un'intuizione. Adesso andiamo a vedere che cos'è il certificato. L'intuizione che abbiamo dato prima è ciò che la macchina di touring non deterministica gessa per rispondere sì su una certa istanza. Quella è l'intuizione di certificato. Andremo a vedere che questa caratterizzazione di NP ha i certificati in questa posizione qua, cioè questa Y sono i certificati sostanzialmente. Un esempio. Ah, indipendent set. Independence set, ad esempio, è l'insieme delle stringhe X tali che X Y appartiene a R independent set e R di indipendent set è una relazione relazione binaria in cui x è una coppia grafo numero e y è un independent set. Riuscite a vedere? Sì, è fuori. Ok. R è una relazione binaria in cui X è l'istanza che sono le coppie grafo numero e Y è il certificato. Che cos'è il certificato? È un indipendenzet di taglia K, ok? Un indipendet di taglia e qua viene una schifezza taglia K. Ok? Ve ne menziono un altro. Quali altri problemi? Soddisfacibilità. Ok? Perché il linguaggio della soddisfacilità delle formule buuleane è un linguaggio in P? Perché noi possiamo definire la relazione polinomialmente decidibile e polinomialmente bilanciata per SAT in cui X sono formule buleane e Y è un assegnamento di verità. Ok? Questa relazione è polinomialmente? Sì. i certificati, le y sono per giunta più corte del della formula. È polinomialmente verificabile decidibile, sì, perché una volta che le abbiamo fare il test quell'assegnamento verifica la formula è facile. Ok? Questo ovviamente ancora non lo abbiamo dimostrato, lo dobbiamo dimostrare. Ok? Quanto manca? Un po'. Alrg. No, andiamo dal verso facile prima. Allora, quello che noi vogliamo mostrare ora è che sia l un linguaggio tale che esiste una relazione RL polinomialmente decidibile è bilanciata tale che L = XY appartiene a RL. Ok? Quindi stiamo dimostrando questo verso della della doppia applicazione logica. Adesso noi vogliamo dimostrare che se L è un linguaggio sia L un linguaggio caratterizzato in questo modo, cioè L è un linguaggio per il quale esiste una relazione polinomialmente decidibile, polinomialmente bilanciata che caratterizza il linguaggio, cioè una relazione le cui stringhe in prima colonna sono le stringhe del linguaggio. Ok? Vi ripeto, l'intuizione è istanza certificato. Sì, polinomialmente polinomialmente decidibile e bilanciata tale che funziona. Vogliamo mostrare che L appartene a NP. Ok? Secondo voi un linguaggio così definito, cioè un linguaggio che ha una relazione polinomialmente decidibile, polinomialmente bilanciata, che lo caratterizza, è un linguaggio che può essere deciso in tempo polinomiale da una macchina di touring non deterministica. Sì. Cosa deve fare questa macchina per decidere lì? Eh, ma prima che deve fa'? Indovinare un certificato Y e poi dopo verificare. Ok. Ok. Allora, siccome ML, mettiamo le cose precise, siccome ML è polinomialmente decidibile, allora vuol dire che esiste una macchina di Touring deterministica che in tempo polinomiale è in grado di decidere RL. Ok? il tempo polinomiale che data alla coppia XY, quella macchina è in grado di dire sì, questa coppia appartiene a Ll, no, questa coppia non appartiene a RL. Come fa una macchina di touring non deterministica a decidere L? Semplice. Dato X in input, gessa Y scrive Y nastro. Quanto tempo ci mettiamo a scrivere Y nastro? in particolare quanto eh eh che è limitata come rispetto a ximo cardinalità di x^ lunghezza di x^ c. Quella c è una costante che caratterizza il linguaggio. Quindi la macchina la prima cosa che fa? inizia a sparare cose su nastro, scrive una y di lunghezza pari a lunghezza di x^ c, ok? Scrive questa cosa sul nastro, ok? Sul nastro, quindi poi avremo che cosa? La coppia x y. Quindi deve essere lanciata una procedura che data la coppia X y stabilisce stabilisca se questa coppia appartiene a RL o meno. Siccome RL è bil polinomialmente decidibile, allora noi abbiamo che questa macchina di touring non deterministica si sostanzialmente fa quello che farebbe il riconoscitore di RL. Ok? Quindi in tempo polinomiale, il non deterministico, siamo in grado di riconoscere L. Da cui, se L è caratterizzato da una relazione polinomialmente decidibile e polinomialmente bilanciata. Bilanciata, vi ricordo che y non è più grossa di x, quindi la macchina non deterministica sta y la può scrivere sul nastro, ok? in tempo polinomiale. Quindi se L è caratterizzata da una relazione binaria in quel modo, allora il linguaggio appartiene a NP secondo la definizione classica che abbiamo dato prima, che abbiamo dato nelle lezioni passate. Cioè, ci sta una macchina non deterministica che è in tempo polinomiale. Riconosci il linguaggio. Ok, veniamo adesso alla parte più intricata della dimostrazione. Ok. sia L un linguaggio in NP. Vogliamo mostrare che esiste una relazione RL polinomialmente decidibile e bilanciata tale che L = XY appartiene a RL. Quindi, che cosa abbiamo qui? abbiamo che L è un linguaggio in NP generico a questo punto e noi vogliamo mostrare che L può essere il linguaggio più disgraziato di NP, ma potrà sempre essere deciso da una fase iniziale di gas polinomiale seguito da una fase di check, cioè può essere caratterizzato da una relazione polinomialmente decidibile e polinomialmente bilanciata. Cioè la macchina di Touring non deterministica che riconosce Là di fare gess nello stadio avanzato della computazione. Può fare tutto all'inizio. Ok? Alrght è un linguaggio in NP, che cosa possiamo dire? Che esiste? Sì, se L è in NP esiste una non deterministicuring machine M che decide L in tempo polinomiale. Ok. Alright. Vediamo la computazione di questa macchina. ricordo ID0, poi ci stava ID1, ID 1 ad esempio. Poi qua abbiamo altro, qui c'è altro ancora e così via. Ok? Quindi la computazione di questa macchina è caratterizzata da questo computation 3. Chiaro? Se la macchina lavora in tempo polinomiale, che cosa possiamo dire sulla lunghezza dei branch di computazione? quello più lungo che accetta la attenzione attenzione. Quello più lungo, indipendentemente se accetta o meno, il branch di computazione più lungo polinomiale è polinomiale nella taglia dell'input, ok? Cioè tutti questi branci di computazione, il numero di step partendo dalla configurazione iniziale e che arrivano alle foglie, cioè dove la macchina si ferma e non processa oltre, ha un numero di passi, diciamo che un certo polinomio P1 di N, dove n è la taglia del dell'input. Ok? È chiaro? Quindi questa macchina processa in tempo polinomiale significa che fa al più un numero polinomiale di passi in qualsiasi sia il suo brancio di computazione. Supponiamo che questo polinomio sia +1. Ok? Benissimo. Se la macchina lavora in tempo P1 polinomiale, no, potrà mai scrivere su nastro qualcosa che è gigantevolmente più grande? No, perché? Perché non c'è il tempo. Questa macchina che fa un di n passi potrà scrivere sul nastro P1 N cose. Ok? Quindi ogni istantaneous description sarà di taglia polinomiale. Ok? Ripeto, questa macchina processa in tempo polinomiale il proprio input, poiché lavora in tempo polinomiale, non ha tempo per scrivere più cose di polinomiale. Quindi ognuna di queste istantaneous description avrà una lunghezza polinomiale nella taglia dell'input, una sola, ok? tipo ID1 oppure questa qua sotto ID5 per dire avrà una taglia che è polinomiale nella taglia dell'input iniziale perché perché la macchina non ha il tempo di scrivere spazzatura, ok? Non ce l'ha il tempo di scrivere più di polinomiali, ok? Allora, guardiamo questa sequenza. Noi sappiamo che c'è una computazione di questa macchina e supponiamo cambiamo colore che questo qua sia il pat accettante. Ok? Noi possiamo listare la sequenza dell'istantaneous description della macchina da ID0 verso lo stato accettante. Ok? Quindi abbiamo ID0, ID1, poi magari veniva ID4 bla bla bla bla bla bla IDK che è finale, ok? Questa sequenza di instantaneous description della macchina è sostanzialmente una prova del fatto che la stringa input debba essere accettata o no? Ci chiediamo a questo punto, questa sequenza qui, ok? La nostra idea è usare questo come certificato perché costituisce la prova che la macchina accetti. Cioè se io mostro la sequenza di passi, guarda, questa è un'istanza sì perché questa macchina di Touring fa questi passi e alla fine dice di sì. Quindi questa è la ragione per cui questa è un'istanza sì. Ok? Quante sono le istantaneous description in questa sequenza? Sì, sono P di 1 N, sono bounded da questo. Ok. Quanto è lunga ognuna di questa istantaneous description? Sempre al massimo polinomiale. Sempre polinomiale. Chiamiamolo, boh, P2. Chiamiamo P2 la lunghezza di ognuna di queste istantaneous description. Quindi avremo che cosa? un certificato costituito da un numero polinomiale di istantaneous descriptions, ognuna delle quali ha lunghezza polinomiale. È chiaro? Quindi questo certificato overall che taglia ha? Sì, avrà una taglia P1n P2N che è un polinomio. Ok? Quindi noi ci siamo inventati un una sorta di certificato per questo linguaggio L generico che non è che va a guardare la struttura del problema, cioè qui non stiamo gessando nodi, non stiamo ghessando colori, non stiamo gessando assegnamenti di verità, eccetera. Il certificato è la sequenza di passi che una macchina che decide L compie per dire di sì su una certa istanza. Ok? Quindi ci dobbiamo come prima cosa chiedere se questo certificato sia sensato o meno. Poi stabiliremo se è grande o piccolo e se si verifica veloce o lento. Ok? Prima domanda. Siccome questa cosa qua deve andare a finire, noi dobbiamo costruire un RL in cui X sono le istanze del linguaggio e Y è il certificato che X appartiene a L. Se in Y ci andiamo a ficcare questo certificato qui, è vero, no, che le solamente tutte e sole istanze CDL hanno un certificato di questo tipo, cioè una sequenza di passi di una macchina di Touring che fa per dire di sì. Sì, quindi il certificato è sensato. Ok? Quindi in linea di principio noi potremmo caratterizzare l'RL del linguaggio L in questo modo in cui X è l'istanza di del linguaggio e Y è la sequenza di passi che la macchina di Touring non deterministica M fa per dire di sì sulla stringa X. Ok? Per come è definito questo Y esiste solo per le istanze C di N. Ok? Quindi questo certificato ha senso. Ci chiediamo, il certificato è conciso? Quando parliamo di certificato conciso significa che la taglia di questo certificato è un polinomio della taglia di x. Ok? Questi sono gli aggettivi che usiamo. Il certificato è conciso, la relazione è polinomialmente bilanciata, il certificato è polinomialmente verificabile, la relazione è polinomialmente decidibile. Ok? Allora, ci chiediamo, è vero, no, che questo certificato è piccolo e conciso? Sì, perché abbiamo una sequenza polinomiale di instantaneous description, ognuna di taglia polinomiale. Quindi questa y è grande, è vero, però sempre un polinomio è. Ok? Quindi questo certificato è conciso da cui la relazione RL è una relazione polinomialmente. Ok? È vero, no, che questo certificato è polinomialmente verificabile? È vero che in tempo polinomiale deterministico siamo in grado di stabilire se questa sequenza, questo certificato che ci danno è una sequenza sensata o meno. Voci nuove. Y no. Sì, sì, perché è l'insieme di instantaneous description fino a quel punto. È la sequenza, non l'insieme, la sequenza di instantaneous description che arrivano fino in fondo. Ma lo posso fare in tempo polinomale deterministico o no? Questo check deterministico. Eh, ok. unazione all'altra verifichiamo se la se lo step è leg esattamente nel momento in cui abbiamo la sequenza della computazione della macchina non deterministica, il verificarne la correttezza non implica non richiede l'uso del nondeterminismo. Quello che noi dobbiamo semplicemente andare a verificare a coppie se questa ID è una mossa legale rispetto alla funzione di transizione di M che è fissata. È fissata per il linguaggio L, ok? Perché M è fissato. Quindi verifichiamo e verifichiamo questo, poi verifichiamo questo, questo e così via. Ok? E questo check si può fare in tempo polinomiale deterministico perché dobbiamo semplicemente andare a verificare che questa cosa sia legale secondo una funzione di transizione fissata. Ok? Quindi noi abbiamo e con questo ma adesso ci fermiamo un attimo. Noi abbiamo che cosa? che un linguaggio appartiene ad NP, se è solo se, è caratterizzabile da una funzione, da una relazione binaria polinomialmente decidibile e polinomialmente però all'inizio siamo partiti che con me che vi dicevo, oggi vedremo una nuova caratterizzazione di NP. Ok? Ma dove sta questa nuova caratterizzazione di NP? Allora, la caratterizzazione di NP è sostanzialmente questa. I linguaggi di NP, poiché sono caratterizzati dalla relazione polinomialmente decidibile e polinomialmente sono quei linguaggi le cui soluzioni possono essere verificate in tempo polinomiale deterministico. Questa è. Quindi abbiamo in soldoni che in P ci stanno i problemi la cui soluzione si calcola in tempo polinomiale. In NP abbiamo quei linguaggi che una volta che ci danno un testimonio, un certificato, quello lo verifichiamo in tempo polinomiale. Quindi i problemi in Piluzione è facilmente ottenibile. I problemi in NP sono quei problemi la cui soluzione una volta che ci viene data è facilmente verificabile. Quindi la questione P versus NP si annoda su questo punto crociale: è vero, no, che tutti i problemi che ammettono che posso la cui soluzione possa essere verificata facilmente sono anche problemi la cui soluzione può essere calcolata facilmente. Ecco, noi riteniamo che questo non sia possibile, cioè che esista una classe che P ed NP siano separati, cioè che NP, che i problemi per i quali è facile verificare una soluzione non necessariamente sono problemi per i quali è facile calcolarla, come riporta Calauti nei suoi appunti, questo è un interessantissimo paper di Aronson dove lui fa una discussione filosofica sul fatto se P sia uguale a NP o men. E lui dice, "Se noi vivessimo in un universo in cui NP e fosse uguale a P, allora chiunque fosse in grado di apprezzare una sinfonia sarebbe Mozart, sarebbe in grado di comporla e chiunque fosse in grado di seguire una dimostrazione sarebbe Gaos, sarebbe in grado di produrle dimostrazioni, ma noi non vediamo questo. Quindi con buona probabilità NP e P sono separati, ok? e ci fermiamo per Ok, fino ai 20. Pausa. Cosa vediamo ora? Ora vediamo per la gioia di voi tutti un altro problema NP completo. Ok? un problema che vi ho già menzionato che è il problema della colorabilità dei grafi. Ok? [Musica] Allora, in cosa consiste questo problema? Abbiamo il solito nostro grafo, abbiamo una Ok, ve lo spiego a pezzi. Allora, cos'è una cos'è una colorazione di un grafo? La colorazione di un grafo, per quello che abbiamo visto già quando abbiamo parlato della riduzione, la eccetera, è sostanzialmente una funzione che assegna un colore ad ogni nodo. Dice questo nodolo coloro rosso, questo verde, questo viola, questo indaco e così via. Ok? E deve essere una funzione, una colorazione tale per cui nodi agganciati da un arco hanno colori distinti. Ok? Chiaro per tutti così è una colorazione? Tipo questo lo facciamo verde, questo lo facciamo eh giallo, questo blu e questo rosso, per esempio. Ok. Alrghto un grafo. È vero o no? Vi ricordo che noi siamo sempre interessati a problemi di decisione, ok? Quindi un problema la cui risposta è sì. No. Dato un grafo, è vero o no che ci sta un una colorazione per quel grafo? Certo, usiamo tanti colori quanti i nodi. Siamo ben contenti di colorarlo come vogliamo. Ok? Allora, il problema non sta lì. Il problema è colorare un grafo con una tavolozza limitata, ok? Quindi quello è il problema che noi definiamo. Colorabilità è definito così. È l'insieme delle coppie grafo numero K tale che è possibile colorare i nodi di G. con Kori, no con al più Kori con al più Kori, così è più esplicito. Ok. Alright. Noi vogliamo dimostrare che questo problema è NP completo. Per dimostrare che il problema è NP completo, come al solito, dobbiamo fare due cose: mostrare la membership in NP e mostrare la sua hardness. Allora, la colorabilità appartiene a NP o no? Sì, perché gessiamo una combinazione. Gessiamo una colorazione. Quanto tempo ci mettiamo a ghessare questa cosa? Polinomiale. Polinomiale, perché dobbiamo gessare un colore per ogni ognuno dei nodi. Ok? Quindi il gess si fa in tempo polinomiale. Quanto tempo ci mettiamo a verificare che questo gess sia corretto? polinomiale. Tempo quadratico. Noi per ogni coppia di nodi agganciati andiamo a vedere se il colore è lo stesso o meno. Ok? Quindi possiamo dire che colorabilità appartiene a NP. Dobbiamo mostrare adesso che colorabilità è un problema NP arduo. Ok? La riduzione si fa da 3 SAT, almeno la riduzione che vediamo ora è da 3 SAT. Tres nella sua variante in cui ogni lettera, ogni clausola ha esattamente tre letterali. Ok? Così ci semplifichiamo un po' le cose. Ok? Quindi domanda che mi è stata fatta prima, ma come mi organizzo una riduzione? Allora, una riduzione è un guizzo di fantasia, cioè questo è for di dubbio, di dubbio, però possiamo dare una struttura a quello che facciamo. Ok? Cosa faccio io? Mi chiedo qual è il problema di partenza? Presat, qual è il problema di arrivo. Colorabilità. Che cos'è un'istanza del problema di partenza? è una formula fai in CNF. Ok? Che cos'è un'istanza del problema di arrivo? è una coppia grafo numero, quindi io devo inventarmi una funzione fasze sì di tre sat che sono formule in istanze sì di colorabilità che sono grafi e tavolozze di colore. Ok? Che cos'è un'istanza si per tre sat? [Musica] una formula soddisfacile che significa che è soddisfacbile combinazioni letterali che attenzione esiste un assegnamento di verità per le variabili tale che la formula sia soddisfatta. Eh, attenzione, quando io vi correggo sui termini e sulle parole è perché l'utilizzo di un linguaggio vago ci fa confondere, ok? Quindi dobbiamo essere precisi, senò ci perdiamo per strada. Ok? Ecco perché sono così puntiglioso nel correggere le cose. Ok? Quindi che significa che la formula FA è soddisfacbile? Significa che date le sue variabili buleane esiste un modo di scegliere per loro il valore vero o falso, tale per cui una volta che diamo questi valori nella formula tutto davvero. Ok? Che cos'è un'istanza? Sì. per il problema della colorabilità, un grafo, tale che ogni nodo non abbia nodi adiacenti legati ad un arco con lo stesso colore. Mh, no, attenzione, più precisa perché come ha strutturato lei la frase presuppone che sta facendo riferimento a una colorazione. No, è diverso. istanza sì per il problema della colorabilità è un grafo che può essere colorato con al più k colori. Il fatto che i nodi adiacenti abbiano colori diversi eccetera, quello proviene dal fatto se abbiamo già una colorazione in mano. Ok? Quindi dobbiamo essere precisi. Poi sì, è legato ovviamente alla nozione di colorazione. Un stanza sì del problema della colorabilità è una coppia grafo numero tale per cui quel grafo ammette una colorazione dei suoi nodi con al più numero di colori, tale per cui, e qui c'entra la descrizione fatta dal nostro collega, tale per cui quella colorazione assegna colori diversi a gra a a nodi agganciati. Ok? Che cos'è un'istanza no per tre sat? Unazione a variabili tale che quando No, no, no, no. Un'istanza no di satte, eh un'assegnazione a variabili. Attenzione un attimo. Non esistono assegnamenti di variabili. Se cosa c'era il suo collega prima? Beh, se nel momento in cui abbiamo censato nel momento in cuiamo la clausola da cosa No, no, ma cos'è unistanza? No, di Tresti. Ok, c'era il collega dietro di lei. Cos'è unistanza no di Tre SAT? Eh, è una un'espressione in 3CN, sì. Che non è soddisfacbile tramite nessun assegnamento. E che cosa significa? che cioè non esiste un assegnamento delle variabili che compaiono all'interno del dell'espressione che renda veri tutte le clausole. Sì. Ok. Allora, è importante il modo in cui ha iniziato la sua frase. Ha detto è un'espressione buleana tale che. Che cos'è un'istanza no? Un'istanza no è un'istanza perché ci stanno le istanze e poi le dividiamo in due classi. Stanze sì, istanze no. Che cos'è un'istanza? No, un'istanza no e un'istanza. Che sono le istanze di SAT? Sono formule. Quindi un'istanza no di SAT è poiché è un'istanza è una formula che ha una proprietà. Il fatto che qualsiasi assegnamento di verità noi diamo alle sue variabili il risultato della valutazione è sempre falso. Ok? Questa è un'istanza, no? Che cos'è un'istanza no della colorabilità? Un attimo. Qualcun altro? Vi ripeto, un'istanza no di colorabilità è un'istanza di colorabilità. Che che sono le istanze della colorabilità? Un attimo, un attimo. Ok. Una coppia di grappoa per cui non esiste nessuna combinazione di colori per farsi piedi. Ci siamo di al più K colori. Ok. Cioè perché fa sì che ci siamo nodi dello stesso Sì, esattamente. Ok, quindi istanze sì, istanze no. Istanze sì, istanze no sono due classi delle istanze. Quindi cos'è un'istanza sì è un'istanza che ha una certa proprietà, che cos'è un'istanza no è un'istanza che è una certa proprietà. Ok? Allora, quello che ora ci dobbiamo inventare è un modo di trasformare una formula soddisfacbile in un grafo colorabile e una formula non soddisfacbile in un grafo non colorabile. Ok? Quindi questa riduzione è simile a indipendenzetti in cui trasformavamo una formula in un grafo. Qui dobbiamo trasformare una formula in un grafo che può essere colorato o meno. Allora, questa ve la faccio vedere. Allora, supponiamo di avere la formula fatta così: X1 or X2 or not X3 and not X2 or X3 or not X4. Ok, qua mi sto dimenticando un pezzo, quindi avvio questo. Prima parte me la ricordo, la seconda non tanto. Ok, allora partiamo. Così noi dobbiamo partire da questa formula e dobbiamo generare un grafo, ok? un gafo che sia K colorabile. Partiamo con questo pezzettino di grafo, con questi tre nodi T, F, B e agganciamo così. Ok? Questi saranno i nodi che ci diranno in qualche modo se la colorazione sta codificando un assegnamento di verità che soddisfa la formula o meno. Allora, perché facciamo questo? Che cos'è che dobbiamo decidere? Cioè, nel momento in cui dobbiamo decidere che una formula f sia soddisfacbile, che dobbiamo stabilire? sempre un assegnamento ai ai letterali avere almeno una delle clausole almeno una tutte le clausole, ok? però in buona sostanza dove sta qua. Senò mi perdo per strada e non voglio scrivere fesserie. Ok. Ok. Quello perché c'è l'aggancio. Sì. Ok. Mi ricordavo bene. Allora, sulle formule buleane date le variabili noi dobbiamo stabilire che cosa? Per soddisfare la formula. Seè una variabile vero o falsa. Che cos'è il quibus da decidere sulla colorabilità quando vogliamo risolvere il colore che assume un sac? Ok? Quindi da un lato dobbiamo stabilire se la variabile è vero o falsa, dall'altro dobbiamo stabilire ma sto nodo che colore gli diamo? Rosso, verde, giallo. Quindi in qualche modo la nostra riduzione dovrà mappare assegnamenti di verità variabili in colori da dare ai nodi. Ok? Questa è la metafora che usiamo nella trasformazione. Quindi, nel primo, come primo pezzo del nostro grafo, mettiamo questa click di taglia 3, ok? Una click, vi ricordo, che è un pezzo di sottografo, in cui tutti i nodi sono collegati a tutti gli altri. Quanti colori ci servono per colorare questa click? Al massimo tre. Al minimo tre. Al minimo tre. Ok, ci servono tre colori e allora facciamo così. C'è il colore del vero, il colore del falso e un colore neutro o base. Ok? Quindi nel nostro grafo i nodi che avranno lo stesso colore del nodo T è come se mi stessimo assegnando il valore vero. I nodi che avranno lo stesso colore del nodo F è come se gli stessimo assegnando falso. Ok? Perché facciamo questa similitudine? Vi ripeto, perché dobbiamo mappare l'assegnamento di verità delle variabili verso colori da assegnare ai nodi. Ok? L'ho colorato in quel modo, poteva essere qualsiasi altra cosa, è solo per avere un omnemonic. Ok? Quindi avremo i nodi colorati come t, in questo caso verde, così ce lo ricordiamo, sono i nodi veri. I nodi colorati come f rosso, così ce li ricordiamo, sono i nodi falsi. I nodi colorati blu sono nodi altro. Ok? Allora, siccome noi dobbiamo mappare l'assegnamento di verità su una colorazione, noi avremo nodi. Per ogni variabile x con i avremo due nodi, x con i e x con i negato. Ok? Ci inventiamo questa cosa qua. Quindi avremo sì, come no? X1 è not x1. Siccome dovranno avere colori diversi, noi otteniamo questa cosa collegandoli. Poi avremo, sto trasformando proprio questa formula qua, eh, X2 not X2 è lì aggancio. x3 not x3 e poi x4 e not x4. Ok? Not x4. Ok? Allora, così come sono collegati i nodi x1, not x1, x2, not x2 e così via possono essere colorati con colori diversi, ok? non possono avere lo stesso colore. Però siccome noi dobbiamo mimare il fatto che possano essere veri o falsi, che facciamo? Li agganciamo al nodo blu. Ok? Così il colore che possono prendere X1 e not X1, X2 e not X2 saranno solo verde e rosso. Ok? Quindi io faccio questo, questo, questo e questo. Chiaro? Quindi x1 e notranno essere uno vero e l'altro rosso o al contrario, però non potranno assumere il colore blu. Va bene? Così questo pezzo di grafo, eh devo fare più di qua. Come si taglia? Non si taglia. Questo pezzo di grafo ci codifica, ci andrà a codificare l'assegnamento di verità delle variabili buleane. Ok? Dobbiamo adesso inventarci altri pezzi di grafo che vanno a codificare se una formula sia se una clausola sia stata soddisfatta da un certo colore o meno, da un certo assegnamento o meno. Ok? La facciamo prima a parte e poi l'aggiungiamo. Ok? Considerate questo pezzettino di grafo, poi lo cancello. Eh, noi dobbiamo, vi ricordo che questa è una clausola che è fatta da due OR, quindi dobbiamo andare a simulare tramite colorazione un OR, ok? Lo facciamo in questo modo, cioè questo gadget qui, questo pezzettino di grafo che ci andrà a implementare questa cosa. Supponiamo, no? di dare il colore falso ai due input. Questi sono gli input e questo sarà l'output di questo pezzettino qui. Eh, guardate questo pezzo di grafo come si comporta. Se io li coloro entrambi rossi, questi qua, eh, questi qui di che colore dovranno essere? Entrambi verdi. Come? Entrambi verdi possono essere entrambi verdi. Uno verde e uno blu. Ok. Adesso quale? Non importa perché son collegati, eh? C'è questo c'è questo arco qua. Quindi entrambi i verdi non possono essere. Sì, avevo dato questo contatto quello a destra, forse è quello blu. Ah, ok. Ok, ok. Ok. Quindi saranno uno rosso, uno verde, uno verde e l'altro blu. Ecco qua. Certo, qua non finiamo più. Blu. Ok, quindi se quello sono uno verde e l'altro blu, il terzo nodo di quel triangolino sarà rosso. Ok? Quindi questo pezzettino di grafo è interessante perché si ha input due nodi rossi, in output ha un nodo rosso. Guardiamo una cosa simile di nuovo, quindi questo qua, questo qui, questi sono gli input output. Ok, questo è il nostro gadget. Supponiamo che invece sia uno rosso e l'altro l'altro verde. Ok. Di che colore possono essere i due nodi intermedi? Come? O verde o blu e blu o blu e rosso. Blu qua. Sì. è rosso qui. Ok? Di conseguenza l'uscita potrà essere colorata verde. Quindi questo pezzettino di grafo sta codificando la funzione logica OR. Quindi noi utilizziamo questo sottografo per codificare le clausole. le clausole loro fra tre elementi e noi semplicemente faremo una cosa di questo tipo. Questo che sono i due input che è messo in input a comerà fatto all'altro. Ok? In questo modo noi con questo pezzo di grafo noi siamo in grado di codificare la clausola le clausole. Ok? È chiaro? Allora, adesso li cancello. Attenzione. Quindi spariranno, mi serve spazio. Quindi mi servono due pezzi per le due clausole, una e l'altra due. Ok? Quindi questo qui farà riferimento alla prima clausola che è questa e questo qui farà riferimento alla seconda clausola. Ok? Qual è la prima clausola? X1 or X2 or not X3 e semplicemente le colleghiamo. X1 qua, X2 qua, not X3 qui. L'altro cos'è? not x2, x3 e not x4. Ok, al primo grafico dei quelli a fianco, sì, colleghiamo x1, x2 e noi colleghiamo i nodi relativi ai letterali che appaiono in quella clausola. Quindi la prima clausola è x1 or x2 or not x3. colleghiamo il nodo x1, il nodo x2 e il nodo not x3. Stessa cosa per la seconda clausola. Una domanda, ma all'esame forse consigliate di portarci o altro un normografo? Vi portate proprio il tecnigrafo, vi mettete là. C'era il mio professore di analisi all'università quando gli diceva "Ah, ma gli appunti li possiamo portare" eccetera faceva "Voi potete portare tutto quello che passa dalla porta, solo il vostro vicino non potete usare, tutto il resto è ammesso." Allora, noi abbiamo quindi che in questo che in questo pezzo di grafo noi stiamo andando a codificare che cosa? le clausole della formula. Noi che cosa vogliamo? Noi vogliamo che l'output di queste clausole sia vero, di quel pezzo di di clausole sia vero. Ok? Quindi di che colore ci aspettiamo che siano questi nodicini qua? Verdi. Come facciamo a imporlo che siano per forza verdi? collegandoli agli altri due. Quindi quello che faccio è che collego questo al blu e al rosso. Questo al blu e al rosso. Ok? Quindi questa è una trasformazione. È intrigato. Non vi non vi darò cose così toste da inventare. Eh, non vi preoccupate, peggio ancora. No, no, scherzo. Allora, questo grafo, quindi, è un grafo particolare, abbiamo 8 minuti, è un grafo ottenuto dalla formula G. Dobbiamo stabilire il numero di colori, il numero di colori è 3. Ok? Il K dobbiamo stabilire. Questi sono tutti i dettagli che trovate negli appunti di Calauti. Ve li leggete, vi rispiego esattamente la stessa cosa. L'ho presa da là la riduzione che se in genere ne usavo un altro. Ok. Sì. Il problema che abbiamo fatto un po' di tempo fa sulle piastrelle si può ridurre è questo. Sì, noi abbiamo le le piastrelle. Sì. No, le piastrelle non si può ridurre a questo perché le piastrelle è indecidibile. Questo problema invece è decidibile, quindi non si può, a meno che non abbiamo una funzione di trasformazione indecidibile, ma quello ovviamente è come tirar fuori il coniglio dal cappello, ok? è una cosa che non si può fare. Alrght, allora, quello che noi sostanzialmente vogliamo mostrare ora è che la formula fai è soddisfacbile se è solo se il il grafo così generato è un grafo tre colorabile. Ok? Supponiamo che la formula sia soddisfacbile perché io mi occupo della formula soddisfacbile perché le istanze di partenza sono formule. Ok? Se fosse stato un altro grafo, avrei parlato di grafi, insieme di nodi, eccetera. Supponiamo che la formula di partenza fai sia una formula soddisfacile. Questo significa che ammette un assegnamento di verità sigma per le sue variabili tale che quell'assegnamento di verità soddisfa tutte le clausole di F. Ok? Allora, noi coloriamo il grafo G ottenuto da Fine con tre colori in questo modo. I tre nodi della parte di sopra li coloriamo così. Dopodiché dobbiamo stabilire x1 e not x1 come colorarli. Se x1 è vero in sigma gli diamo gli diamo verde. Se x1 è falso in sigma gli diamo rosso. E a notte x1 gli diamo l'opposto. Facciamo lo stesso per tutti gli altri. Ok? Quindi noi stiamo prendendo l'assegnamento di verità che soddisfa fai e lo stiamo trasformando in una colorazione per questo grafo. Ok? Dopodiché dobbiamo colorare la parte rimanente del grafo. La parte rimanente del grafo è colorabile perché per quello che abbiamo visto prima sulla proprietà di questi pezzettini di grafo, se questi pezzettini di grafo ricevono in input dei nodi verdi, allora l'output può essere colorato verde. E quindi, come ciò è vero per tutte le clausole, perché sigma soddisfa tutte le clausole di f, noi avremo un modo di colorare in maniera coerente questo pezzo qua. È chiaro? Chiaro per tutti? Vediamo l'altro verso. Supponiamo di essere arrivato a arrivati a un'istanza sì del problema della colorabilità. Se siamo arrivati a un'istanza sì del problema della colorabilità, allora vuol dire che questo grafo è colorabile con tre colori. Questo pezzo di grafo avrà necessità sicuramente di tre colori. Parleremo quindi del colore di T, del colore di F e del colore B. Questi altri nodi saranno colorati in un certo modo. Da questa colorazione noi deriviamo l'assegnamento di verità per la formula per la formula f e funziona così. Andiamo a vedere questi nodi e la loro colorazione. Se x con i prende lo stesso colore del nodo t, nell'assegnamento di verità gli diamo vero. Se il nodo x con i prende il colore del nodo f, allora nell'assegnamento di verità gli diamo falso. Ok? Ci chiediamo, questo assegnamento di verità è coerente e consistente. Abbiamo variabili a cui assegniamo vero e falso contemporaneamente? No, perché per ognuna delle x con i prendiamo il colore del nodo e usiamo solamente lui, ok? Quindi non è che deamo vero e falso alla stessa variabile. Quindi l'assegnamento di verità così generato è coerente. Ci chiediamo se un tale assegnamento di verità soddisfi la formula di partenza. Ok? Supponiamo per assurdo che non la soddisfi, ok? che quindi ci sia una clausola, ad esempio questa qua della formula di partenza che sia falsa in questo assegnamento di verità ottenuto dalla colorazione. Se è falsa vuol dire che questi letterali sono tutti falsi, ma se sono tutti falsi allora questo sarebbe rosso. Questo sarebbe rosso, quest'altro sarebbe rosso e quindi per come è definito questo pezzo di grafo, anche questo qui dovrebbe essere rosso, ma ciò non pot può essere perché lui è agganciato qua. Se questo è rosso, questo è rosso e quest'altro è rosso, questi qua saranno verde e blu, quindi lui rosso. Poi quest'altro rosso, quindi verde e blu rosso e questo rosso qua. Ok? Quindi ciò implicherebbe che avremmo una colorazione in cui questo rosso è agganciato a quest'altro rosso, ma ciò non è possibile. Di conseguenza l'assegnamento di verità ottenuto dalla colorazione di questo grafo deve essere una deve essere un assegnamento che soddisfa la formula di partenza. Quindi se siamo arrivati a un'istanza sì del grafo, quindi un grafo colorabile, era perché partivamo da un'istanza sì della formula buleana, quindi da una formula soddisfacile. Chiaro? A questo ora siamo tutti un po' stanchi, eh? Chiaro? più o meno. Allora, io chiuderei qua, se c'è qualche domanda rispondo, senò abbiamo bisog Mi sp. Buona serata. Grazie. Ok, alza la voce. Ripeta i cerchietti che destra è un vertice perché Sì, sì, questi qua devono essere per forza ver. Sì, esattamente.