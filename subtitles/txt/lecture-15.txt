Ok, iniziamo. un po' prima che oggi c'è un sacco di roba e vorrei riuscire a finirla in caso concludiamo prima. Allora, che vediamo oggi? Oggi continuiamo a vedere problemi indecidibili, quindi vediamo il problema che avremmo dovuto vedere nella seconda metà della scorsa lezione, ma non ci siamo riusciti. Lo vediamo oggi e poi introduciamo un concetto nuovo riguardo l'indecidibilità. Ci siamo quasi, eh, credo che domani chiudiamo la parte di calcolabilità e poi si inizia a complessità, quindi, insomma, il corso anche da un punto di vista di ore e abbiamo già varcato la metà, non so se ve ne siete accorti, ci stiamo dirigendo verso la fine. Ok, allora quello che facciamo oggi è una cosa simile a quello che abbiamo visto durante la lezione scorsa in cui abbiamo preso un problema non strettamente legato alle macchine di Turing. abbiamo dimostrato essere un problema eh non ricorsivo, indecidibile e abbiamo ottenuto l'indecidibilità tramite una riduzione da eh linguaggio universale. Essenzialmente abbiamo fatto vedere che quel problema era in grado di simulare funzionamenti di macchine di Turing. Ok, oggi ne vedremo un altro che è il problema del tassellamento, del tiling e dimostreremo che anche questo problema è un problema indecidibile. Questo problema all'apparenza sembra molto diverso, sembra abbastanza un problema normale e non cose strane su macchine di touring, però mostreremo che anche questo problema è indecisibile. Riduzione. Dimostreremo questa cosa tramite una riduzione. Come al solito voi ve lo siete andati a riguardare il concetto di riduzione perché non se ne esce senò eh proprio è proprio da qui in poi saranno quasi sempre riduzioni durante tutte le lezioni, ok? Quindi è una cosa che usiamo usiamo e usiamo e usiamo e quello serve. Eh ok. Allora, consideriamo questo problema che è il problema del tiling. Tiling. Ok, ve lo spiego prima in maniera intuitiva, poi lo formalizziamo. Ok? Ok. Che cos'è il tiling? Il problema del tiling, supponiamo di avere una superficie, tipo il primo quadrante cartesiano, ok? Che vogliamo ricoprire con delle piastrelle sostanzialmente. Ok? Quindi questa superficie può essere suddivisa in dei quadri. riquadri che per noi sono di unità uno e noi dovremmo andare a sistemare dentro questi riquadri delle piastrelle. Questa superficie, essendo il primo quadrante cartesiano, è una superficie infinita, ok? Ha un'origine in cui questa è la cella di origine, dopodiché il resto, cioè abbiamo questa superficie come se avessimo una stanza infinita in cui abbiamo un angolo e dobbiamo mettere piastrelle su questa stanza. Ok? avremo varie piastrelle di un certo tipo, piastrelle che potranno essere accostate orizzontalmente o verticalmente secondo alcune regole. Ok? Quindi recap, noi abbiamo il piano cartesiano, il primo quadrante del piano cartesiano da piastrellare con delle piastrelle che hanno tutte la stessa dimensione e ognuna andrà a riempire uno di questi quadrati. Le piastrelle non si possono mettere a caso. Avremo del che ci saranno delle regole tale per cui alcune piastrelle possono essere messe una affianco all'altra orizzontalmente e altre piastrelle che potranno essere messe una sopra l'altra verticalmente. Cioè ci saranno delle regole. Come sono fatte queste piastrelle? Forse vi è capitato di giocare a questo gioco. Una piastrella è fatta in questo modo, no? Che è divisa in quattro parti. Ognuna di queste parti ha un colore, tipo verde, blu, rosso, eh, che ne so. Che altro abbiamo di carino? Questo viola. Si vede niente. Vabboh. Questo qua. Ok. Quindi le piastrelle hanno questa suddivisione a quattro. Ognuna di queste piastrelle è caratterizzata da questa colorazione. Quindi abbiamo che alcune piastrelle sono di questo tipo, altre piastrelle sono di un altro tipo. Il tipo delle piastrelle è individuato dai colori dalla disposiz dal tipo di colori e dalla disposizione dei colori che abbiamo. Ok? Possibile non c'è un colore migliore. M m m questo qua. Questo mi piace. Eh, questo Ok, abbiamo visto. Ok. Alright. E ne abbiamo tanti. Ok. Quindi abbiamo piastrelle divise in quattro settori con dei colori. Il tipo di colori e la disposizione dei colori individua il tipo di piastrella. Le piastrelle che possono essere messe sul quadrante vanno messe così come sono, non le possiamo girare, ok? Quindi vanno prese così e le schiaffiamo sul tavolo, ok? non le possiamo girare, non le possiamo strecciare, cioè quindi non è che le allunghiamo, hanno tutte questa stessa dimensione che è una cella sul quadrante e come possono essere messe una di fianco all'altra. Sì, ad esempio quattro colori possono averne quanti ne vogliamo, più pure 1000. Ma ogni casella ha 1000 colori o no? Ogni ogni ogni tessera è divisa in quattro porzioni. Una porzione c'ha un colore preso da un set che vogliamo, no? Ok. Sono ne abbiamo infinite piastrelle, quindi abbiamo un numero finito di tipi e un numero infinito di piastrelle di ogni tipo. Ok? Le piastrelle possono essere messe una a fianco all'altra se si vanno a toccare con il lato e hanno lo stesso colore. Ok? Tipo, ad esempio, non posso mettere questa su questa perché il colore di sotto della tail di sopra è blu e il colore di sopra della tile di sotto è rosso. Però posso mettere, vedi questo? No, però posso mettere questa su questa perché così le parti verdi vanno a combaciare. Ok? Quindi noi possiamo mettere in maniera adiacente le piastrelle solo se vanno a toccare, cioè le altre piastrelle che vanno a toccare sul bordo in comune hanno lo stesso colore. Ok, ci siamo. Piastrelliamo il primo quadrante diviso in celle. Le celle prenderanno queste piastrelle. Le piastrelle sono un numero finito di tipi. Il tipo identificato dai colori che colorano le quattro porzioni. Piastrelle ne abbiamo un numero infinito. Le piastrelle possono essere affiancate solamente se il bordo in comune con la piastrella vicino è dello stesso colore. Ok? Tra le varie piastrelle ne avremo una particolare che andrà posta per forza in prima posizione che chiamiamo di zero. Ok? Quindi fra tutti i tipi di piastrelle uno di questi tipi è l'unico che può andare in quella posizione là. Ah, ho capito. Sì. Cos'altro? Cos'altro? Cos'altro? Detto tutto, la domanda è dato un sistema di questo tipo, di tiling di questo tipo, è vero, no? Che è possibile ricoprire tutto il primo quadrante cartesiano? Cioè, è possibile che riusciamo a ricoprire quello spazio infinito? Oppure la tipologia di piastrelle che abbiamo a un certo punto si blocca e non riusciamo a finire tutta il piastrellamento. No, può essere qui una pastella identica a qualche direzione? Non ho capito la domanda. Se ripetere più più di una piastrella identica. Certo, noi abbiamo vari tipi di piastrelle e per ogni tipo ne abbiamo infinite. Ok? Certo, senò se ne avevamo finite come riempiamo un piano infinito? E è un po' un problema. Sì. Quindi abbiamo infinite piastrelle di un numero finito di tipi. L'affiancamento può avvenire solo se i bordi hanno dello stesso colore, son dello stesso colore. In questa posizione ci deve andare a finire una piastrella specifica. Non possiamo metterci quello che vogliamo. La domanda è se posso mettere piastrelle per riempire tutte le linee di questo piano e io piastrello questa stanza infinitamente grande? Questo problema si può dimostrare essere indecidibile, cioè potete sbattere la testa quanto volete, un algoritmo che risolve questo problema non lo troverete, non ci sta. Prego. Nella stessa piastrella puoi sapere in due settori diversi lo stesso colore. Sì, sì, sì, sì, sì. Quindi può esserci una piastrellaato lo stesso colore. Sì, su quello non abbiamo vincoli, eh, cioè fa parte dell'input. Fra i tipi di piastrelle abbiamo una piastrella tutta blu. Vabboh. Ok. Però poi verrà contornata da piastrelle che la toccano con porzioni blu. Eh, non è che ci metti altro. Può mettere due a fianca all'altra. Può mettere, scusi, due giù, una fianca all'altra. Sì, sì, sì, sì. L'unica regola che dobbiamo seguire è questo, che nel momento in cui affianchiamo due piastrelle, o orizzontalmente o verticalmente, il cordo in comune deve avere lo stesso colore. Tutto come nella posizione zero. Sì, ci deve andare una Guys, guys, guys, un attimo. Ci deve andare una pesterella di un certo tipo che viene assegnata. Questa con l'indom te lo danno nell'input. Adesso lo vediamo. Questa va in prima posizione. Per alcune è possibile però provare risposta per altre no dipende l'input. Sì, alcuni input. Se lei ha un input di piastrelle tutte rosse si fa un bel pavimento rosso, lo ricopre. Il problema è se abbiamo piastrello un po' così a cavoli, se ce la facciamo a Cioè alla fine è un problema di domino, no? Hai visto che le tessere del domino che vanno affiancate riusciamo a sistemarle? Eh, più o meno quello è il problema. Altre domande? Yes. Sì, sì, adesso vediamo. Sì, perché se avessimo tutte le combinazioni di colore, se fossero finite, ovviamente o avessimo tutte le possibili combinazioni di colore, avremmo anche le piastrelle monocolore, quindi le useremo. Ok? Quindi i tipi di piastrella adesso lo descriviamo bene. Eh, c'era una domanda là. Quindi non abbiamo ogni tipo di di di piastrella, no? Se avessimo input ogni tipo di piastrella, un'istanza del genere sarebbe quale sarebbe la difficoltà di rispondere a istanze del genere? Supponiamo di avere istanze in input in cui abbiamo la garanzia che tra le tipologie di piastrelle ci sono tutte le tipologie di piastrelle che abbiamo. Qual è la difficoltà di rispondere a questo problema? è nulla. Si risponde sempre di sì, non devo nemmeno guardare gli input, si risponde in tempo costante a questo problema. Cioè, io ignoro l'input e dico yes, capito? Quindi non ha senso. Le piastrelle, dai un attimo non vi sovrapponete. Le piastrelle sono di tipo finito, di tipo assegnato nell'input secondo delle regole. Adesso il problema lo formalizziamo, non vi preoccupate. Vi ho solo voluto dare l'intizione. C'era domanda là sono Sì, sì. È tipologia di piastrelle qu sono 5 10 20 100. Te lo dicono prima. Ti danno un'istanza e ti dice guarda c'è ste pile di piastrelle, no? Ne hai 18 tipi diversi. Ci sono delle pilone, pile infinite. Dice, scusa, dice questa questa tipologia se è l'unica messa a stare in posizione zero. Me lo piastrelli il pavimento, no? E tu e noi dobbiamo dire sì o no. Questo problema è indecisibile, cioè non si risolve. Questo non esclude, guys. Quando noi diciamo che un problema è indecidibile, non significa che su ogni istanza non sappiamo che dire, significa che ci sono istanze sulla quali noi non siamo in grado di dare la risposta. Quello è sufficiente per il problema essere indecidibile. Se su ogni istanza noi fossimo in grado di dire sì o no, il problema sarebbe in quale classe? R. Ok? Quindi basta giù anche una sola istanza sulla quale non sappiamo dare la risposta. Il problema è indecidibile, ok? Perché se siamo sfigati e ci capita questa istanza in input, la nostra macchina non risponde. Chiaro? Domanda non so se la domanda, cioè la domanda che risponde è possibile piastrellare il quadrante con un set specifico oppure è possibile farlo a partire da un set di zero? È possibile farlo con un set specifico se impongo di zero. Eh sì, fa parte dell'input. Ok, adesso formalizziamo l'input così siamo tutti contenti. Ok, cos'è l'input di questo problema? Un'altra cosa, per esempio, questa piastrella può essere messa sulla destra di questa. Ok? Vi ricordo che le piastrelle non ruotano, eh, non le giriamo come vogliamo, vanno prese così come sono e piazzate sul pavimento. Ok? Input. L'input è un sistema di tiling che è una quadrupla formata da D, D0, H e V dove D è un insieme finito di tipi di piastrella D0 D0 appartiene a D è il tipo di piastrella ammessa in posizione 00. Ok. H è l'insieme delle regole di affiancamento orizzontale. Ok? Quindi h è un sottoinsieme del prodotto cartesiano D* D. Ok? E queste sono intuitivamente le regole di affiancamento orizzontale. Come vedete in questa definizione formale non abbiamo i colori eccetera, ok? Noi abbiamo tipi tipo 1, tipo 2, tipo 3, tipo K, tipo A, tipo B, tipo C. Ok? Poi abbiamo un subset del prodotto cartesiano che ci che ci dice il tipo pippo e il tipo topolino possono stare di fianco. Ok? I colori ve li ho descritti prima per avere un'idea di come funziona sta cosa e non partire con i simboli che senò ci sparavamo. Ok? H poi D è un sottoinsieme del prodotto cartesiano D* D. Che cosa sono? Sono le regole di affiancamento verticale. Come si chiama? M quello originale hh H maiuscolo horrizontal. Ok. Cos'è un tiling? Un tiling attraverso il sistema T è una funzione che mappa coppie di numeri naturali a tipi di piastrelle. Ok? Quindi un tiling cos'è? è un'allocazione, è una funzione che mappa la posizione della cella sul quadrante con il tipo di piastrella che vogliamo infilare lì, tale per cui l'allineamento verticale, l'affiancamento verticale orizzontale rispetta le regole. Quindi abbiamo che f 00 deve essere di 0. Quindi in posizione 00 che è questo angolino qua, ci deve andare il tipo specifico. Non ci possiamo mettere una cosa a caso. Secondo pezzo f di mn f m + 1 n appartiene ad h per ogni m ed n appartenente ai naturali. E quindi significa che se noi andiamo a vedere la piastrella in posizione MN e la piastrella alla sua destra, allora questo affiancamento deve far parte dell'insieme delle coppie ammissibili in H. Ok? e FMn FMN + 1 appartiene a V per ogni MN appartenente a ai naturali. Ok? Quindi cosa dice? è che se noi andiamo a prendere di questa funzione l'assegnamento delle pastrelle a una qualsiasi posizione e a quella sopra di lui, allora questa coppia di piastrelle deve appartenere all'insieme delle coppie ammissibili dell'affiancamento verticale. Ok? Not ci stanno colori eccetera, era solo per stabilire un po' e difatti adesso i colori non li vedremo un granché perché ce ne serviranno veramente tanti, quindi invece di colori inizieremo a parlare di etichette perché è più facile, ok? Sennò non saprei come colorare le cose, ok? Alright. È chiaro per tutti il problema? Allora, noi dimostreremo, sebbene questo problema non sembri particolarmente strambo, questo problema è indecidibile. Ok? E per dimostrare questa cosa proporremo una riduzione da hal dal negato di tiling dal negato di halt e. Vi ricordo che il problema halt e l'arresto di una macchina su stringa vuota. Il suo negato è il non arresto della di una macchina su stringa vuota. Cioè, dato una macchina è vero che questa macchina processando la stringa vuota non si ferma mai. Ok? Noi ridurremo quindi il complemento di halt e al problema del tiling. Il simbolo della riduzione qual è? è minore o uguale. Ok, chiaro? Ok. Cos'è un'istanza? Cos'è un input per il problema not halt e? Una macchina. Una macchina. Ok. Cos'è l'input per il problema del tiling? E la e la quadrupla è un sistema di tiling. Ok. Quindi quello che noi ci dovremmo inventare è una trasformazione F, chiamiamola in un altro modo perché F abbiamo già chiamato quello, una trasformazione G che presa in input la codifica di una macchina di Touring sputa fuori in output un'istanza del problema di tiling tale per cui la macchina M non si arresta sulla stringa vuota se è solo se il sistema di tiling sputato fuori dalla funzione. Vi ricordo che questo t è ottenuto come applicazione di g su m. Quindi la T che sputiamo fuori è un sistema di tiling che ammetta un reale tiling se solo se M non si arresta mentre processa la stringa vuota. Ok? Come potete intuire, ed è del trucco che abbiamo usato anche per il problema di corrispondenza di post, noi dobbiamo codificare nel problema del tiling le computazioni di questa macchina. Questo è il problema. Ok? Quindi ci dobbiamo inventare sta cosa. Adesso vi inverto la spiegazione. Invece di spiegarvi prima la riduzione, come ho fatto la scorsa volta, vi faccio prima l'esempio, così cerchiamo di mettere i pezzi del puzzle, magari così vi perdo di meno. Ok, vi chiedo. Alright. Allora, l'intuizione è sostanzialmente questa. Noi dobbiamo riuscire a individuare dentro sto cavolo diing dov'è che possiamo codificare la computazione di una macchina di Touring. Questa è la è la questione sostanziale. Ok? Vi ricordo che le computazioni di macchine di Touring possono essere efficacemente rappresentate come sequenze di configurazioni che la macchina attraversa mentre processa una certa stringa. Ok? Quindi vi ricordo che quindi una computazione può essere configurazione 1 seguito dalla configurazione 2 seguito dalla configurazione 3 bla bla bla bla dove per configurazione vi ricordo che una sequenza di simboli è una cosa del tipo eh che ne so 0 1 Q3 1 Questo è un esempio di configurazione in cui ci essenzialmente ci dice che in input abbiamo questa stringa qua 011, cioè sul nastro di input, siamo nello stato Q3 e stiamo leggendo questo simbolo. Ok? E questa è l'idea di configurazione, un'assunzione che facciamo sulla macchina M, istanza del problema halt epsil, not halt epsil, e che è un'assunzione che non limita il potere espressivo delle macchine. C'è un teorema sul sul testo Opcroft, potete andarvelo a guardare, no? Il dettaglio non lo vediamo che ci dice che praticamente se noi limitiamo la macchina di touring a un nastro semiinfinito, cioè che ha un punto di partenza e non sposta mai la testina alla sinistra di quel punto di partenza, la macchina ha lo stesso potere delle macchine standard, ok? Esere dall'altro lato sostanzialmente, ok? È la stessima cosa. Questo ci serve per semplificare la riduzione, ok? La riduzione che vi propongo è un po' diversa dalla riduzione che trovate sugli appunti di Calauti. Ok? Questo è preso da Papa Dimitriu, mi pare. Ok? Più altre miegioni per renderlo similare a come stiamo trattando noi le le macchine di Turing. Ok? Alright. Allora, l'idea è sostanzialmente questa. Facciamo un bel disegnone, bello grosso, così capiamo. Ok, questo è il nostro piano. Avremo il primo livello qua, secondo livello qua, il terzo livello qua e insomma. Poi abbiamo questo, questo, questo. Noi che cosa faremo? Questa è l'origine. Noi sfrutteremo i bordi, ok? Fra ogni livello di piastrelle, perché le piastrelle le possiamo immaginare, siccome è un reticolo, primo piano, secondo piano, oppure prima fila, seconda fila, terza fila. Ok? Cosa faremo? Il bordo fra le file lo sfrutteremo per codificare le configurazioni delle della macchina che calcolo. Ok? Questa è l'idea. Quindi dovremmo avere intuitivamente un numero di colori sufficientemente ampio tale per cui i colori che mi appaiono qui mi stanno sostanzialmente descrivendo una cosa di questo tipo. Quella quella è l'intuizione. Ok? Quindi vi ripeto, abbiamo la prima fila, la seconda fila, la terza fila. Noi sappiamo per le regole di affiancamento, l'intuizione era che i colori a cavallo tra la prima e la seconda fila devono essere gli stessi perché sennò non riusciremo a impilare le piastrelle. L'intuizione è questa, avere una tavolozza di colori sufficientemente ampia, tale per cui tramite quei colori riusciamo a fare che cosa? a codificare configurazioni di macchine di touring, tale per cui sul bordo fra la fila 1 e la fila 2 avremo la prima configurazione, sul bordo fra la seconda fila e la terza fila avremo la seconda, poi la terza e così via. Ok? È chiara almeno l'intuizione? L'intuizione è inventarsi delle piastrelle tale per cui quando le andiamo a buttare su questo piano il loro affiancamento mi sta codificando il funzionamento della macchina M. Yes. Ma usiamo solo i bordi orizzontali? I bordi verticali, questi qua, adesso vi mostro, serviranno poi a ottenere certe cose, ok? Però l'intuizione è che sul sulla parte orizzontale noi dobbiamo codificare il la sequenza delle configurazioni che la macchina di Turing M osserverebbe nel attraverserebbe nel momento in cui stesse processando la stringa vuota. Questa è l'idea. Ok? in maniera tale che se la macchina M non si arresta mentre processa la stringa vuota, allora di file e di piastrelle ne possiamo mettere infinite. Questa è l'idea. Ok? Se la macchina si ferma, ste piastrelle a un certo punto si fermano perché poi la tipologia di piastrelle che avremo non ci permetterà di piazzare una nuova fila. Se invece la macchina M non si arresta su epil, allora noi avremo tipologie di piastrelle che ci permetteranno di mettere file di piastrelle l'una sull'altra senza fine. È chiara l'intuizione della riduzione? Yes. Ok, lo dico io. Va benissimo. Allora, questa è quello che noi vogliamo ottenere. Ok. Adesso, siccome a noi servono un bel po' di tipi di piastrelle, perché dobbiamo codificare il funzionamento della di una macchina di Touring che può essere generico, ok? Fare riferimento ai colori diviene un po' complicato. Ok? Allora, quello che faremo invece è che le quattro porzioni delle piastrelle, invece di colorarle gli scriviamo il nome del colore, ok? Gli mettiamo un'etichetta Topo Gigio, Paperino, ok? Così possiamo enumerarne un po' di più di colori che non stare là a scegliere le gradazioni. Ok? Quindi useremo etichette per il nome del colore in modo da gestirli più facilmente in quantità perché ce ne servono tanti. Ok? Alright. Allora, l'idea sostanzialmente è questa qui, eh, vediamo di cancellare. Yes. Vediamo se funziona. Uh, yes! Ok, allora vediamo se c'abbiamo spazio. Sì, supponiamo di avere questa macchina qua. Ok, Q0 stato iniziale. Leggo blank, scrivo blank e vado avanti e mi muovo in Q1. Leggo blank, scrivo blank e torno indietro e vado Q0. Ok. Che fa sta macchina con la testina? Pin pom pin pom pin pom. Ok. Questa macchina si arresta o non si arresta sull'input vuoto? Non si arresta. Ok. Quindi quello che noi vogliamo ottenere è un sistema di tiling partendo da una macchina del genere che ci permette di eh ricoprire tutto il piano. Ok? Allora, sostanzialmente, siccome abbiamo detto che utilizzeremo dei labels, dei nomi per i colori, ok? Noi avremo quindi cosa avremo qua? Che il colore che appare qui e il colore che appare qui dovranno avere lo stesso nome. Lo stesso qua, lo stesso qua. Ok, chiaro? Ok, disegno anche questi sopra, così diventa più semplice, dai. Eh, ta ta. Ok, allora l'idea è questa. Qual è la configurazione iniziale di questa macchina specifica sulla stringa vuota? Q0 che legge bianco. Ok, quindi sarebbe Q0 Q0. Ok. Che legge bianco. Qual è il resto del contenuto del nastro di questa macchina? All'inizio è tutto bianco. Ok. Quindi avremmo blank blank blank. Ok? Cioè le configurazioni che andiamo a mettere su questo piano sono un pochino strane, cioè sono estese, non ci fermiamo, la scriviamo tutta, ok? Quindi noi vorremmo che le etichette che appaiono sul bordo tra la prima e la seconda fila siano queste Q0 bianco, quindi una coppia che ci dice che in posizione 1 abbiamo la testina e stiamo leggendo bianco mentre siamo in Q0. Questa però è solo il nome di questo colore. Potrebbe essere verde verdolino. Ok. Però siccome non possiamo andare a guardare tutte le sfumature, prendiamo queste etichette. Ok? Quindi abbiamo il colore aperta parentesi Q0 blanc chiusa parentesi. Lo potevamo chiamare Topo Gigio, è la stessa cosa, però siccome dobbiamo mapparla su funzionamento di una macchina, scegliamo dei nomi che ci tornino funzionali. Ok? Quindi, se noi abbiamo fatto proprio un affiancamento con tutti i crismi, di che colore sarà questa porzione qua? Uguale sarà Q0 bianco, chiusa parentesi. Ok? Poi qua avremo bianco bianco e qui bianco bianco. Come facciamo a imporre che alfa 2 vada a codificare la configurazione successiva? Data questa configurazione, qual è la successiva secondo quella macchina? Sì, prego. Come facciamo ad essere sicuri che anche i successivi a destra siano uguali al primo? che siano bianchi, che siano bianchi anche loro. Lo vedremo fra un attimo. Adesso diamo giusto un'intuizione su che cosa ci deve stare a quei bordi perché poi giustamente dobbiamo inventarci dei tipi in maniera tale che non facciamo cose strane, ok? Utilizzeremo i bordi verticali per forzare piastrelle che vanno affiancate orizzontalmente. Ok? Alright. Ah, ok. Qual è la configurazione successiva a quella blank? Eh, blank Q1 blank blank blank bla bla bla bla. Ok, quindi se voglio che questo affiancamento di piastrelle mi vada a replicare che da questa configurazione io raggiungo questa qui, allora questa qui, questa piastrella qua e quest'altra piastrella qui mi devono dare la possibilità di codificare che lo stato passi da q0 a Q1 e vada avanti di una posizione. Ok? Come faccio? Stabilisco delle etichette di colori che replicano queste cose. Ok, potremmo farlo rosa shocking, no? Gli mettiamo un label. Ok, quindi qua ci mettiamo blank, qua ci mettiamo Q1 blank e qui blank. Ok, quindi guardate qua che ci serve come piastrella. ci servirà una piastrella che simula il passaggio di Q0 su blank. Che piastrella ci serve qua? Ci servirà una piastrella che simila il passaggio di Q1 verso lì. Per fare ciò e non avere cose strane, qui dovremmo utilizzare dei colori particolari in maniera tale che questa piastrella possa essere affiancata solamente a questa. Come lo facciamo? Usiamo questo altro label. Eh, come si chiamava? È P. Sì, la chiamiamo Q1 freccetta avanti e questa qua Q1 freccetta avanti. Per dire cosa? Che c'è lo stato Q1 e la testina in transizione verso quello che è destra. Destra. Ok? Chiaro? Quindi noi avremo necessità di cosa? di U piastrelle che abbiano questa faccia in modo tale che noi su questo bordo qua stiamo codificando alfa 2. Cosa sarà alfa 3?0 sarà Q0 blank blank blank and Quindi che cosa avremo necessità? Avremo necessità di una piastrella che qua c'ha blank perché sennò non la riusciamo ad impilare sull'altra. Qui c'ha Q1 blank, senò non la riusciamo a impilare con l'altra e deve che cosa? Codificare il passaggio della testina verso sinistra. Quindi qui che avremo? Q0 che si muove a sinistra e qui avremo Q0 blank e qui blank, qua blank and on. Ok? È chiaro il senso? Quindi noi ci stiamo inventando un attimo delle piastrelle i cui colori alle quali noi stiamo dando dei noi perché come vedete ce ne serviranno tanti. Quanti sono i simboli di nastro? Noi dovremmo avere piastrelle, non è che possiamo stare là a colorarle. Usiamo delle etichette per identificare i colori. Ok, tutto qua. Questi colori identificati tramite etichette hanno lo scopo primario di codificare la sequenza di configurazioni che la macchina M attraversa mentre processa la stringa vuota, guardando a cosa? A i bordi fra i ai bordi orizzontali fra i livelli di piastrella. Ok? Adesso questa idea qui e dai va generalizzata a una generica macchina di Touring M che potremmo avere input alla funzione di trasformazione G. C'era una domanda lì. Sì, non ho rispondo. Ah, ok. Alright. Chiaro? Chiaro il principio, l'idea che c'è dietro. Adesso va semplicemente generalizzata in maniera tale da descrivere G in modo generico. Ok? Alright. Mi serve un'altra pagina. Cool. Andiamo a guardare qua. Come vedete da queste da queste piastrelle qua, tipo questa questa qua che è lo stesso, se qui avessimo dei simboli, tipo qua X qua andrebbe replicato. Quindi servono delle piastrelle che simulano il fatto che se la testina sul nastro è distante lì non deve succedere niente. Cioè, quindi quel colore dal bordo di sotto deve essere passato al bordo di sopra. Quindi avremo una prima tipologia di piastrelle che è questa qua per ogni simbolo X appartenente a gamma. Ok? Qui non infilo niente sui bordi per dire che l'etichetta vuota e noi possiamo affiancare piastrelle con quel bordo verticale solo se hanno la stessa etichetta. Quindi se non c'è niente io posso mettere piastrelle solo con quella porzione vuota. Non ci posso affiancare una piastrella dove lì c'è scritto altro. È come se fosse un nome aggiuntivo, no? colore trasparente. Ok? Semplicemente non lo scriviamo. Ok? Dopodiché guardiamo questo esempio che ci servono? ci servono piastrelle che codifichino la funzione di transizione. Queste qua sono e lo spostamento della testina da un lato all'altro, perché la tipologia uno sono queste piastrelle qua, cioè quelle piastrelle che stanno su che simulano una porzione di nastro lontano dalla testina e lì c'è un'inerzia. Il simbolo è quello e quello deve rimanere fino a quando si avvicina la testina. Ok? Dobbiamo codificare, adesso dobbiamo descrivere in maniera generica le piastrelle che codificano la funzione di transizione. Ok? Secondo tipo di piastrelle. Supponiamo che dobbiamo codificare una generica transizione di configurazioni in cui abbiamo lo stato Q che legge il simbolo X seguito dal simbolo Z e poi c'è la funzione di transizione che siamo in Q, leggiamo X, andiamo in P, scriviamo Y e andiamo a destra in cui praticamente questo viene trasformato in cosa? Yp. Ok? Quindi se quello è un generico pezzettino di una configurazione e siamo in presenza di una fun di un pezzo di funzione di transizione così, allora vuol dire che transiamo da questa pezzo di configurazione a questo pezzo di configurazione. Adesso quindi dobbiamo fare le piastrelline per quello là. Che cosa abbiamo? Quindi abbiamo due piastrelle in cui sotto abbiamo la coppia QX, sopra abbiamo Y, sotto c'è Z e qui c'è PZ e qua c'è P in transinzione verso destra. Ok? Cioè, quindi questa due tipologie di piastrelle codificano che semmai la macchina si troverà a leggere un simbolo X, questo simbolo viene sovrapposto da da Y, eccetera. Adesso qui X e Y e Z sono dei simboli generici. Noi dobbiamo quindi generare tante piastrelle per cosa? per ogni stato Q e P che appartengono agli stati non terminali e poi per ogni X, Y e Z che sono simboli di nastro in cui X e Y però devono essere quelli che appaiono qua dentro. Eh, chiaro? Cioè, questa è solo una descrizione generica. Quindi ci stiamo attrezzando con tipologie di piastrelle che sono in grado di simulare scrittura e spostamento di sestina a destra. Cosa ci serve adesso? Le piastrelle che simulano scrittura e spostamento di testino a sinistra. Ok? Ah, quindi avremo No, qua avremo che cosa? Tipo in caso avessimo ZQX e questo diviene pzy. In caso di presenza di funzioni di transizione qx che va in p y a sinistra. Ok, quindi abbiamo la stessa cosa, due piastrelle. Quindi che ci sta? Z qui, PZ qui, QX qui, Y qui e qua abbiamo Q che trans P che transisce a sinistra, P che transisce a sinistra e questo va fatto per ogni stato Q e P appartenente ai non terminali e per ogni simbolo X, y z su i simboli di nastro. Chiaro? Quindi questa tipologia di piastrelle, ovviamente ne abbiamo tante, eh, cioè per ogni combinazione di quei simboli di nastro noi dobbiamo avere piastrelle di quel tipo. Quindi, stiamo carrozzando il sistema di tiling con tutti i possibili casi che la macchina si potrebbe trovare di fronte mentre computa. Perché dobbiamo fare questo? Perché noi non possiamo preventivamente simulare la macchina per stabilire se si ferma o meno, perché la funzione deve produrre un sistema di tiling in tempo finito, cioè quindi dobbiamo fare una trasformazione generica. Prego. no è il nome che diamo a due stati non terminali. Ok? Vedete che noi stiamo facendo solo cose per stati non terminali, quindi non lo prevediamo proprio che la macchina possa a un certo punto transire in uno stato terminale. Ok? Chiaro? Ultima cosa, terza tipologia. La terza tipologia, che è quella che ci serve per la cosa che ci diceva proprio il nostro collega prima, detto come facciamo a essere sicuri che qua vado a finire proprio la configurazione iniziale e lì usiamo questa terza tipologia di piastrelle. Allora, abbiamo una piastrella di questo tipo Q0 blank, dove Q0 è lo stato iniziale e qui c'ho blank e poi un'altra piastrella fatta così, blank, blank, blank. Ok, chiaro? Questa qui è di 0. Vi ricordo che parte del tiling system prevedeva che noi esplicitamente menzioniamo una piastrella di essere tipologia di zero. Quella è di zero, cioè quindi in posizione 00 ci va per forza quella là. Ok? Adesso, come potete vedere dalla riduzione, dalla costruzione che abbiamo fatto, la prima linea di piastrelle è costituita solamente da questo, perché questa qui va in posizione 00 perché gliela imponiamo. Dopodiché di fianco a lei ci possono andare solo quelle con blank qui. Quindi questa qui mi andrà in prima fila. In prima fila. Quindi cosa staremo facendo? Staremo mantendo piastrelle in maniera tale che sul bordo superiore stiamo codificando la configurazione iniziale della macchina M su stringa vuota. È chiaro? Alright. Adesso dimostriamo che la trasformazione funziona e poi ci prendiamo una pausa. Ok. Primo verso, vi ricordo che noi dobbiamo dimostrare sostanzialmente che m è un'istanza sì del complemento di halt su se e solo se t ottenuto come il trasformato secondo g di m è un'istanza sì del problema del tiling. Un'istanza del problema di tiling è sì se ammette un piastrellamento. Se non lo ammette, non è un'istanza, no? Ok. Alright. Dimostrazione. Primo verso della dimostrazione. Dimostriamo che se m non si arresta su allora t ottenuto in quel modo specifico ammette uning. Ok? Allora, l'intuizione è molto semplice e riguarda il modo specifico in cui abbiamo definito le tipologie di piastrell. Noi andremo a piazzare in posizione 00 la piastrella di 0 e poi riempila tutte le piastrelle di terza tipologia. Dopodiché noi possiamo impilare su seconda fila, su terza fila, solamente piastrelle che codificano che cosa? La sequenza delle configurazioni della macchina. Perché? Perché così abbiamo scelto i colori. Ok? Quindi noi avremo una fila aggiuntiva di piastrelle. Ogni qualvolta la macchina avrà a disposizione uno step aggiuntivo. È chiaro? Siccome la macchina non si ferma su input vuota, quanti step fa? Infiniti. Quante file di piastrelle potremmo mettere? infinite, da cui se la macchina M non si arresta su stringa vuota, allora noi riusciamo a piastrellare il nostro primo quadrante. Allora T appartiene Allora T ammette un tiling, un timingo. Chiaro? Altro verso della dimostrazione. Dobbiamo dimostrare che se la macchina si arresta su stringa vuota, allora noi non siamo in grado di piastrellare la nostra superficie. Invece di dimostrare questo, dimostriamo il suo compo. Dimostriamo che se la sistema di tiling ottenuto tramite G che ha processato M ha prodotto un sistema di tiling che ammette un tiling, allora era perché M non si arresta su stringa a ruota quando processa. Ok. Alright. Guardate le piastrelle come sono state definite. Abbiamo già visto che queste piastrelle codificano sostanzialmente, no, la sequenza delle configurazioni che la macchina attraversa nel momento in cui calcola. Ok? Questo perché? Perché in prima fila, se abbiamo un tiling, avremo una disposizione di piastrelle che codifica la configurazione iniziale. Le tipologie di piastrelle che abbiamo definito non sono non ammettono stati terminali. Di conseguenza, se siamo riusciti a piastrellare tutto, la macchina non è mai passata da uno stato terminale da cui M non si arresta mentre processa la stringa vuota. Ok? Questo ci dimostra che il problema del complemento del halting su stringa vuota può essere ricodificato sul problema del tiling, da cui non possiamo sperare che il problema del tiling sia decidibile perché il complemento di Halt su È indecidibile. Chiaro? Ok, facciamo fino a 10 di pausa. Ok, il dopo potrebbe essere lungo. E ora è un po' sofisticato e mi serve del tempo. Schermo intero. Ah no, c'era già. Schermo intero. Cool. Guys, quello che vi sto per spiegare ora, state bene attenti, bla bla bla. Non c'è trucco, non c'è inganno, non sta né sugli appunti di Calautti né sui libri segnalati perché è un argomento un po' più avanzato che in genere non viene affrontato quando si parla di calcolabilità perché è una cosa che riguarda più la teoria delle funzioni ricorsive è più una cosa della logica matematica che non della calcolabilità in informatica. Quindi se voi vi prendete un testo dove c'è si chiama gerarchia aritmetica, queste cose vengono spiegate, ma sui testi standard di calcolabilità non si trova. Però io ve la volevo mostrare da un punto di vista informatico perché secondo me ha una certa valenza carina, secondo me, ok? Perché ci servirà anche quando ci servirà a ragionare quando prenderemo la complessità. Ok? Allora, non so se avete già notato, quindi vi ripeto, sta roba non la trovate sugli appunti o sui libri, quindi è quello che vi dico io stamattina. Non so se avete notato che i problemi indecidibili che abbiamo visto finora sono tutti un po' particolari, cioè c'è una certa relazione fra un linguaggio indecidibile e il suo complemento, cioè hanno tutti la stessa faccia, guardate. Quindi noi abbiamo R, qua ci sta R che è una cenerentola. Finora non abbiamo visto un granché che sta in R. Ok. Allora, abbiamo che il linguaggio universale sta qua, sta in re, perché il linguaggio qui vi voglio un po' snappi, eh, perché ci serve del tempo. Perché il linguaggio universale sta in re? Perché dobbiamo fare un po' di ragionamenti assieme, senò ci perdiamo. Perché Lu sta in re? Perché esistono che lo devi accettare. M intuitivamente che facciamo? Simuliamo m su w se ci arrestiamo diciamo di sì. Ok? Il suo complemento dove sta? Sta fuori perché? Perché sennò altrimenti entrambi starebbero in R. Ok? L'intuizione, perché il complemento di Lu sta fuori R? Perché se eh esistono macchine che non arrivano mai ad accettare. Sì. Quindi se dobbiamo dire sì, è vero, la macchina non si ferma e noi la simuliamo, noi non ci arriveremo mai a vederlo che la macchina non si è fermata per fermarci e dire di sì. Ok? Questa è l'intuizione per cui il complemento di lu sta fuori il re. altro lne che è l'insieme delle macchine che accettano qualcosa. Ok, sta in re perché l'intuizione indovino una cosa che perché indoviniamo, cioè l'intuizione è quella. noi riusciamo a rispondere sì perché il tempo finito abbiamo il modo di farlo. Quindi come facciamo a sapere che unistanza che ci viene data che una macchina fa parte di LNE perché noi che siamo una cosa che accetta la simuliamo in tempo finito perché la deve accettare e siamo in grado di dire sì. Dove sta il suo complemento le sta fuori intuitivamente perché sta fuori il re? Perché dovrei provarle tutte Sì, perché per poter rispondere sì, è vero, questa macchina non accetta niente, dovrei tra virgolette provare tutte le stringhe, no? E vedere che non si arresta o dice di no. Quanto tempo intuitivamente mi serve per faare sta cosa? infinito. Quindi noi io non sono in grado in tempo finito di dire "Guarda, sta macchina non accetta niente, questa è l'intuizione che c'è dietro". Ok? Altro. Poi LD, vabbò, questo era un po' strambo. Andiamo avanti. Vediamo quest'altro. Halt. Halt sta qui, che è il problema dell'arresto. Perché Halt sta dentro il re? Perché basta vedere se la macchina basta simulare se la macchina se sta macchina si ferma, diciamo. Sì. Ok. Dove sta il suo complemento? Fuori. Fuori. Perché? Perché dovremmo poter dire che si ferma in tempo? Esattamente. Poi c'abbiamo halt su che sta in re perché è un istanza di perché noi simuliamo la macchina sulla stringa vuota. Se si ferma ci fermiamo e diciamo di sì. Dove sta il suo complemento? Fuori. Fuori. Ok, state notando qualcosa per questi problemi? Noi abbiamo halt e che sta fuori perché intuitivamente non siamo in grado di dire se da dire in tempo finito se la macchina non si arresta su stringa vuota. Perché se gli andiamo appresso appresso nella simulazione per essere sicuri che sta macchina non si ferma dovremmo simularla fino alla fine dell'eternità. Ok? Quindi questa è l'intuizione dei problemi che abbiamo visto finora, cioè i problemi che stanno e state attenti bene qua perché adesso facciamo il salto. I problemi che abbiamo visto finora che stanno in R sono quei problemi per i quali noi siamo in grado di rispondere sì in tempo finito. I problemi che abbiamo visto finora in R e non in R hanno il loro complemento fuori re, però il complemento che hanno è un è un linguaggio particolare. Sono tutti questi linguaggi che abbiamo visto qua, che abbiamo visto finora e che non stanno in re, hanno una peculiarità. sono linguaggi complementi di linguaggi che stanno in R. Ok? Vi ricordo che il complemento di un linguaggio è il linguaggio in cui flipliamo le risposte. Ok? Quindi se i linguaggi che abbiamo visto finora stanno fu i linguaggi che abbiamo visto finora che stanno fuori re sono complementi di linguaggi che stanno in re, allora questi linguaggi hanno una peculiarità. Sì, dicono que sono quei linguaggi per i quali noi siamo in grado di rispondere no in tempo finito. Ok? Cioè, quindi questi non sono linguaggi a caso, cioè è successo solo per caso, no? Che ci siamo imbattuti in problemi del genere. Cioè i linguaggi fuori e re che abbiamo visto finora hanno tutti questa peculiarità. Sono linguaggi per i quali noi siamo in grado di rispondere no in tempo finito. Quindi questi linguaggi re e questi linguaggi fuori re hanno una peculiarità, sono decidibili re a metà. quelli nel re rispondiamo sì in tempo finito, ma non diamo garanzie sul no. I linguaggi che abbiamo visto fuori re finora sono linguaggi per i quali rispondiamo no in tempo finito, ok? E non diamo garanzie sul sì. Ad esempio, prendiamo il linguaggio complemento di halt, no? È vero che questa macchina non si ferma sulla su quest su una data stringa? Riesco a rispondere no in tempo finito perché basta che io la simulo, vedo che si ferma e dico "No, guarda, non è una di quelle che non si ferma, è una di quelle che si ferma". Quindi no. È chiaro? Quindi i linguaggi che abbiamo visto finora sono dei linguaggi particolari che stanno in re e i loro complementi sono linguaggi per i quali abbiamo che riusciamo a rispondere no in tempo finito. Quindi noi possiamo definire e questa è una cosa che non trovate su almeno sui libri che vi ho segnalato perché è un concetto un po' più sofisticato. Noi possiamo definire un'altra classe di decidibilità che va a raccogliere appunto i linguaggi per i quali rispondiamo no in tempo finito. Ok? Quindi che cosa avremo? Qui abbiamo R e qui abbiamo co re. Cos'è la classe con R? Esattamente in C e ci stanno i linguaggi i cui complementi stanno in R. Al centro c'è R. Come? Al centro c'è R. Al centro c'è R. Ora vediamo. Ok. Quindi i problemi che abbiamo visto finora son problemi un po' Ok, questo mi serve spazio, ve la riscrivo perché non voglio che si sovrappongano. Quindi abbiamo questo qua, qua abbiamo R e qua abbiamo C. Ok? Quindi i linguaggi che abbiamo visto sono per esempio LU sta qui, ma lu segnato sta qui, LNE sta qui, ma L sta qui. Halt, che succidiamo? L eh non rompe le balle. Halt stai. Ma alt segnato sta qui. Hal sta qui, ma halt segnato sta qui. Poi abbiamo LD, ma dai, LD segnato sta qua e LD sta qui. Ok, chiaro? Quindi i linguaggi che abbiamo visto finora sono linguaggi indecidibili ma un po' sbilanciati, cioè che noi siamo in grado di rispondere o sì o no in tempo finito. Per i linguaggi nel re rispondiamo sì in tempo finito e non diamo garanzie sul no. Per i linguaggi in co e re siamo in grado di rispondere no in tempo finito. Ok? e eh non siamo in grado di rispondere sì in tempo finito, però sono linguaggi tra virgolette sbilanciati, cioè annullato facile, tra virgolette. Ok? Adesso se ripensiamo assieme al tiling, il tiling, il problema del tiling che abbiamo dimostrato essere indecidibile dove sta? In re o in co? CR. Ok, quindi sta fuori R. La dimostrazione che abbiamo fatto prima è che sta fuori R. Quella riduzione ci dimostra solo che sta fuori fuori R. Però per dimostrare che è in co noi dovremmo essere in grado di dimostrare no? Cioè di rispondere no in tempo finito. Qual è l'intuizione per rispondere no in tempo finito sulle stanze del tiling? Se mi arriva un'istanza di tiling e quella è un'istanza no, significa che io mi posso cervellare come voglio un modo di piastrelle non lo troverò mai. Ok? abbiamo un numero finito di tipi di piastrelle, il che significa che se noi facciamo un'esplorazione in backtracking di tutte le possibilità, quest'albero di esplorazione è finito. A un certo punto lo vedremo tutto e quando lo esploriamo tutto e non abbiamo raggiunto un tassellamento completo, lì rispondiamo no, non è possibile. Quindi questa è la ragione per cui siamo in grado di rispondere no in tempo finito sulle stanze no del tiling. Ok? Quindi tiling sta qua. Ok. Quindi again è un altro problema che ha un lato facile. Ci siamo? Ok. Il complemento il complemento sarà in r. Ok. Complemento del tiling lo mettiamo qua. Tiling soprasegnato. Ok. Allora, la nostra domanda è questa: ma ci sta un problema qua? Ok? Esistono problemi per i quali non siamo in grado di dare garanzie né su risposte sì né su risposte no. Cioè esistono problemi talmente tosti che non siamo in grado di dire niente. Questo è l'idea. Ok? Ripeto, finora per semplicemente per come abbiamo ragionato, ci siamo andati a impattare contro problemi per i quali o è facile o è possibile dire sì o è possibile dire di no con garanzia. Ok? La domanda è: esistono problemi che non stanno né in RE né in coer? Andremo a vedere oggi un problema che sta lì fuori. Ok, ma per farlo ci servono un po' di proprietà. Ok. Ma sì, si può fare. Sì, sì, sì, sì. È carina anche quella che dice lei. Sì. Ok. Allora, prima proprietà ah prima proprietà che ci serve. Ok, teorema. Vediamo di andare veloce. Fiorem, R è diverso da R. Vogliamo prima capire che relazione c'è fra queste classi R ed R. Allora, primo risultato R è differente da co perché esiste out per perché esistono problemi che stanno in R e non in R e quindi per forza questo deve essere vero. Ok? Secondo teorema, quello era un lemmino che ci serve dopo, eh, che R è diverso da R. Abbiamo che co intersecato re è uguale a R. Quindi quello che dimostriamo è che questa cosa è esattamente R. Per dimostrare questa cosa noi dobbiamo dimostrare due cose che co re intersecato re è un sottinieme di R e che R è un sottinsieme dell'intersezione di quei due. Cioè dobbiamo mostrare che si contengono a vicenda. In questo modo noi otteniamo che i due sono uguali. Quindi primo pezzo co re intersezione re e un sottoinsieme di R. Quindi vogliamo dimostrare questo. Mh mh. Si fa così, sia L un linguaggio tale che L appartiene a R intersecato R. Noi dimostreremo che questo linguaggio L sta in R. Ok? Siccome L appartiene a co re per definizione di co avremo che il complemento di L è in R. È in R. L complementato appartiene R. Dal fatto che L appartiene a R e L soprassegnato appartiene a R. Quindi dal fatto che L e il suo complemento stanno in R, allora L sta in R. segue che L appartiene a R e questo ci dimostra che tutti i linguaggi ci dimostra questa cosa qua, tutti i linguaggi che stanno in questa intersezione devono stare anche qua dentro. Ok? Questo non basta a dimostrare che i due sono uguali. Dobbiamo dimostrare ora quest'altra cosa. R è un sottoinsieme di co intersecato R. Sia L un linguaggio appartenente ad R. Se L appartiene ad R, allora il suo complemento appartiene ad R. Quindi cosa avrò? Avrò una macchina che è in grado di dare garanzia di risposta sia su sì che su no. E questo ci dimostra che L sia nella parte re che nella parte OR. Ok? Tutto qua. Eh. Ah! Ah, da Sì. Ok. Alright. Quindi cosa abbiamo? La prima proprietà ci dice che questi pezzi sono scissi, cioè c'è una distanza qui e che l'intersezione di questi due è esattamente R. Ok. Altro problema. Altro eh risultato. Teorema stiamo facendo perché è interessante notare come su queste classi noi siamo in grado di dire varie cose che sono separate, che la loro intersezione è esattamente quella eccetera. scopriremo che su delle classi di complessità invece non siamo in grado di dire niente, sono tutti risultati che ha detto probabilmente separato, probabilmente l'intersezione, cioè su per quanto riguarda la complessità la nostra conoscenza è veramente limitata. Per la calcolabilità invece siamo in grado di dire queste cose. Quindi teorema re è diverso da re. dimostrazione. Supponiamo per assurdo che co sia uguale ad R. Poiché C intersecato R è uguale ad R. Per il teorema di prima, se fosse vero che co re è uguale ad re, io avrei avremmo re = R. Ma ciò è impossibile per il teorema di prima. Ok? Quindi questi tre risultati ci dicono alcune cose interessanti su queste due classi. Uno, che queste due classi sono distinte, cioè quindi non collassano sulla stessa cosa, che sono sganciate, sono distinte da R e che la loro intersezione è esattamente R. Ok? Chiaro per tutti? Alri, vogliamo ora andare a caratterizzare un problema come questo qui, ok? Un problema che non sta né in re né in coccia, quindi un problema talmente tosto sulle quali non abbiamo garanzie, non possiamo dare garanzie né di rispondere sì né di rispondere no. Per fare questa cosa qua, ovviamente ci serviranno delle riduzioni perché così procediamo e ne dovremo vedere un paio. Ok? Adesso vi dico perché. Allora, ci serve una proprietà aggiuntiva che è un altro teorema che non dimostriamo, ma è semplicissimo da dimostrare perché è simile a una cosa che abbiamo già visto che è questo qua. Siano A e B due linguaggi tali che A si riduce a B. Ok? Se A non appartiene a C e re, allora B non appartiene a C e R. Ok? Eh, is it? Diamond. E se da u se A non appartiene a R, allora B non appartiene a co dimostrazione è molto simile a quella là che abbiamo già visto qualche lezione fa. Se A non appartiene a R, allora nemmeno B appartiene. Se se non appartiene a R, allora B. Nemmeno B appartiene R. Perché se così non fosse vero, cioè se fosse B se B appartenesse ad re, allora noi potremmo rispondere no in tempo finito su A, utilizzando una riduzione, una trasformazione. Questo è il trucco. Quindi ci serve sto teorema. Ok? Allora, noi consideriamo questo problema qui di cui siamo alla ricerca è questo qua. Halt per ogni lo possiamo chiamare che cos'è? è l'insieme delle macchine di Touring M tali per cui per ogni stringa W M si arresta su W. Ok? Ripeto, halt per ogni è l'insieme delle macchine di touring che da datogli qualsiasi input, questa macchina si ferma. Intuitivamente, perché non è in R questa cosa? Perché non è in R questo linguaggio? Perché dovrei controllare tutte le string Perché dovremmo trovare provare tutte le stringhe. Quante sono? Sono infinite. Ok. Perché non sta in co? è questo linguaggio perché la macchina va avanti all'impito. Perché la macchina va avanti all'infinito. Quindi questo linguaggio sembra essere candidato a non stare né in re né in co re, cioè a essere un problema sostanzialmente più complicato di quelli che abbiamo visto finora, ok? Un problema sulle quali non possiamo dare né garanzia di risposta sì né garanzia di risposta no. Ok? Allora, per riuscire a dimostrare, quindi per dimostrare che uno halt per ogni non appartiene a re e du che halt per ogni non appartiene A co re ci servono due riduzioni, una che ci tira fuori halt da R, quindi una riduzione, una riduzione che tolga halt per ogni da R e un'altra una che tolga halt per ogni da or. Ok? Siccome dobbiamo dimostrare che alt per ogni non sta né in R né in co ci servono due riduzioni, una che la butta fuori da R e una che la butti fuori da co ok? per ottenere 1. Quindi per ottenere fa ridurremo alt il negato di halt epsil verso halt per ogni perché il negato di halt e non sta in R. Guardate qua, il negato di halt e sta in co ma non sta in r. Quindi se riduciamo halt ad alt * ogni noi spingiamo halt per ogni fuori re. Per l'altro lato noi ridurremo halt ep che sta in r ma non in co ridurremo questo a lui in maniera tale che halt per ogni non sta nemmeno in co? Lo scriviamo per ottenere 2. Cosa faremo? Riduciamo halt ep verso halt per ogni. Ok? È chiaro cosa andremo a fare? Quindi il nostro obiettivo è dimostrare che halt per ogni non sta né in r né in coerre. Per dimostrare questa cosa ci servono due riduzioni, uno che la lo butta fuori da R e uno che lo butta fuori da co? Focalizziamoci sulla prima, no, sulla seconda. Partiamo da due perché è più facile. Quindi ovviamente anche il complementare di è fuori tutto. È fuori tutto. Sì, perché se fosse in re o in co l'altro andrebbe a parare nell'altra classe, ok? Quindi il complemento di halt per ogni sta da un'altra parte. Adesso esiste tutta una gerarchia di classi che andrebbero a categorizzare questi problemi strani, però è una cosa sofisticatissima, lasciamo stare. Ok? Però volevo mostrarvi che ci stanno problemi tostarelli che hanno sta faccia qua. Ok, partiamo da due, cioè da dimostrare che eh halt non halt per ogni non sta in co e facciamo questa riduzione da halt verso halt per ogni. Ok? Che cos'è un input per alt? una macchina è una macchina che ha la particolarità di arrestarsi sulla stringa vuota. Ok? Cos'è un input per halt per ogni? Una macchina. Una macchina la chiamiamo N per distinguerla che è ottenuta come il trasformato di m secondo una funzione f. Che caratteristica ha questa n se è un'istanza s di halt per ogni si ferma su tutte le stringhe. Non ci importa se dice sì o no, si deve arrestare. Può può dire quello che vuole, l'importante è che si fermi. Ok. Ok. Vi propongo questa riduzione. E dai. Ah, ok. Quindi abbiamo m, la funzione di transizione di Mine data impasto ad f. F tira fuori una macchina M la cui funzione di transizione codifica questa cosa qua. Quindi otteniamo una F che è un trasformato di M, una N che è un trasformato di M secondo F. Allora, questa macchina M che fa? Prendi input una stringa W, se ne frega, non fa assolutamente niente. E che cosa fa? simola su m. Ok? Se m su risponde sì, rispondiamo di sì. Se m su risponde no, rispondiamo di no. Se M su luppa, luppiamo assieme a lei. Ok? Chiaro? Molto semplice questa cosa qua. Va bene? Il passaggio è la l'altra riduzione. L'altra riduzione è più sofisticata. Alri? Dobbiamo dimostrare che effettivamente questa funzione f trasformi istanze s di halt ep verso istanze sì di halt per ogni e istanze no di halt ep su istanze no di halt per ogni. Ok? Primo verso della riduzione della della dimostrazione. Dimostriamo che se partiamo da una macchina M che si arresta su stringa vuota, allora N si arresta su tutto. Ok? abbastanza semplice, siccome la macchina N. Ok, quindi supponiamo che M appartenga ad halt da cui m si arresta su Ok? Quindi, siccome n ignora completamente il proprio input e quello che fa è simulare m su, la macchina n su tutte le stringhe w darà sempre la stessa risposta, la risposta di m su noi non ci importa cosa sia questa risposta, a noi quello che ci importa è che la macchina n si arresta sempre. Ok? È chiaro questo passaggio? da cui m si arresta su epil. Sì, scrivo un po' a cavoli, poi specialmente con questo aggcino. Ok, quindi se m si arresta su darà una risposta. A noi questa risposta non ci importa, però quello che ci importa è che n a un certo punto si ferma e dice qualcosa. Ok? segue che n appartiene ad halt per ogni. Ok? Quindi m appartiene ad alt, n appartiene ad alt per ogni istanza sì, istanza sì. Supponiamo invece che M non appartenga ad halt EP, da cui M non si arresta su EP. Che cosa possiamo dire di n? Che n siccome ignora il proprio input e non fa altro che simulare m su, se m su luppa m n lupperà per tutti i propri input, non si ferma mai. Ok? Gli possiamo dare qualsiasi cosa in input. La macchina N, siccome ignora il proprio input e simola M su lpererà come M su. Quindi in questo caso la macchina N arresta. Chiaro? Segue. N appartiene halt per ogni, quindi istanza no. Istanza no. Ok, questa era la parte di riduzione facile. Ok, adesso dobbiamo vedere l'altra che è più complicata. Ok, quindi in un quarto d'ora ce la dovremmo fare. Chiaro? Per tutti? Questo ci dimostra che cosa? Che halt e non sta in corr. Ok. Questo segue che halt per ogni non appartiene a co e re. Sì. Ok. Eh, caso 1 che era quello ah caso 1 dobbiamo ridurre il negato di alt per ogni. Ok? Cos'è un'istanza per altta e? No, una macchina M. Cos'è un'istanza per alt per ogni una macchina che sarà ottenuta come un trasformato secondo una funzione F. Ok? Ci dobbiamo inventare sto F qua. Ok? Allora, vi faccio il disegno prima che la penna mi molli. Allora, questa cosa è un po' più complicata. Adesso ve la faccio. Ecco qua questa bella macchinona N che FDM. Allora, come funziona questa macchina? prende in input W e ci fa una cosa molto particolare. Usa la lunghezza di W come un contatore. E adesso vi spiego a quale fine. Poi c'ha m con input se m su si si ferma, allora noi luppiamo. Se m su non si ferma, allora noi ci arrestiamo, diamo una risposta al caso, cioè basta che ci fermiamo. Ok, non è ancora finito. Ok, se non si ferma si ferma. Se la simulazione di M su ha raggiunto adesso, adesso vi dico, ok, ve la spiego meglio, eh. Prendiamo in input w che cosa facciamo? Vedete, adesso vi disegno un bel cronometro, ok? Non sapevo come disegnarvelo, ok? Che è la lunghezza di W. Ok, ho scritto tutto, quindi pure se mi molla la penna, poi a voce possiamo procedere. Cosa fa N? Prende W input e simula M su per un numero di passi pari alla lunghezza di W. Quindi se W è lunga 10, Nimulerà 10 passi di M su EP. Se W è lunga 25, Nimulerà M su per 25 passi. Se all'interno di questo time bound m la simulazione di m su ha raggiunto una configurazione finale, non importa se accettante o meno, ha raggiunto una configurazione finale, cioè se all'interno di questa simulazione bounded m si è arrestata, la macchina n deliberatamente Lupa inizia a girare all'infinito. Se in questa simulazione limitata ha un numero di passi che è la lunghezza di W. M non ha raggiunto una configurazione finale, non importa eh se accettante o meno, non ha raggiunto una configurazione finale, allora N si ferma. Ok? Può rispondere sì, può rispondere no, non importa, si ferma. È chiaro? Quindi N che fa? Usa W come un cronometro. Simula M su per un numero di passi pari alla lunghezza di W. Se in questa simulazione limitata m ha raggiunto una configurazione finale, n inizia a girare a vuoto. Se M non ha raggiunto una configurazione finale, allora N si ferma e ci dice qualcosa. Sì, no? Boh, si ferma. Ok, chiaro? È chiaro come funziona N? Perché dobbiamo capire sto concetto della Sì, prego. Ehm M ogni volta che sostanzialmente faccio un'interazione del cronometro faccio ripartire l'intera esecuzione sull'EP o dal No, io no. Io eseguo m su e lo devo eseguire per un numero di passi parall. Ah, quindi è come la macchina universale, no? Solo che ogni volta che simuliamo uno step ce lo segniamo, ok? Un carattere di W se ne va. Quando finiscono io vado a guardare che succede. Se M nel frattempo aveva raggiunto una configurazione finale, inizia a luppare. Se M non aveva raggiunto una configurazione finale, allora mi fermo. N si ferma. Ok? Chiaro come funzione N? Sì. Eh, una cosa che non ho capito e quindi eh viene eseguita m N menda passi con NAR all lunghezza di W. Sì. Sta macchina come S della macchina. Non ho capito. Mh. Scep Sì. E esce. Si ferma. Si ferma. Ok. Ok. Guys, abbiamo 7 minuti. Primo verso, supponiamo che m appartiene a halt soprasegnato, quindi supponiamo che m appartenga al complemento di halt epil da cui m non si arresta. su epil. Ok. Ok. Guardate questa cosa qua. Se M State State bene a sentire questa cosa. m non si arresta su vuol dire che qualsiasi sia il time bound che consideriamo sulla simulazione m su in quel numero finito di passi non avrà raggiunto una configurazione finale. Chiaro? Di conseguenza, noi possiamo dare in input ad n una stringa w di qualsiasi lunghezza e quindi una qualsiasi stringa. La simulazione di m su, siccome m non si ferma su, non arriverà mai una configurazione finale, quindi la macchina N si arresta. si arresta su qualsiasi stringa perché qualsiasi stringa non darà mai un bound sufficientemente ampio da vedere la macchina M che si arresta su EP. Ok? È chiaro? segue n appartiene ad halt per ogni altro caso, supponiamo che m non appartenga ad halt da cui m si arresta. su. Chiaro? Bene. Se m si arresta su epil lo farà in tempo finito. No, diciamo che si arresta in t passi. In un tempo t passi. M si arresta. su epil in t passi. Ok? Guardate la definizione della macchina. Se la stringa W ha una lunghezza almeno T, la simulazione arriverà alla configurazione finale, cioè quindi se W è sufficientemente lunga, N vedrà e N vedrà M arrestarsi e quindi su quelle stringhe lunghe N luppa. Se la stringa W input è troppo corta da non permettere a nere che m si arresta su EP, allora N si arresterà su quelle stringhe. Ok? Quindi avremo che n luppa su stringhe lunghe e si ferma su stringhe corte. Quindi non è vero che n si arresta su tutto. Segue che n non appartiene ad alt per ogni. È chiaro questo secondo pezzo? La discriminante di questo secondo pezzo è che poiché m si arresta su, esiste una soglia oltre la quale la sua la simulazione di m su n m su permetterà ad n di vedere che si è arrivati alla fine. Quindi segue che m sorry n si arresta su stringhe w di lunghezza inferiore a T ed m luppa su stringhe w di lunghez al- ti. N appartiene ad alt. per ogni chiaro? Ok, ce l'abbiamo fatta e con questo chiudiamo per oggi. Faremo un'ultima lezione, credo, su calcolabilità. Ci manca ancora un risultato, dopodiché chiudiamo e inizieremo la parte di complessità. Ok, grazie mille. Buon pranzo.