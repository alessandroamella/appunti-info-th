Ok, iniziamo. [Musica] [Musica] Ok. Com'è che vanno i concetti della scorsa volta? Chiari? Avete capito? ci nelle prossime cinque selezioni ci andiamo un po' a impognare su cose un pelino più implicate, ok? però spero di polvere in maniera tale che risultino comprensibili eh ad ogni modo. Quindi la scorsa volta abbiamo introdotto la macchina universale. Abbiamo visto che la macchina universale è in grado di simulare altre macchine di turni, quindi è sostanzialmente una macchina programmabile. Eh, uno di voi mi aveva chiesto perché non abbiamo visto la funzione di transizione della macchina universale. Ok, allora di la mia risposta è stata perché la macchina è un po' intrigata, basta che un'idea di funzioni funzionerà. In realtà non è proprio così perché poi ci ho pensato. Se la progettata è non deterministica, una macchina universale secondo me in 30-40 stati la la scrivete, cioè se non sono 40 saranno 50, però è per dire che una macchina di quel tipo ha un numero di di stati che è nell'ordine delle decine, non nell'ordine delle centinaia. Cioè è una cosa che si riesce a fare, se vi ci mettete in un'oretta, due è una cosa che si riesce a fare, però 2 ore sprecarle a mostrare una macchina del genere non mi sembra nel caso. Ci concentriamo su altro. Al sabe scrivere come non sa scrivere autobili macchina, cioè che mi scrive una macchina universale noamente cioè è inutile. Vi chiedero cose del tipo di teorema da Italia se ci riuscite bene. Me li ricordo che quando ho iniziato a, cioè quando ero un giovanissimo dottorando, ero assistente del corso di informatica teorica e davamo cose di questo tipo e c'erano alcune dimostrazioni che erano dei trip nell'acido, non si capiva veramente niente. Ok? Quindi mi aspetterei che riusciate a comporre un po' di cose, no? Per renderle più o meno più o meno intelligibili. Ok? Eh, alright. Quindi dove siamo? Abbiamo fatto macchina universale e poi abbiamo abbiamo detto "Ma esiste un nuovo linguaggio che non sia di posizione numerabile?" e ci siamo inventati questa cosa, il linguaggio diagonale che è ricordo, lo riscriviamo qua velocemente LD è l'insieme dei codici di macchine di Touring M, tale che m con i non accetta la propria stessa codifica. Ok? Questo era il linguaggio diagonale. Abbiamo detto che LD un risultato che abbiamo dato è che non appartiene ad re. La dimostrazione era tramite una diagonalizzazione, una tecnica dovuta al cantor. Quindi quello ci dice che non esiste e non esisterà un algoritmo in grado un algoritmo re che sia in grado di rispondere a questo problema. Ok? Adesso, ehm, noi abbiamo giusto un appunto prima di passare al resto che da questo risultato è abbastanza evidente. Siccome LD non appartiene ad RE, allora LD non appartiene nemmeno a R perché R sta dentro il re, quindi sta fuori, ok? Perché oggi ci serve questa cosa che LD non appartiene a R. Ok? e buttiamoci nel vivo della della lezione di oggi. Definiamo il linguaggio universale, ok? Che è una piccola variante di quello che abbiamo già visto la scorsa volta. Allora, il linguaggio universale è l'insieme delle coppie macchina stringa tale che la macchina M accetta la stringa W. Ok? Non l'avevamo visto sotto questo formato. La scorsa volta abbiamo parlato della macchina universale, abbiamo parlato che la macchina universale è in grado di simulare le altre macchine di Touring. Oggi lo introduciamo proprio come linguaggio. Il linguaggio universale lo definiamo come l'insieme delle coppie di stringhe MW tale che se gli diamo impasto W M si ferma e dice di sì. Ok? Questo è il linguaggio universale. Cos'è il simbolo M? Cos'è quel simbolo in mezzo? Questo è questo qua. Lo scrivo più grande. Ta ta ta che significa accetta. Models. Modella. Si usa in varie parti della della logica. Noi qua lo usiamo per dire che m accetta w. Ok? Allora, domanda per voi. Lu appartiene alle re? Yeah. No. Sì. Sì. No. Come on, guys. Sì. No. Chi è per il no? Ok. Ce ne stanno un po'. Chi è per il no? Ok. Chi è per il sì? Ok. Sì. R. Perché? Perché le posso leggerli sempre e basta. Qual è la definizione? Un linguaggio sta in re. Guys, dobbiamo ritornare sempre alle definizioni perché senò poi ci perdiamo. Eh, un linguaggio sta in re se se Prego. Può accettare un tempo infinito. Chi può accettare in un tempo infinito? Può accettare più preciso. Un linguaggio L sta in Rx. Esiste una macchina di in grado di accettarlo. In grado di accettare chi? Quale linguaggio? L. Ok. Un linguaggio L sta dentro il re se esiste una macchina di doing in grado di accettare L. Ok? Questa è la definizione di appartenenza del re di un linguaggio. Domanda. È vero o no che lu appartiene ad re? Sì, perché perché esiste la macchina universale. Perché esiste la macchina universale che lo accetta. Eh, questo è facile, eh. Ok, quindi lu appartiene ad RE perché è una macchina che l'accetta chi è? È la macchina universale. Ok? Quindi la macchina universale è per noi la prova che lu è un linguaggio in re. Ok? Adesso, secondo voi questo linguaggio, quello che ci chiediamo ora, LU appartiene o no? A R? Qual è la definizione di appartenenza a L un linguaggio? A R di un linguaggio linguaggio L appartene a R? decidere se esiste una macchina di Turing che è in grado di decidere il linguaggio. Ok, per decidere intendiamo che la macchina risponda sempre sì e sempre no correttamente su tutte le stanze che gli arrivano sottomano. Ok? Allora, la domanda è: LU appartiene a R o no? Pensateci un attimino e poi lo vediamo assieme. Sì, sì, che per come abbiamo progettato MU, abbiamo fatto in modo che ogni stringa che non rappresentasse una macchina di touring rappresentasse uno stato non accettante. Di conseguenza io non accetto. Sì. Eh, ok, più o meno. Ma supponiamo di avere in input una macchina codificata per bene. Ok? Voi vi ricordate come funziona la macchina universale? La macchina universale è una macchina che passo passo simula il comportamento della macchina che gli abbiamo passato un input, no, sulla certa stream. Ok? Allora, supponiamo di mandargli input una una codifica funzionante di una macchina M e di una stringa W. Ok? Quindi la macchina universale simulando M su W farà passo passo quello. Ok? Passo passo. Benissimo. Supponiamo che M non si arresti su W. La macchina universale che fa? Non si arresta. Quindi il linguaggio intuitivamente può essere in R? No. Questa però è un'intuizione del perché il linguaggio non è in R. Cioè l'intuizione che noi abbiamo è che il linguaggio non sia in R, perché se noi lo simuliamo in quel modo e la macchina che stiamo simulando non si arresta, il simulante non si arresterà e non si fermerà per dire "Ehi, la risposta è no, ok? Quello gli va appresso, non si ferma mai." Ok, quindi da questo punto di vista intuitivamente L1 non sta in R. Ma questo dimostra che L1 non sta in R o dimostra che la macchina, come ce la siamo inventata, non è una macchina che garantisce risposta? Chiara la domanda? Cioè la macchina che ci siamo inventati la scorsa volta è una macchina che su istanze del genere c'ha un po' di problemi. Ok? Allora, la questione è e questo ci garantisce che il linguaggio non sia in R oppure semplicemente ci dice che quella macchina non dà garanzie di arresto? Sappiamo solo che la nostra macchina universale non è in grado di Sì. Quello che noi sappiamo è che quella specifica macchina che abbiamo chiamato la macchina universale non dà garanzie d'arresto su risposta no. Ma questo non ci dice nulla riguardo al fatto se il linguaggio universale sia in R o meno, perché magari esiste una macchina più fulba di quella che ci siamo inventati che è in grado di rispondere no in tempo finito. Ok? Allora, quello che vi dico è che no, non è così. Non ci sta nessuna macchina che è in grado di rispondere in tempo finito su Lu, però questo richiede una dimostrazione. Ok? Quindi ci dobbiamo adesso inventare un modo per dimostrare che una tale macchina non ci sta proprio. Sì, potremmo fare in modo che la macchina che utilizziamo sia una macchina che accetta la stringa seifica un termine che che termina sempre. Questo è un problema ancora più difficile, cioè forse è una cosa che sto decidendo se farvela vedere o meno nelle prossime lezioni, cioè decidere cè una macchina che riceviamo in input è una macchina che si arresta su tutte le stringhe è un problema catastroficamente complicato, però questo mo decido se farvelo vedere o meno perché ci richiederà 2 ore. ha riconduto al problema dell'alternato. Mh, no, la questione è in quel modo, cioè mo la nostra macchina non si arresta. Se vogliamo dimostrare che Lu non ammette proprio una macchina che dia garanzia ad arresto, allora ci dobbiamo inventare una dimostrazione. Ok? E allora è quello che dimostriamo ora. Teorema lu non appartiene ad R. Voi che vedete un attimo, mi giro qua, poi vedete? Ok, dimostrazione. Ok. Supponiamo, allora, noi vogliamo dimostrare che Lu non appartenga ad R. Facciamo una dimostrazione per assurdo. Supponiamo per assurdo supponiamo per assurdo che Lu appartenga ad R. Ok, voi siete familiar con le dimostrazioni per assurdo, no? Ne avevamo vista una. Ok, quindi adesso dobbiamo far vedere che se portiamo avanti le conseguenze di questa assunzione arriviamo a una contraddizione e che quindi l'assunzione è sbagliata. Ok? Quindi supponiamo per assurdo che lu appartenga a ar. Ok? Quindi, per le proprietà dei linguaggi che abbiamo visto la scorsa volta, se Luu appartiene a R, allora lu segnato appartiene a R, cioè il complemento di Lu appartiene a R per la proprietà del linguaggi, ok? Che abbiamo visto l'altra volta. Se LU segnato appartiene a R, allora esiste una macchina, chiamiamola così, mu segnato che decide LU segnato. Ok? Però se scrivo tutto andiamo lentissime. Ok? Supponiamo per assurdo che Lu appartengi ad R. Se lu appartiene a R, allora appartiene a R anche il suo complemento. Se il complemento di L appartiene a R, cioè è decidibile, allora ci sta una macchina, chiamiamola MU segnato. Non sappiamo chi chi sia, però è garantita la sua esistenza dal fatto che Lu segnato lo stiamo assumendo in R, eh che ci decide ci decide lu segnato. Siccome mu segnato MU grado di decidere LU segnato, allora MU segnato dà sempre garanzia di arresto e risposta corretta. Ok? Dato che segnato, come? Dato che mu segnato decide lu segnato, allora mu segnato si arresta sempre e dà risposta corretta per L segnato, cioè è sempre in grado di dire sì e sempre in grado di dire no correttamente. Ok? Cose strane non ne fa. Consideriamo questa macchina qua. Ci costruiamo una macchina M prim, ok? M primo, dove all'interno facciamo questa cosa qua. Riceviamo una stringa W da fuori. La macchina M'O come prima cosa prende la stringa W e ne fa doppia copia. Ok? Quindi ottiene sulla sul nastro di input m11 1 W in cui M e W sono la stessa stringa. Prima dei 31 lo interpretiamo come il codice di una macchina, dopo facciamo così, eh w V con i e qua abbiamo m con i w con i ok? Cioè quindi è proprio la stessa stringa. La prendiamo, ci mettiamo tre uni, la ricopriamo, ok? Dopodiché questa cosa m' la dà impasto ad m sovrasegnato, cioè in m' infiliamo la funzione di transizione di mu soprasegnato. È chiaro? Quindi questa macchina M'O che fa? Riceve questa stringa w con E. La prima cosa che fa è che la replica, quindi prende doppia v con ci mette 31 e poi ci schiaffa nuovamente doppia bucon. Ok. Dopodiché la funzione di transizione di m' diventa la stessa di mu segnato, che non sappiamo quale sia, però sappiamo che esiste. Quindi noi la possiamo ficcare nella funzione di transizione m di m' ok? Allora, e poi m' si comporta così: se mu segnato risponde di sì, allora m' risponde di sì. Se mu segnato risponde di no, allora M' risponde di no. Chiaro? È chiaro per tutti che una macchina M' così può essere progettata nel momento in cui assumiamo l'esistenza di me segnato. Si tratta di appiccicarci una parte iniziale in cui facciamo doppia copia della string input, dopodiché parte la subroin che che codifica il funzionamento di meu soprasegnato. Ok? Quindi questa macchina M' esiste nel momento in cui mu soprasegnato esiste. Ok? Ora quello che ora noi ci chiediamo è qual è il linguaggio riconosciuto da M prim'. Quindi questa è la domanda che ci facciamo. [Musica] Qual è il linguaggio? riconosciuto da M', quindi ci chiediamo chi sia L M'. Ok? Una cosa, ma nella copia mettiamo email o mettiamo qui? Ma si vede un po' male, ve lo scrivo mi 1 do buc che per quello che ci siamo detti mi e buc sono la stessa striga, eh, solo che la prima la interpretiamo come un codice di una macchinatura. l'altra la interpretiamo con una stringa binaria. Sono in interpretazioni. Sì, la domanda stupida, ma nel test domanda è stupida. La ringrazio la nel test scritto possiamo integrare dimostrazione con disegni oppure vuole tutto Sì, sì, sì. Però, cioè, poi dovete spiegare spiegare. Sì, sì, sì, sì, assolutamente. È ovvio che dice "Ah, abbiamo questa macchina", fa questo e poi non mi commenta in alcun modo la funzione di transizione, cioè è un po' un po' così, è un po' appesa. Invece qua ci siamo detti che questo schema ci rappresenta questa macchina. La macchina M' prende W conci impacchia 31, la riscrive. Dopodiché la sua funzione di transizione è la stessa di MU soprasegnato. Se Mus soprasegnato risponde sì, la macchina M' risponde sì. Se M soprasegnato risponde no. La macchina M' risponde no. Ok. Sì. Eh, avrei una domanda su quelle che sono le implicazioni eh di assunto quando noi arrivamo a ancora non ci siamo arrivati al alla contraddizione. Sì, sì, però c volevo chiedere una cosa perché non riesco a capire questo passaggio intermedi e quando noi arriviamo a dire che esiste una lu segnato, che riconosce le segnato, sì. Non si può affermare che LU segnato sia LD per come avevamo definito ieri, no? Perché LD non ha input coppie di strega. Quando noi pensiamo ai linguaggi o ai problemi, voi tre domande vi dovete porre sempre. Qual è l'input, qual è l'output? Qual è la relazione tra l'input e l'output? Ok? Qual è l'input per l? È una macchina di Turing, più precisamente è una stringa che codifica una macchina di Turing. Questo è, tra virgolette l'inputa, LD. Qual è il l'input del problema e le segnato? È una coppia di stringhe macchina che in cui la prima codifica una macchina e la seconda è una stringa. Quindi i due linguaggi sono diversi, non sono la stessa cosa. Ok? Quindi quando ragionate come riconduco un linguaggio ad altro che poi lo vedremo domani. Domani introdurremo il concetto delle riduzioni fra linguaggi e lì si deve essere sempre molto precisi, senò ci perdiamo. Quali sono le stanze del linguaggio, quali sono le stanze sì, quali sono le stanze no. Ok? In maniera tale che quando mappiamo un linguaggio su un altro riusciamo a fare questa cosa, senò ci perdiamo per strada. Quindi ogni volta che pensate a un linguaggio e alle sue possibili relazioni con altri, vi dovete sempre chiedere come sono caratterizzate le istanze di quel linguaggio, cioè che faccia hanno le stringhe di quel linguaggio, che faccia hanno le stringhe sì, che faccia hanno le stringhe no. Ok? Quindi non possiamo dire che lu soprassegnato LD perché le stringhe dei due linguaggi hanno facce differenti. Una è una stringa, l'altra sono coppie di stringhe, ok? che poi ovviamente la coppia di stringhe viene ricodificata in una stringa soltanto, no? Però semanticamente gli stiamo dando un significato diverso, è chiaro? Ok? Alri. Ah! Quindi siamo arrivati a chiederci quale sia il linguaggio, ok? che viene riconosciuto da m'. Ok? Ragioniamo per casi. Supponiamo che m' risponda di sì. Che cosa possiamo concludere? Dobbiamo percorrere il grafo il grafico al contrario. Supponiamo che m M m M m' abbia risposto di sì. Se ha risposto di sì m' cosa lo ha causato? La macchina simulata ha accettato la la macchina M1 soprasegnato ha risposto di sì. Ok, dobbiamo dobbiamo però ripercorrerlo al contrario. Evitiamo di fare salti così evitiamo di sbagliare. Allora, supponiamo che m' abbia risposto di sì, ok? Se m' ha risposto di sì, allora mu sovprasegnato ha risposto di sì. Ma su cosa la stavamo eseguendo mu soprasegnato? Sto andando indietro, eh, sto andando indietro nel grafico. Su cosa eseguiva mu soprasegnato? M con. Ok. Che linguaggio decide mu soprasegnato? mh lu soprasegnato. Lu soprasegnato. Quindi se mu sovrasegnato risponde di sì sulla coppia mi w con i, allora vuol dire che m con i che fa su w con i? Lo accetta o non lo accetta? Attenzione eh, che qua ci stiamo spostando di livello. Ricapitoliamo. La macchina MU soprasegnato che decide il linguaggio LU soprasegnato, che è il complemento di Lu, riceve in input una coppia MV con i. La ficchiamo dentro questa macchina. Questa macchina fa quello che deve fare, finisce e dice di sì. Allora, che informazione possiamo ricavare sulla relazione tra MI e Wi? M non accetta W che MI non accetta W con i Sì. Quindi se la macchina M' risponde di sì, allora M con i non accetta w con i. È chiaro? Supponiamo che la macchina N M primo risponde di no. Ok. Ripercoliamo il grafo al contrario. Il grafico al contrario. Supponiamo che la macchina M prima abbia risposto di no. Ciò implica che abbiamo risposto di no perché mu sovprnato stava rispondendo di no. Qual era l'input soprasegnato? la coppia mi w. Quindi se mu soprasegnato su input mi w con i ha risposto di no, che possiamo dire della relazione di mi e doppuni? M acc che mi accetta. Allora, mi accetta boni, ok? Lo riconoscete questo linguaggio? Quindi mi m' è una macchina che risponde sì quando mi non accetta w con i e vini è l'input di M' e invece risponde di no quando mi accetta bug e doppia v è l'input di M'. Che linguaggio sta decidendo m' sta decidendo? Cioè il linguaggio di M' è LD. Ma è possibile questa cosa? No, perché sappiamo che LD poiché ND non appartiene ad re, non è possibile che il linguaggio di M' sia proprio LD. E questa è una contraddizione da cui otteniamo che lu non appartiene ad R. Ok? Questo è l'ultimo passaggio. È chiaro cosa abbiamo fatto? Questo ci dimostra che LO non appartiene a R. Non il fatto che la macchina universale non dia garanzia di risposta. Il fatto che la macchina universale non dia garanzie di risposta ci dice solamente che quella macchina che ci siamo inventati è una macchina che non dà garanzia di rispondere no, ma non ci dice nulla sul fatto che Lu soprasegnato non sia eh che Lu non sia in R. Ok. Sì, non ho capito bene come eh cioè come abbiamo fatto capire il linguaggio riconosciuto da M prim, perché noi dobbiamo guardare quand'è che è dobbiamo guardare qua quand'è Eh sì, vabbè, noi dobbiamo guardare qua. Noi ci rendiamo conto quand'è che risponde sì e quand'è che risponde no. Ok? Allora, la macchina risponde sì quando do w con i è non accettata da m con i e la macchina M' risponde no quando M accetta w con i. Ma questo è proprio LD. Allora, il linguaggio riconosciuto, il linguaggio deciso da M', eh cioè non è un linguaggio accettato da M' perché M' risponde sempre, per come l'abbiamo progettata, nel momento in cui assumiamo che mu soprasegnato risponda sempre. Quindi il linguaggio di M' è LD ed M' è progettata per rispondere sempre. Da ciò seguirebbe che LD apparteni ad R, ma ciò non è possibile. Ok? Da ciò ricaviamo che Lu non può appartenere alla classe R. Ok? Questo dimostra che Lu non appartiene alla classe R. È chiaro come come ci siamo arrivati? Ok. Il grafico la macchina che ricorda come MV o M1. Questa qua questa è M1. Allora, scrivo meglio, dai. M U. Ok. Alright. Chiaro? [Musica] Allora, noi ora ci chiediamo altra proprietà. L soprasegnato può appartenere ad R? Quindi noi abbiamo che Lu, facciamoci un disegnino R. Abbiamo che Lu sta qui, quindi sta in R e non in R. Ok. Adesso la domanda. Il complemento di Lu può stare in R? No. Mh. No, no, perché perché altrimenti LU sarebbe altrimenti sarebbero entrambi del L. Quindi il complemento di LU è un problema che sta fuori R. Ok? Alrgri. Abbiamo qualche minuto prima della pausa. Adesso noi dimostriamo teorema. Avevamo che LD non appartiene ad re. Questa è la dimostrazione che abbiamo fatto lunedì scorso. Ok? teorema LD sovrasegnato appartiene ad re. Ok, adesso andiamo a dimostrare questa cosa. Dimostrazione. Ok. Come facciamo a dimostrare che il complemento di LD sta dentro R? Innanzitutto definiamolo, eh LD soprasegnato è l'insieme delle macchine di Touring M tale che M accetta Wi. Ok? Questo è il sovrasegnato, eh è il complemento di LD. Adesso noi vogliamo dimostrare che LD, il complemento di LD sta in R. Per dimostrare che il complemento di LD sta in R, che cosa dobbiamo mostrare? Che ci serve? Forse che LD sta al di fuori di R. Eh, sì. Bene. Definizione di linguaggi in R. Un linguaggio L sta in R. Abbiamo detto prima, eh linguaggio Liner. Esiste una macchina che accetta esiste una macchina che accetta L. Ok? Quindi se dobbiamo dimostrare che LD sovrastegnato sta in R, che cosa dobbiamo mostrare? Esiste. Dobbiamo mostrare una macchina. che accetti e legti la segnalaz. Ok? Questo è nel momento in cui vogliamo dimostrare che qualcosa sta dentro il re, dobbiamo mostrare un algoritmo una macchina. Quando dobbiamo dimostrare che qualcosa non sta in una certa classe, cioè non sta dentro R o non sta dentro R, allora ci dobbiamo inventare qualcosa. Ok? È chiaro? Ok? Quindi dobbiamo dimostrare che LD soprasegnato sta in re mostrando una macchina che una macchina che lo accetti. Ok. Come può essere fatta questa macchina? Guardate, guardate. Ecco qua. Guardate la definizione di questo linguaggio. L soprasegnato l'insieme delle macchine I, no? Le macchine MI tale che M quando riceve in input, la propria stessa codifica dice di sì. Come possiamo riconoscere questa cosa? Fto primi divertendo il risultato? Mh. È più semplice. Sì, quello che abbiamo fatto prima invece di mettere Natale una. Sì. Ah. Eh, sì. Ok. Però non possiamo invertire il risultato perché non è decidibile la cosa. Ok. Sì, sì, è la stessissima cosa. Bravo. Allora, come si fa? Dov'è? Perché non scrivo? Ok. m', cioè questa quindi è la macchina per L soprasegnato. Eh, quindi abbiamo in input M' facciamo nuovamente la copia, ok? E quindi che cosa abbiamo? M Y11 W. La mettiamo in input amu stavolta. Ok? Se la macchina M1 risponde sì, allora rispondiamo sì. Ok. Allora, dimostriamo che questa macchina effettivamente riconosca LD soprasegnato. Ok? Alright. Quindi, primo caso, assumiamo che mi appartenga a LD soprasegnato. Dobbiamo verificare se effettivamente questa macchina che ci siamo inventati si ferma e dice di sì. È il caso? Se M appartiene a LD soprasegnato, allora vuol dire che M accetta bucon. Quindi, nel momento in cui diamo la copia, cioè questa stringa qui, mi w con i impasto mu se ne accorge, si ferma, dice di sì e noi rispondiamo di sì. Ok? Quindi se M appartiene a LD soprasegnato, allora come la chiamiamo questa macchina? La chiamiamo, boh, M. Allora, M risponde di sì. Secondo caso, supponiamo che M non appartenga a LD sovrasegnato. Ok? Che succede in questo caso? Mh. In che senso nulla? Non si ferma. Chi non si ferma? M non si ferma perché non riconosce. M1 non si ferma e quindi M non risponde. Non risponde cosa? Il tempo finito. Eh, ma non risponde non risponde. Sì, quello è. Ok. Quindi, se mi appartiene a LD soprasegnato, per definizione di linguaggio MD sovprasegnato, vuol dire che Mi, mentre processa la propria stessa codifica, ok? Non non si ferma o risponde di no. Ok? Allora, questa macchina, poiché noi diamo in input a mu qua dentro l'input mi w con i, facciamola un po' più ricca, eh, se dice no, rispondiamo di no. Allora, siccome M non appartiene a L soprassegnato, allora vuol dire che M non risponde di sì sulla propria stessa codifica. Quindi due sono i casi. O mi sulla propria stessa codifica si ferma e dice di no o non si ferma proprio. Se M si ferma e dice di no sulla propria stessa codifica, allora la simulazione qua si ferma. Prendiamo il no e lo diamo in output. Ok? Se mi invece non si arresta sulla propria stessa codifica, allora MU, questa MU qua, simulando mi su W con i non si fermerà mai e quindi m non risponde di sì. Ok? Quindi se M I non appartiene a L dis segnato, abbiamo che M risponde no oppure M non risponde, che è quello che ci serviva tu. Ok? Di conseguenza questa M, come ce la siamo inventati, è una macchina che decide LD soprasegnato. Ok? Per questa ragione LD sovrasegnato appartiene ad RE e quindi LD soprasegnato sta qua. Ok? Però ultima considerazione e poi ci fermiamo per la pausa. LD che sta, guardate un po', LD che sta dentro il re significa che LD sta potenzialmente qua dentro, cioè può stare qui, qui, qui, qui. Ok? Perché noi abbiamo semplicemente detto che LD non sta LD soprasegnato non sta al di fuori del bordo di R, però potrebbe stare tanto dentro da trare qua dentro. Ok? Allora, la domanda che ora ci facciamo è LD sovrasegnato. LD sovprasegnato appartiene o no ad R? Guardiamo il disegnino, no? Perché se appartenesse ad R, allora anche L apparten appartenerebbe R. Noi sappiamo che non appartiene ad R e quindi non appartiene nemmeno ad R. Ok? Quindi LD noi abbiamo che LD actually does not belong to R. Ok? Chiaro? Chiaro come abbiamo ragionato finora? che sta diventando un pelino un po' più tricky rispetto a progettare funzioni di transizione. Ok, va bene. Facciamo una pausa di quarto d'ora. Ok. Ora continuiamo a vedere un po' di linguaggi decidibili, indecidibili. Questo qua dove andiamo un po' a vedere delle dimostrazioni. Quello che abbiamo visto finora era chiaro, avete seguito? Ok, perché continueremo su questo tenore per per un po' di lezioni. Ok? Eh, alright. Allora, quello che introduciamo ora sì, sto andando. Allora, quello che introduciamo ora è il problema dell'arresto, ok? che è una cosa che abbiamo già visto intuitivamente all'inizio per farvi vedere che ci stavano problemi indecidibili. Oggi lo definiamo proprio come linguaggio per macchine di Turing perché è una cosa che poi ci servirà nelle lezioni successive. Eh, introduciamo l'arresto ora, poi una variante dell'arresto che poi è quella che ci serve in alcune riduzioni che vedremo. Quindi ci concentriamo. Dove vedete? Yes. H. Definiamo il linguaggio dell'arresto halt. Ok. Il linguaggio HT è l'insieme delle coppie di stringhe. Macchina stringa. Ok. La questione è: è possibile che in input di una macchina abbiamo una macchina? Cioè che gliela ficchiamo? con i bulloni di dentro, eh, potremmo l'input è una codifica, ok? Cioè, quando io dico abbiamo in input una macchina e una stringa, cioè la macchina in input a un'altra macchina, non è la macchina che ce la picchiamo con l'input, è una codifica di macchina, ok? è una stringa binaria che codifica la funzione di transizione di m per, cioè alla fine son tutte stringhe, questo cioè vi è chiaro perché le stringhe uno le può le può interpretare come cavolo ti piace. Se noi prendiamo prendiamo il vostro computer e facciamo il dump di un pezzo di memoria, no? che tiriamo fuori una stringa binaria, siamo in grado di stabilire se quello è un video o un audio o un pezzo di codice eseguibile? No, quella è una stringa finale, dipende dall'interpretazione che diamo. Quindi, quando diciamo che il linguaggio halt è fatto dalle coppie macchine stringhe, cioè il primo pezzo della coppia non è una macchina con i bulloni, è una stringa che codifica che codifica la che codifica la funzione di transizione di quella macchina. Ok? che che sia chiaro. Eh, allora, quindi abbiamo il linguaggio H, le coppie macchina stringa tale che M si arresta su W. Ok? Questa è la definizione del linguaggio dell'arresto. Ok? Questo è il problema classico che negli anni 30 dimostrò essere indecci, cioè lui prova su quello ha lavorato. Ok? Quindi se noi abbiamo una macchina e una coppia macchina M stringa W, allora noi vorremmo essere in grado di stabilire se M processando W si arresta. Mi sapete dire che differenza c'è fra il linguaggio HT e il linguaggio lu? Lu è l'insieme di cosa? Delle coppie macchina stringa tale che M M accetta W. Ok? Questa è la differenza. Cioè in LU la macchina che ricevi input W non solo si deve fermare, si deve fermare e dire di sì. Per il linguaggio halt la cosa è un po' più lasca. Fanno parte del linguaggio dell'arresto tutte le coppie macchina stringa tale che M processando W prima o poi si ferma. Potrebbe dire di sì, potrebbe dire di no. A noi quello che ci interessa è che M si arresti, non che m risponda di sì. Per lu ci interessa che M risponda di sì. Ok? Quindi i due linguaggi sono diversi, sono definite sulle stesse istanze, coppie, macchine, stringhe, ma le istanze sì di un linguaggio sono non sono tutte le stanze sì dell'altro. Ok. Ok. Allora, vogliamo studiare la decidibilità del linguaggio dell'arresto. Ok? Quindi, teorema Halt, secondo voi appartiene o non appartiene nel re? Non appartiene. Attenzione. Sì, prego. Partiene perché se terminarlo intuitivamente come Sì, sì, giusto. Un secondo, un secondo. Se la macchina rispond Ma quale macchina? La macchina che accetta. Ah, è come la vuole progettare la macchina che accetta linguage alto. Ok, va bene, va bene così. E dai, cosa un'altra cosa. Ok, secondo. Poi c'era lei, mi pare. Possiamo vedere. come l'insieme del linguaggio LU LU segnato. In principio uno potrebbe vedere dove ci va a far guys, ve lo ripeto, come si fa a dimostrare che un certo linguaggio sta in R? Esiste una macchina che aveva accenti. Ok. Riusciremmo ad inventarci una macchina c'era lei mi pare che accetti HT. Sì, usiamo la macchina universale per simulare il programma. Ok. Sì, noi possiamo accettare Halt, ok? Tramite l'utilizzo di una macchina universale. Ok? Quindi teorema HT. appartiene ad re. Dimostrazione per dimostrare che halt appartiene a re per definizione di linguaggi che appartengono del re, che un linguaggio L appartiene al re, se esiste una macchina che accetti L, dobbiamo mostrare una macchina che accetti halt. E ce la disegniamo, la chiamiamo MH per dire che è la macchina che decide Halt. Ok? Qual è l'input macchina? È una macchina che accetta il linguaggio Halt, quindi che si prende in input la coppia la coppia MW MW. Ok? Quindi la macchina halt MH è una macchina che prende in input queste coppie. Ok? Come ci suggeriva il nostro collega, noi possiamo fare una cosa semplice, la diamo impasto alla macchina universale. Quindi la macchina universale inizierà a processare, a simulare M su W. Se la macchina si ferma e dice sì, noi diciamo di sì. Se la macchina universale nella sua simulazione si ferma e dice di no, che facciamo? Diciamo di sì, perché noi siamo interessati solamente all'arresto. Se la macchina universale luppa non facciamo niente, ok? Ovviamente, ma continueremo a seguire, non ci non ci fermiamo mai. Ok? Giusto. Sì, sì, sì, sì. Cioè perché mh praticamente ha al suo interno la codifica della funzione di transizione di MU, solo che gli cambiamo un pochino gli stati finali, ok? Cioè mh fa un test finale che se MU nel suo nella sua simulazione arriva ad arrestarsi indipendentemente dalla risposta, allora MH dice di sì, altrimenti segue mu all'infinito e gli va appresso. Ok? per dimostrare che eh quindi questa macchina è effettivamente che MH. Dobbiamo dimostrare quindi che il linguaggio di MH è propriamente alt. Dobbiamo dimostrare insomma che si comporta per come ci aspettiamo. Ok? Quindi due sono i possibili casi. La string la coppia MW appartiene ad ahalt e questa macchina MH deve rispondere di sì. Oppure la stringa MW non appartiene ad Ault e allora la macchina MH non deve rispondere di sì. Ok? È chiaro? Supponiamo che il caso che MW appartenga al linguaggio halt. Ok? Che cosa possiamo concludere? Quindi mu inizia a processare m su w. Noi stiamo assumendo che la coppia MW è un'istanza s del linguaggio halt, il che significa che M m mentre processa W a un certo punto si ferma. Ok? Questo per assunzione, perché stiamo assumendo di star di star ricevendo in input una coppia MW che sia unistanza sì della del linguaggio HT. Ok? Quindi che fa la macchina U mentre simula M su W? Sira si arresta, no? E per definizione di come abbiamo abbiamo definito questa macchina che mu si arresta e se dice di sì o dice di no, comunque diremo di sì. Allora, vuol dire che la macchina MH risponde di sì. È chiaro? Quindi, semmai Mh dovesse ricevere input un'istanza sì del linguaggio halt, la macchina MH correttamente risponde di sì. Ok? Supponiamo ora che la coppia MW è un'istanza no del linguaggio alt. Ok? Quindi riceviamo un'istanza no del linguaggio HT. Se MW è un'istanza no del linguaggio Halt, significa che M quando riceve input w non si ferma. Ok? Che possiamo dire quindi della simulazione di mu di questo mu eh su la stringa di input mond che m che mu loop e quindi mh non risponde e in particolare non risponde non risponde sì non risponde sì che è quello che ci serve. Quindi MH non risponde. Ok? Quindi questo che cosa ci dice? Ci dice che il linguaggio halt appartiene ad R per quello che ci siamo detti. Quindi alt potrebbe stare qua, potrebbe stare qui dentro, potrebbe stare qua dentro. Ok? E quindi non lo sappiamo ancora. Quello che noi quello che sappiamo è che Alt sta alt sta da qualche parte qua. Potrebbe per giunta stare qui, quindi Sì. Ma visto che per come l'abbiamo disegnata non c'è un range di uscita, no? Da MH, non basta dire che non risponde proprio, cioè è importante dire che non risponde sì. Vboh, non risponde sì, non risponde proprio. È ok, cioè l'importante è che non non risponda sì nel momento in cui doveva dire di no. Ok? Quindi, ok, ora quello che noi ci chiediamo è se il linguaggio HT, che adesso noi sappiamo essere da qualche parte qua, se sta in R e non in R oppure sta proprio in R. Ok, c'abbiamo spazio. Sì. Teorema H. Ok. La macchina che abbiamo progettato prima, che è questa qua, la macchina che abbiamo appena progettato, MH, ok? Lavora su Alt, che cosa fa? Lo accetta o lo decide? Lo accetta, ok? Non dà garanzia di arresto in caso di no. Ok. Questa cosa è sufficiente per farci dire che Halt non è un problema ricorsivo? No, questa cosa ci permette semplicemente di dire che la macchina MH, per come l'abbiamo progettata, non dà garanzia di risposta a no. Ok? Quindi, per dimostrare adesso se il problema Halt sia dentro R o meno, ci dobbiamo inventare altro. Ok? Per se volessimo dimostrare che il problema halt sta dentro R, sem mai volessimo dimostrare questa cosa, che cosa dovremmo fare? Dovrem per dimostrare che Halt sia dentro R, noi la definizione qual è? Un linguaggio è dentro R se ci sta una macchina che lo decide. Quindi, per mostrare che Halt sia dentro e R dovremmo mostrare una macchina che è sempre in grado di stabilire se per una data coppia MW M si ferma sul W. Pensateci 20 secondi. Secondo voi sta cosa si fa? Prima lezione. Come visto prima lezione? il problema disibilia. Allora, questa cosa non si fa, quindi il problema non è in R, però dobbiamo dimostrarlo, ok? Non è in R, dobbiamo dimostrarlo. Ok? Quindi regole che ci tiriamo fuori. Quando dobbiamo mostrare che un linguaggio sia in re o in r, dobbiamo mostrare macchine che o le accettano o le decidono. Se vogliamo tirare fuori linguaggi da R o re, ci dobbiamo inventare delle dimostrazioni più sofisticate. Ok? Quindi dobbiamo dimostrare che halt non appartiene a R. Questo è un po' più intricato. Vi guido, vi guido io. Dimostrazione. Anche questa è una dimostrazione per assurdo. Ok. Supponiamo assurdo che H appartenda ad R. Ok? Allora, esiste una macchina, chiamiamola MH asterisco, che decide Alt decide. Eh, ok. deterministica o non deterministica che decide Hal. Ok? Quindi stiamo assumendo per assurdo che Halt appartenga all'insieme dei linguaggi ricorsivi. Per definizione di linguaggio ricorsivo, semmai Halt dovesse essere dentro R, allora ci deve essere una macchina di touring, deterministica o non deterministica, che è in grado di decidere halt, ok? Cioè è in grado di dare sempre la risposta. Eh, ok. E la chiamiamo MH MH asterisco. Noi sfruttiamo MH asterisco in questo modo. Vediamo un po' se ce la facciamo. [Musica] Anche in questo caso costruiamo una macchina M primo apposta. e facciamo questa cosa qua. Riceviamo input una coppia MW. [Musica] La diamo input a mh star [Musica] e funziona così. Quindi m' ha come prima parte della propria esecuzione la funzione di transizione di MHTAR che stiamo assumendo essere una macchina di Turing che decide il problema dell'arresto, quindi è una macchina di Turing che è sempre in grado di dirci se la eh la macchina M si ferma o meno su W. Ok? Allora, facciamo questa cosa un pelino più sofisticata. Se la macchina MH Star risponde di no, allora rispondiamo di no. Se la macchina MH Star risponde di sì, noi facciamo partire la macchina universale. Ok? e si prende in input MW. Ancora non è finita, eh, è un po' trucchettosa questa macchina. Allora, che fa questa macchina M'O? Questa macchina MO, come prima fase di computazione, esegue sul proprio input MHTAR. MHTAR dà garanzia di arresto perché stiamo supponendo essere una macchina che decide il problema Halt, ok? Se MHSTAR risponde di no, prendiamo quella risposta e la diamo in output, ok? La sputiamo fuori. M' la ricopia in uscita. Ok? Se invece MH star risponde di sì, noi diamo questa risposta sì come un segnale per avviare una computazione su una macchina universale, ok? E la macchina universale processa M e W. Ok? È chiaro che facciamo? Quindi prendiamo MW, le processiamo prima dentro MHT. Se MH ST dice di no, ci fermiamo e diciamo di no. Se MH Star dice di sì, allora facciamo partire una funzione di transizione di una macchina universale nuovamente sulla sulla coppia M W. Ok? Dopodiché uh che ho fatto? Se la macchina universale risponde di sì, rispondiamo di sì. Se la macchina risponde di no, rispondiamo di no. Ok, qua non c'abbiamo più spazio grandioso. Dobbiamo ora capire che fa questa macchina. Cioè, di nuovo ci chiediamo qual è il linguaggio deciso da M prim. Questo è il linguaggio di M' che cos'è? Ragioniamo nuovamente per casi. Voi vedete più o meno. Ok. Supponiamo che la macchina M', quindi M' risponde di sì. Ok, facciamo lo stesso lavoro di prima, andiamo al contrario. Ok? Supponiamo quindi che la macchina M' abbia risposto di sì. Come vedete, se la macchina ha risposto di sì, vuol dire che stavamo ricevendo sì dalla macchina MU. Ok? E quindi cosa riceveva in input MU? MW. Quindi se la macchina M' ci risponde di sì, vuol dire che cosa? Tra M e W. M M accetta W. Ok. Quindi se la macchina M', se una tale macchina M' definita in questo modo risponde di sì, allora vuol dire che M accetta w B. Ok? Supponiamo ora, vedete sì, che m' risponde binomo. Guardiamo sempre le possibili risposte. Quante strade ci portano a no? Due. Partiamo da quella in alto, ok? Quella in alto che cosa ci dice? Se la macchina risponde no per il no in alto, vuol dire che stavamo ricevendo no da mu. Se la macchina MU ci sta dicendo di no, che cosa ci sta comunicando? Appartiene a Attenzione, la relazione sempre fra M e W che ci sta se M ci sta dicendo di no, cosa ci sta dicendo sulla relazione fra M e W? che non accetta che m non accetta w. Ok? Quindi se m' risponde no, allora m risponde no su W. Oppure vediamo l'altra strada. Qual è l'altro no che ci può dare la macchina? La macchina non e è quella di sotto. Ok. Da dove proveniva quel no? Da MH Star, che noi stiamo supponendo essere una macchina che decide l'arresto. Se MH Star ci ha detto di no, è chiaro cosa stiamo facendo? Stiamo seguendo le strade dei no. Prima abbiamo visto che cosa significa se riceviamo no dal branch di sopra. Ora ci stiamo chiedendo che cosa significa se riceviamo no dal branchio di sotto. Allora, se riceviamo no dal branchio di sotto vuol dire che stiamo sputando fuori il no di MH star. Ma se MH star ci sta dicendo no sulla coppia Mw, che cosa significa? Che M non si arresta su W. Ok? Quindi non accetta W per non arresto, ok? Oppure M non si arresta. Eh M e come non si arresta su W, quindi la risposta sarebbe no. Ok? La sua risposta sarebbe no. Qual è il linguaggio deciso da M'? Lu. È lu una tale macchina decide Lu. Non è che lo accetta. Una tale macchina decide Lu. È chiaro come ci siamo arrivati? Quindi, semmai halt appartenesse ad, allora noi saremmo in grado di costruire una macchina M' che decide Lu. Ok, è chiaro? È chiaro per tutti? Ok, andiamo alla nostra mappa. Se esiste una macchina che decide LU, allora LU dove starebbe? In R. Ma noi sappiamo che Lu in R non ci sta, quindi è una contraddizione per forza. Quindi halt eh No, dov'è? Alt non appartiene ad R. È chiaro come ci siamo arrivati? Ok. E no. Mettiamo nel nostro schemino alt sta qui. Ok. Adesso se halt sta in re e non in R, dove sta il complemento di Halt? Sta fuori R, quindi qui ci sta il complemento di HT. Chiaro? Ultimo problema che vediamo oggi, questa è una variante interessante del problema dell'arresto perché la utilizzeremo in alcune circostanze. A stanze halt epil, ok? Che è il problema dell'arresto su stringa vuota. Cioè, dato un programma e non gli do niente in input, questo si arresta o non si arresta? Questa è la cosa, ok? È una variante, quindi è l'insieme delle macchine M tale che M mannia M si arresta su Ok? Quindi è una variante del problema dell'arresto. La versione standard è dare una macchina una stringa. È vero, no, che questa macchina progettando questa stringa a un certo punto si ferma? Quello è il problema dell'arresto. Arresto su stringa vuota. Date un programma. È vero o no che questo programma se non gli diamo niente in input prima o poi si arresta? Questo è. Ok? Vogliamo capire nuovamente la decidibilità. Ci siamo? Sì. Theorem. Theorem. La decidibilità o meno di questo linguaggio. Ok. Halt. Secondo voi sta in re o non ci sta? Sì. Sì. Perché? Perché una distanza particolare di alfa. Quindi è come se ad alta si più basso. Esattamente. Sì, sì, sì. Interessante modo di ragionare. Quindi Halt appartiene ad error. Una cosa che potremmo fare, infatti, essendo un'istanza particolare di HT, la dimostrazione c'è a noi serve una macchinetta, no, che è in grado di accettare il linguaggio, semplicemente prende in input M, la diamo in passo alla macchina MU, am gli diamo pure EP e alla fine facciamo la stessa cosa. Come potete vedere la costruzione è proprio la stessa. Ok? E qua loop e questo è mh su. Ok? Allora, dobbiamo mostrare adesso che il linguaggio di Mhp è esattamente halt ep. Ok? Primo caso, m è un'istanza s di halt epil. Quindi, se riceviamo in input una stringa sì, un'istanza s del linguaggio halt e significa che la stringa la macchina M quando riceve input la stringa vuota si arresta. Ok? Quello che ci chiediamo è se Mhyp ci dice di sì o ci dice di no. Che cosa fa Mh? Se ricevi input una stringa M che codifica una macchina che si arresta sulla stringa vuota? ci dice di sì perché perché la simulazione di MU, cioè il running di M dentro MH sì che si arresti e quindi noi rispondiamo sì. Quindi m se M appartiene ad a halt ep allora m hp risponde di sì. Ok? Supponiamo che m non sia un'istanza sì di alta e quindi è un'istanza no. Che cosa possiamo dire riguardo alla risposta data da MH? Quindi rtiamo ricevendo input una stringa M che è un'istanza no di halt epsil, quindi è una è una macchina M che su input vuoto non si arresta. Che fa la macchina? Mh? Non risponde sì. Non risponde sì. Lupa. Ok. Quindi MHP non risponde sì. Da cui il linguaggio di Lmp è halt eps da cui halt epsil è un problema ricorsivamente enumerabile. Ok? Come al solito noi sappiamo a questo punto che altro da qualche parte qua dentro. Vogliamo capire se sta in R o non sta in R. Ok? Quindi è lo stesso lavoretto che abbiamo fatto l'altra vol l'abbiamo fatto prima. Ok? Secondo voi, signore, halt epil sta o non sta in r? Ha intuito? Non appartiene, intuitivamente non appartiene a R. Ok? Però lo dobbiamo dimostrare di nuovo. Siccome dobbiamo dimostrare una non appartenenza a una classe, è purtroppo la non appartenenza a una classe significa che non esiste una macchina, questo ci comporta l'uso di dimostrazioni più sofisticate. Quindi l'appartenenza di un linguaggio alla classe si dimostra mostrando l'esistenza di una macchina. Il fatto che un linguaggio non appartiene a una classe si si dovrebbe dimostrare con la non esistenza di una macchina, ma le macchine sono infinite, quindi non è che le possiamo considerare tutte, ci dobbiamo inventare in un altro modo, quindi servono delle dimostrazioni. Ok? Quindi altartiene ad R, si dimostra in maniera simile. Vi guido io pure stavolta di nuovo per assurdo. Supponiamo per assurdo che alt appartenga ad R. Allora, esiste MH star che decide, quindi proprio decide how. Ok? Quindi il trucchetto sarà simile alla dimostrazione di prima, sarà sfruttare mh star all'interno di un'altra macchina e far vedere che questa macchina sa fare meraviglie, cose che non ci aspettiamo possa fare. Ok? Allora, la macchina che definiamo è questa qua, eh? Ok, quindi abbiamo M primo, la macchina M primo che riceve in input una coppia MW shape. Allora, questo modulo fa una cosa particolare. Ok. Quindi m' fa questa cosa qua, riceve in input la coppia, una coppia di stringhe, macchina, stringa e come prima cosa, a differenza dell'altra, ok, fa un'altra cosa, eh, prende in input questa coppia MW e sputa fuori una macchina che chiamiamo la chiamiamo MW M tilde di W. Dai, che così è una cosa un simbolo mai visto prima. Ok? Potemo chiamarlo piccolo di W, mi serve l'erso. Ok, quindi M' prende questa coppia M, la fa passare dentro un modulo di reshaping che sputa fuori in output una macchina, cioè sputa fuori in output una rappresentazione di una funzione di transizione di questa macchina particolare che chiamiamo MW builde. Adesso MW tild MW tilde è una macchina particolare che fa così, scrive sul nastro W, quindi MBLD è una macchina un pochino particolare. La prima cosa che fa è se ne fotte di quello che c'è input. Scrive in input w. Ok? Dopodiché fa partire la funzione di transizione di M. Quindi, per cosa scrive su nastro w, quindi esegue, quindi si comporta come M. Ok? dopo aver scritto si comporta Sì, sì, parte la funzione di transizione di M. Quindi potete capire che M til W, che è la codifica di una macchina di Touring, in realtà come si ottiene? Prendiamo la funzione di transizione di m che ci arriva dall'input, gli aggiungiamo un po' di stati per scrivere sul nastro W, il resto è uguale, quindi poi copia forma si fa. Ok, questa macchina M tilde di w la diamo impasto a Mhy Se questa risponde sì, noi rispondiamo sì. Se questa risponde no, rispondiamo no. Ok? [Musica] È chiaro come funziona questa macchina m'O? La domanda è di nuovo la stessa. Qual è il linguaggio di M'? Cioè che cosa è in grado di decidere questa macchina? Si fa al solito modo. Supponiamo che questa macchina che m' risponde di sì. Quindi m' m' dice sì. Ok, che cosa possiamo dire? Ok, guardiamo le strade, i branch. Se la macchina M prim sta dicendo di sì, è perché la macchina MHT sta dicendo di sì. Che significa? Cosa? che m di w tilde si è arrestata, significa che m di w tilde si è arrestata su quale input? Sull'input vuoto, perché questo è quello che ci dice MH non sta però come si comporta mte di W? La prima cosa che fa è scrivere su nastro w. Di conseguenza, se Mh ci sta dicendo che M tilde di doppia V si sta arrestando sulla stringa vuota, in realtà è perché M si sta arrestando sul W. Capite il passaggio? Ripetiamo perché dobbiamo considerare che cosa faccia M do butdinde. Mutilde è una macchina stramba. è una macchina che scrive sul proprio input e cioè se la canda e se la suona. MW TDE è una macchina che scrive il proprio stesso input, cioè scrive una cosa sulla string in input e poi dice "Va, ora me lo decido." Ok? E come una macchina dice gli arriva in impuls me ne frego, ci scrivo Pippo, vediamo che succede. Ok? Quindi se MW ti su input vuoto si arresta perché è una informazione che ci viene data dal fatto che MHY ST ci dice che si sta fermando, allora vuol dire che M su w si arresta. È chiaro? È chiaro per tutti questa cosa qua? Quindi se M pr' di sì, allora M si arresta. su B M supponiamo dica di no. Guys, ci siamo quasi. Eh, guardiamolo, è esattamente quello. Guardiamo il dettaglio. M' di no. Vuol dire che il nodo se lo sta prendendo da mh star. Se mh star sta dicendo di no su m w, vuol dire che m su w non si è arrestato, quindi m non si arresta su W. Qual è il linguaggio di M'O? [Musica] Sì, è il linguaggio HT, cioè M primo sta decidendo alt, m' decide [Musica] Halt. Ok, andiamo al nostro schemino. È possibile che M' decida Halt? No, perché halt abbiamo appena dimostrato che è ricorsivamente numerabile ma non ricorsivo. Per questa ragione halt e un linguaggio recorsivamente numerabile ma non ricorsivo, ok? Perché andiamo in contraddizione e quindi l'assunzione per assurdo iniziale è falsa. Ultima domanda e poi ci congediamo. Dove sta il complemento di halt e? fuori dal re. Sta fuori dai re perché perché senò sarebbero entrambi in R. Ok, chiaro? Oggi è stato un po' più tricky, eh? Grazie mille. Buon pranzo o buon riposo.