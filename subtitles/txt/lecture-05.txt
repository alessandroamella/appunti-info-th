Ok, [Musica] vi è chiaro cosa abbiamo fatto la scorsa volta? Come abbiamo definito le cose? Un po' lungo, ma giusto per essere un po' formali. Alla fine, alla fin fine, quelle erano tutte definizioni per formalizzare il concetto di accertazione dei macchina di Turi. Ci siamo inventati un po' di nomi eccetera, è chiaro a tutti come l'abbiamo costruito, come sono state definite, eccetera. Eh, quindi recup veloce e poi vediamo degli esercizi. Quindi, cosa cos'è una macchina di Touring? Abbiamo detto che una macchina di Turouring è un automa. anch'esso ha stati finiti, nel senso che i possibili stati di funzionamento di una macchina di Touring sono limitati e sono e sono finiti, cioè non cambiano durante l'esecuzione, non cambia né il numero di di stati, né la funzione né gli edges che li che li collegano. Cioè il programma non può cambiare. Quella è una cosa importante. Una volta che fissiamo il programma, quello è dato e punto finisce lì. Quindi è un automa stati finiti che ha la peculiarità di avere un nastro di input un po' vario. aperto come ho un nastro di input un po' vario, nel senso che è un nastro infinito che può essere letto e scritto, non solamente letto, eh, non serve a niente. Letto e scritto. Ah, no, non siia. e la testina di una macchina di touring, a differenza de degli automi stati finiti, per andare a destra e a sinistra. Ok? Questo quindi è ciò che caratterizza le macchine di Touring rispetto agli autati finiti. Queste proprietà della macchina di Touring, vedremo, le rendono universali, cioè quello che può fare una macchina di touring è sostanzialmente quello che può fare uno dei nostri del computer. Ok? Cioè, quindi quello che ci serve affinché abbiamo un device di calcolo universale che possa fare tutto è semplicemente leggere e scrivere e la possibilità di spostarci sulla memoria. Tutto qua. Ok? la funzione di transizione, quindi il programma deve essere fissato, nel senso una volta che noi accendiamo la macchina, cioè il programma è camblato nella macchina, non cambia, non è una cosa che la macchina a un certo punto decide "Ok, ora faccio una cosa differente." Ok? Eh, quindi questa è una peculiarità che mi invito a rifletterci perché dice "Ok, ma i nostri computer, i nostri computer invece seguono programmi differenti, no? Com'è questa faccenda? Com'è che le macchine di touring fanno una cosa soltanto e invece i nostri computer ne fanno di vario tipo? Vedremo dove si anninea, appunto, il l'inquo eh di com'è possibile che una macchina del genere poi diventi in generale. Eh, ok. E quindi quello che faremo oggi sono giusto un po' di esercizi per impratichirci sulla programmazione delle macchine di Touring perché domani introdurremo un formalismo leggermente diverso, dopodiché nella settimana successiva introdurremo le macchine tuning non deterministiche che ci danno un discreto potere di calcolo e di programmazione. Ok? Però prima di arrivare là dobbiamo avere un'idea di come funzionino le macchine di tuning deterministiche che vediamo oggi. Ok? Alrght. Vogliamo scrivere una macchina di tuning che riconosca questo linguaggio. Professore, l'esercizio che si su momento c'è un testo da come scusi esercizio che si è inventato su un momento. Sì, sì, son cose mi sono inventato io. Ok, vogliamo riconoscere questo linguaggio qui, il linguaggio sulle stringhe 01. Ok? Cioè il linguaggio sull'alfabeto 01 fatto dalle stringhe formate da due parti. C'è una prima parte che chiamiamo W, una seconda parte che chiamiamo W esponente R. Che cosa significa? Cosa significherà per noi esponente R? Significa che doppia B al contrario. Ok? Quindi le stringhe che fanno parte di questo linguaggio sono cose del tipo e così via. Ok? Anche la seconda conta fa parte di questo linguaggio perché come possiamo vedere qui W proviene da 01 star e quindi è una sequenza di 0 e 1 possibilmente vuota. Quindi nel momento in cui doppia V è vuota, il suo reverse è vuoto e quindi la stringa vuota. Ok? Adesso noi dobbiamo inventarci una macchina di Touring che è in grado di riconoscere di decidere questo linguaggio. Ah, ok. Volevo sottolinearvi questo. Siccome è stato fatto un dico di fretta, però alla fine della versione scorsa. Vi è chiaro quando una macchina de Touring decide un linguaggio e quando una macchina di Touring accetta un linguaggio? Per tutti la differenza. Noi usiamo due parole distinte per prenderci in carico il fatto che ci sono due scenari differenti. Una marketing decide un certo linguaggio se su ogni string input la macchina dà garanzia nel resto si ferma e dice sì. Vi ricordo che la macchina per dire sì si deve fermare non stato accettante. Per dire di no. Per non dire di sì, la macchina non deve arrestarsi in uno stato accettante, che significa o la macchina si arresta in uno stato non accettante o la macchina non si per proprio. Ok? Quindi una macchina decid un linguaggio se ci arriviamo insieme arresto. Quindi su ogni stringa di prima o poi si vendono e si però o in uno stato accettante o in uno stato non accettante. Ok? In quel caso la risposta per noi è no. Una macchina accetta un linguaggio. Se su tutte le stringhe che appartengono al linguaggio, la macchina si ferma e dice di sì. su tutte le stringhe che non appartengono al linguaggio, la macchina non le accetta, che significa che o si ferma in uno stato non accettante o non si ferma proprio. Ok, questa è la differenza. Attenzione alla gin eh. Ok. Quindi quello che noi vogliamo fare adesso è progettare una macchina diing che è in grado di decidere quel linguaggio. Eh, con buona probabilità nella prova di esame ci sarà dato un linguaggio scrivere una macchina di tuning che decide, no? Eh, il criterio che in genere ho sempre usato e continuerò ad usare è ovviamente non è che c'è un modo di decidere un linguaggio, ci sono vari modi di decidere un linguaggio. Qualsiasi modo che funzioni va bene, ok? Cioè, quando sul sulla braccio d'esame ci sarà scritto progettando una macchine bla bla bla che conosca che decida questo linguaggio. L'esercizio è corretto se la macchina decide il linguaggio. Ok? L'importante è che funzioni. Poi se fac un altro non importa, l'importante è che funzioni. Ok? Perché? Perché ci sono tanti modi di cri linguaggi. Alri? Allora, tra i 1000.000 modi che ci possiamo inventare per decidere questo linguaggio, io vi esorto nuovamente a visualizzare il funzionamento della macchina che è l'unico modo per riuscire ad esolvere questi esercizi, sennò c'è da impazzire. Ok? Allora, nella immagine che io mi dipingo [Musica] del funzionamento di questa macchina, fra i tanti modi che possiamo inventarci per far funzionare questa macchina, uno che possiamo usare è ad esempio questo. Allora, supponiamo di avere questo input, ok? Eh, ok. Questo è B. Questo è r. Allora, quello che noi facciamo è sostanzialmente questo. La macchina parte da qui, quindi abbiamo la testina là sopra. La macchina vede che è uno zero, mi aspetto che in fondo ci sia uno zero, quindi mi butto la testina a destra, quindi la porto in fondo e vado a controllare che in fondo ci sia uno zero. Ok? Dopodiché dovrei beccarmi il secondo carattere e andare al penultimo carattere. Ok? Per rendere la cosa ciclata, possiamo inventarci tanti modi. Un modo che possiamo fare è questo qui, quello che vi propongo io. Andiamo sul primo carattere, vediamo che carattere è, lo cancelliamo, andiamo in fondo e verifichiamo che in fondo ci sia lo stesso carattere. Lo cancelliamo, ritorniamo a posto. A questo punto andremo alla ricerca del del carattere più a sinistra perché il carattere precedente che era stato testato era stato cancellato. Quindi il primo carattere non blanco che è quello che ci interessa. Vediamo che cos'è. È un uno. Ok, lo cancelliamo. Andiamo in fondo, andiamo a verificare che in fondo ci sia un uno. Lo cancelliamo, torniamo indietro e andiamo avanti così. Ok? fino a quando cancelliamo tutto e la macchina alla fine dice sì, questa stringa era WW. Ok, quindi vogliamo adessoare all'interno della funzione di transizione di una macchina questo filmato che abbiamo in testa. Ok? Vi ricordo che il trucco, almeno il trucco che uso io è questo. Io vedo gli spostamenti, vedo nella mia testa gli spostamenti nella testina che vanno avanti e indietro. Si tratta poi di tradurre in un programma di funzionamento di una macchina sti spostamenti che non vedono la mia testa. Ok? Perché vi suggerisco questo? Perché se non lo fate è molto più complicato. Ok? Se vi parlate dentro è un casino. Ok? Allora, vediamo di disegnare, cioè di progettare la macchina che faccia questa cosa qua. Partiamo dallo stato iniziale che è lo stato Q0. Supponiamo, vi ricordo che quando la macchina parte la testina è sul primo carattere, ok? Non ce lo dobbiamo andare a cercare. La testina è sul primo carattere. Allora, facciamo questo. Supponiamo di leggere zero, lo cancelliamo, cioè ci scriviamo blank di sopra. Questa è una virgola. Avanti, significa leggo zero, scrivo blanche e vado avanti. Ok? e supponiamo di muoverci nello stato Q1. Quindi abbiamo letto il primo carattere, l'abbiamo cancellato. Che dobbiamo fare ora? Dobbiamo spostare la testina in fondo. Ok? Quindi quali caratteri, quali simboli dobbiamo saltare? 0 e 1. Ok? Quindi se c'è zero lascio zero e vado avanti. Se c'è uno lascio uno e vado avanti. Ok? Quindi abbiamo questa testina che salta tutto bla bla bla bla bla bla bla. A un certo punto ci accorgiamo di essere arrivati in fondo. Come ci accorgiamo di essere arrivati in fondo? Guardate al filmato nella vostra testa. Come riconosciamo il bordo? C'è un blank. Ok, quindi se c'è un blank, c'è un blank, lasciamo un blank e andiamo indietro Q2. Ok, quindi siamo arrivati in fondo al primo blank, siamo tornati indietro, di conseguenza abbiamo posizionato la testina sul carattere più a destra che sarebbe l'ultimo. Ok. Cosa ci aspettiamo di leggere? zero perché stiamo provenendo da una storia di computazione nel quale il carattere precedentemente eletto era zero. Ok? Quindi c'è zero, scriviamo black e andiamo indietro. Ok? Q3. OR a questo punto che cosa dobbiamo fare? Tornare indietro. Dobbiamo portare la testina indietro. Come la facciamo a portare indietro? Come abbiamo fatto prima, cioè dobbiamo saltare tutti i simboli che ci stanno sul nastro. Che simboli ci possono stare sul nastro? Guardate nella vostra testa. Zeri e uni. Ok? Quindi se c'è zero lasciamo zero e torniamo indietro. Se c'è uno lasciamo uno e torniamo indietro. Ok? Come ci accorgiamo di essere arrivati all'inizio? Stesso trucco. A un certo punto vedremo un blank. Ok. Quindi c'è blank. Lascio blank e andiamo. Destra o sinistra? No, destra. Destra. Avanti. Ok. Sì, avanti. Ok. Alright. Quindi questo pezzo di macchina ci occupa solamente di andare a matchare zero iniziali con zero finali. Ok? Se la macchina legge un ancora non abbiamo detto che fare, ok? Non sa che fare, quindi dobbiamo aggiungere un pezzo di funzione, ok? Che sia in grado di gestire il caso uno. Sarà molto differente, secondo voi? No, sarà simmetrico. Ok? Quindi partendo da 0, se leggiamo 1, lo cancelliamo e andiamo avanti. E andiamo in Q4. Ok? Cosa facciamo in Q4? Cioè dopo che vediamo il primo l'uno più a sinistra. Sì, lo cancelliamo e andiamo avanti. Come facciamo a far avanzare la testina? fato i punti, cioè che vado avanti che saltiamo tutti i simboli che ci vengono davanti senza importarcene troppo. Siccome i simboli che ci vengono avanti possono essere 0 e 1, saltiamo 0 e 1. Alri. 0 e vado avanti. Oppure 1 e vado avanti. Ok? Quindi cosa dobbiamo fare ora? Stiamo saltando tutto. Guardate il filmato nella vostra mente. Arriviamo in fondo. Come riconosciamo il fondo? Down blank. Ok. Alr. Quindi c'abbiamo blank blank. Torno indietro, vado in5. Dopodiché che carattere ci aspettiamo di osservare? un un perché nella storia di computazione, cioè su questo ramo della computazione della macchina avevamo letto un uno e quindi ci aspettiamo di leggere uno. Eh, ok, mi sono gradito uno lendo. Ok? Allora, in quest'ultimo pezzo qua noi leggiamo uno, lo cancelliamo e andiamo indietro e andiamo nello stato precedente Q3, che è lo stato nel quale praticamente noi riavvolgiamo il nastro, andiamo dietro e ripartiamo il ciclo. Quindi questo pezzo di macchina adesso è in grado di matchare 0 all'inizio e zero alla fine, uno all'inizio e uno alla fine. Ok? Questa macchina, così come è progettata, è in grado di accettare le stringhe? No, non ancora. Non abbiamo uno stato accettante. Ok. Come si fa ad accorgere questa macchina che è arrivato il momento di accettare la stringa? Quando Prego, quando c'è il Q0 blank vuol dire che la stringa è vuota e che stato Ok. Sì, esattamente. Quindi la condizione per accettare è che quando siamo in un zero e non c'è rimasto niente, allora vuol dire che abbiamo matchato tutto. Quindi dice blank, lascio blank e vado avanti e vado in U75 Q6 e accettiamo. Ok, questa macchina è molto semplice. Andiamo a guardare i casi limite. Caso limite per questo linguaggio è che la stringa vuota deve essere accettata. Questa macchina accetta la stringa vuota. Sì. Ok, quindi ci va bene. Ok. Chiaro per tutti come funziona questa macchina? Dobbiamo ricapitolare, no? Alr, vediamone un'altra. Ok, la facciamo sull'altra. Vogliamo riconoscere un linguaggio N in cui c'è A n bm con m più grande di N più grande di 0. Ok? Che significa secondo voi questa notazione? Quali sono le stringhe che apparengono questo linguaggio? A a va bene? Intuitivamente se vogliamo descriverlo ad altro livello, che cos'è questo linguaggio? Cioè perché è troppo semplice, non lo dite. Qualunque stringa non vuota con più B che A. Sì, in cui le Aedono le B. Ok. Quindi non devono succedere cose strane. In mezzo abbiamo tutte le A, poi tutte le B e il numero di A deve essere maggiore del numero di B e ce ne deve stare sempre a -1. Ok? Ok. B yes B deve essere maggiore di di A. Ok? Il numero delle B deve essere maggiore del numero di A. Eh. Ok. Allora, qui introduco introduciamo un differente trick di programmazione di macchine di Touring che finora le che abbiamo visto non abbiamo rispettato perché erano cose molto semplici sia nell'esercizio, no, nell'esempio che abbiamo visto durante la definizione la scorsa volta, sia nell'esempio precedente, noi che cosa facciamo? Vediamo caratteri, li iniziamo a processare, li cancelliamo, eccetera. Ok? Adesso, sebbene questa cosa sia completamente legale e si può fare, di fatto la cosa che abbiamo fatto funzionava, io ve lo sconsiglio perché iniziare a cancellare caratteri sul simboli sul nastro di input, se non stiamo attenti, potremmo iniziare a introdurre buchi nell'input, ok? E quindi poi ti viene difficile stabilire in quale parte del nastro siamo, se iniziamo ad inserire blank in mezzo al nastro che abbiamo ricevuto. Ok? Quindi il mio suggerimento è evitare di cancellare l'input, lo possiamo marcare, ok? ci mettiamo dei simboli di sopra, però evitare di cancellare non è che non si può se può fare, però rende le cose un pelino più complicate se iniziamo a cancellare pezzi in mezzo all'input perché poi stiamo separando la scrinta di input in due o più parti e poi viene difficile capire ma adesso la testina quale parte sta leggendo. Ok? Quindi il mio consiglio è, a meno che non sia un esercizio semplicissimo, di evitare di cancellare le i singoli input. È preferibile marcarli in maniera tale che abbiamo sempre una stringa compatta di singoli non link sul nastro. Ok? Allora, [Applauso] fatto [Musica] ok, supponiamo di riconoscere questa stringa. Ok. Come potremmo farlo? [Musica] Un modo vale l'altro. Eh, non c'è il modo. Esiste un comando per non fare testino da un passo dall'altro? Eh, sì, ma lo vediamo prossima settimana. Sì, sì. Cioè, si può fare solo che non è che se teniamo la testina ferma la macchina è più potente perché uno che può fare avanti e va indietro e la riporto apposta. Ok. Poi introduciamo questa cosa qua per semplificarci. Eh, la testina e sta ferma. Forse sta complicando un po' la cosa, però potremmo prendere una posizione del nastro che ci piace. Comunque tipo metterla alla fine della stringa e la marco inizialmente con una X perché ho letto la prima A. Sì. Quando leggo una B metto Y, continuo a iterare e se alla fine è Y significa che B che A. Sì, sì, sì, sì, sì. Allora, quello che potremmo fare, facciamo un altro colore. Alri. Una cosa che potremmo fare è che noi iniziamo sempre dal primo carattere, dal primo simbolo, leggiamo una a, ci mettiamo una X di sopra, ci spostiamo verso avanti alla ricerca della prima B. Quando arriviamo alla prima Bamo una Y di sopra, torniamo indietro alla ricerca della prima A. Ok, arrivati là ci mettiamo un'altra x, dopodiché ci mettiamo una y, una b, ci mettiamo una y di sopra, torniamo indietro, a un certo punto saranno finite. Quello che dobbiamo fare è andare a verificare che c'è una mi residua, ok? E che non ci sia spazzatura do, capito? Ok. Allora, dobbiamo adesso codificare all'interno della funzione di transizione di una macchina di Touring questo modo di funzionare. Ok, ve lo ripeto, ormai l'avrete capito. Guardate, la soluzione sta nell'immagine che vedete nella vostra testa. Ok? Come vedete il filmato, il filmato vi dice che deve fare la macchinitura, quindi si tratta di eh trasformare in un programma ste cose che si muovono nella vostra testa. Ok? Ok. Partiamo quindi da Q0. Q0 è in primo stato. Partiamo sempre dal primo simbolo. Ok. Quindi all'inizio che carattere leggiamo? Che simbolo leggiamo? A perché noi ci aspettiamo che ce ne sia sempre a meno una perché n è strettamente mag. Scriviamo x sopra a e andiamo avanti e andiamo in1. Ok? Vediamo un po' qui che cosa sta succedendo. Quindi abbiamo marcato la prima A qui. Dobbiamo andare adesso verso le B. Prima di arrivare alle B, che cosa incontriamo per strada? A. Che ci dobbiamo fare con le A? Le saltiamo. Ok? Quindi c'è una A, lascio A e vado avanti. Ok. Qua c'è quel problema della scorsa volta. Se c'ho A B A AB a B che succede? Quindi dobbiamo eh distinguere le fasi di computazione della macchina, quindi ci superiamo tutte le A. Ok? Poi inizieranno delle delle B. Allora, qual è il modo migliore questo intervento? Supponiamo dovrei anche saltare delle Y. Ecco, dipende a che punto di computazione siamo. Potremmo saltare delle guardiamolo così. Ok, mi salto tutte le A. Supponiamo che stiamo in mezzo al calcolo, no? E che quindi un po' di A, un po' di B le abbiamo già matche. Quindi che cosa avremo? X X X X XX. Poi ci stanno un po' di a, poi ci stanno un po' di y e poi ci stanno dei per evitare di dover saltare dell' y non potremmo iniziare via a partire dalla fine. Sì, sì. Allora, quello che possiamo fare è c'è una y, lascio la Y e vado avanti. Q2 vedete? Sì, dobbiamo saltare che cosa? Abbiamo saltato l'emo, abbiamo beccato la prima y, poi che ci sta? altri y che prendiamo e le saltiamo. Quindi c'è Y, lascio Y e vado avanti. E arriviamo fin dove? B arriviamo alla prima B che è dopo le Y. Già marcate. Ok, ragazzi, non guardate me, guardate il vostro filmato. Ci stanno le X sopra le A, c'abbiamo X X X, ok? Ci stanno le A e ci stanno le Y. Ok? dipingo nell'aria così nella vostra testa. Poi ci stanno le B, quindi stiamo saltando le A, saltiamo le Y, arriviamo a cosa? Cosa c'è qua? B c una B. Quindi arrivata alla prima B, cosa facciamo? Scriviamo Y andiamo indietro. Voi la vedete? Sì. Andiamo indietro qua e qua. Ok, andiamo in Q3. Ok. Non bisogna fare parte anche da Q1 in questo caso. Cosa? Come? Scus non bisogna fare un uguale da Q1 anche da Q1. Sì, adesso lo aggiungiamo. Aspetta un secondo. Ok. Quindi abbiamo marcato la B, ci abbiamo messo l'abbiamo marcata con la Y, non ci stiamo spostando indietro. Quindi dove abbiamo spostato la testina? Yes. Fammi scrivere qua. Ok. A ah a B. Ok. Abbiamo marcato. Quindi siamo in questa situazione. Ok, abbiamo marcato una Siamo in mezzo al calcolo, quindi ne abbiamo già fatti un po'. Ok, spostiamo la testina in avanti e abbiamo trovato la bcciante. Ci scriviamo Y di sopra. Dobbiamo adesso andare in questa direzione. Quindi cosa troviamo? Prima la Y. C'è Y e torniamo indietro. Poi cosa troviamo? Troviamo le A. A A e andiamo indietro. E andiamo indietro fino a che punto? fin fino a quando troviamo la x delle A. Ok? Quindi facciamo così, sarà c'è X, scrivo X e vado avanti. Ok? A quel punto, una volta che abbiamo incontrato la prima X, ci siamo spostati sulla prima A disponibile. A quel punto dobbiamo continuare a fare lo stesso lavoro. Ok? Un attimo. È chiaro che se siamo in mezzo alla computazione questo è quello che si deve fare. Chiaro per tutti? Siamo in mezzo, eh, non siamo all'inizio perché ora ci dobbiamo gestire un po' di casi limite. Chiaro? Perché questa macchina così ben disegnata non funziona al primo giro. Ok? Perché? Che cosa succede al primo giro? Supponiamo quindi che siamo proprio partiti. Ok? Mettiamo una x sulla A. Andiamo avanti. Ok? Il progetto della funzione di transizione al momento ci dice che superato il blocco delle A, ci aspettiamo il blocco delle Y. Ok? Però al primissimo giro quante Y ci stanno sul nastro? Nessuna. Ok? Quindi noi dobbiamo inserire un ramo extra, ok? per gestire il primissimo caso. Secondo voi dove va inserito? Tra Q1 e Q3. Quindi tra Q1 e Q3 c'è B. Scriviamo Y e andiamo avanti o indietro? Indietro. Ok. Alr. Right. Quindi questo pezzo di macchina si occupa di andare a meccare le A con le B. Ogni volta che ce l' A scrivo X, vado alla ricerca della prima B, ci metto Y, torno indietro e vado su e giù, su e giù. Ok. Quand'è che la macchina si accorge che le A sono finite, che le abbiamo cadute? Qu secondo quando letto quando sono la letto una y andiamo a destra e facciamo una y esattamente cioè quando sulla via del ritorno tra q3 e q0 leggiamo una x e andiamo avanti. Quindi siamo arrivati qua, leggiamo una x e andiamo avanti. Se quello che leggiamo di nuovo è una y perché magari questa era stata marcata x, arriviamo qua, andiamo avanti, quello che leggiamo è una Y. Sì, non capisco a cosa serva Q2. Si può mettere Y scrivere Y sempre qua. Sì. Allora, la questione è che noi vogliamo evitare che stringhe del tipo A b a A bengano accettate. Quindi noi disegniamo, noi progettiamo, dico disegniamo perché in inglese è design, noi progettiamo la funzione di transizione in maniera tale che la macchina si aspetti un blocco di A sedito da un blocco di B. Però, cioè, se incontrasse un A si bloccherebbe l'altra, no? Se incontra una Y, perché è stata è una B precedentemente marcata, quello che potrebbe accadere è passarci di sopra. Se tu hai A B A AB A AB, no? E a A a A, marco la prima A con la prima B, quella diventa Y. torno indietro. Dopodiché marco la A, la B marcata Y la supero e supererò anche le altre A. Quindi c'è un po' un problemino. Ok? Quindi questa è la ragione, è semplicemente per sincerarsi che la macchina non possa accettare cose strane. Ok? Quindi siamo arrivati a un punto in cui abbiamo che la macchina facciamo questo poi che la macchina eh trova la x + a sinistra, va avanti qua e invece di trovare una a trova una y, chiaro? Per tutta la condizione di uscita. Quindi qua c'è una y, scrivo y e vado avanti. Ok. E andiamo in Q. Che altro dobbiamo fare qui? Stai un secondo, un attimo. Che voce nuova. Ma che voce nuova. Ok. La presenza almeno un altro B. Dobbiamo andare a beccarci un'altra B. Ok. Prima delle B che cosa compare? Il il blocco delle Y. Ok? Quindi c le superiamo tutte, abbiamo y Y e andiamo avanti. A un certo punto noi cosa ci aspettiamo di vedere? una B, una B, quindi c'è B, scrivo B e vado avanti. Q5, cos'è che vedete là? Ok, però però qua Q4 non potrebbe essere rimanente a Q2 e poi da Q2 facciamo che se mettiamo Q2, cioè facciamo un No, conviene tenerli separati, ok? Mh mh. Perché poi qua tu ti aspetti una B, perché un'altra cosa che va fatta, dopo che vediamo una B, cosa dobbiamo fare? Controllare che non ci dobbiamo controllare che tutto il resto sia B e non ci siano a strambe in fondo che non avevo mai visto prima. Ok? Quindi arriviamo qua, avanziamo, c'è B, scrivo B e vado avanti. Quand'è che termino il controllo? M sepo o è una oppure no quando quando proprio finiamo, quand'è che sappiamo che Ah, ok, abbiamo fatto e quindi che carattere vedo? Il blank. Quindi c'è blank, scrivo blank, vado avanti, sei agetto. Ok. Sì, dai. Q4 e Q5 li facciamo combinare come Q4 e Q5 li facciamo la se insieme. Q4 e Q5. Cioè, se mettiamo B andiamo avanti eamo un plan andiamo nel nostro finale. Sì, sì, si potrebbe un Q0. Dopo bisogna anche saltare perché sub dove in quanto si torna? No, no, perché noi becchiamo sempre l'ultima che è stata scritta, quindi non ce ne stanno, stanno prima. Bene. Eh, ok. [Musica] Che facciamo? Pausa. Ne vediamo unaltro. Ne vediamo un'altra. Uno semplice, però faccio una pausa. Questo è vogliamo riconoscere il linguaggio L fatto dalle scri n BN. Sì. M tali che n m è ugn. Questo possiamo andare più veloce perché, insomma, è qualcosa che molto simile a quello che abbiamo già visto che è. Come si può fare? Offo quei due invece di cancellare solo una B ne cancelliamo due. Ne marchiamo due. Ok? Quindi è una cosa molto simile a quello che abbiamo fatto, quindi possiamo farlo un po' più velocemente. Ok? Quindi abbiamo che ne so, A a A B B b. Ok? Quello che noi facciamo è che per ogni a che troviamo marchiamo 2y con la 2 b con una y, ok? Alri, quindi abbiamo Q0 Q0. Quindi leggiamo A, scriviamo X e andiamo avanti. Diamo V1, saltiamo tutte le A, c'è A, lascio A e vado avanti. Dopodiché abbiamo lo stesso ingippo della volta precedente, quindi saltiamo tutte le y, c'è Y, scrivo Y, attenzione, vado avanti, q2 c'è Y, scrivo Y e vado avanti. Dopodiché mi aspetto di beccare eh 2b, quindi c'è B, scrivo Y e vado avanti e qua c'è Q3, un'altra c'è B, scrivo Y e vado dietro. Lo vedete? Sì. Q4 riavvolgo sulle Y. riavvolgo sulle A. Sto andando troppo veloce e ne abbiamo marcato una X. Siamo andati alla ricerca della B. Ok? C'è qui lo stesso problema di prima perché dipende se è il primo giro o sono i giri successivi. Supponiamo di essere in mezzo al calcolo. Quindi c'è una, scrivo X, vado a cercarmi, mi salto le A, mi salto le Y, cerco le 2 B, le marco, torno indietro alla ricerca della X, ok? che è l'ultimo marking su A, quindi c'è X, scrivo X e vado avanti. Quindi questo pezzo di macchina è in grado di processare in mezzo al calcolo il fatto che ogni a viene match con 2 b. Ok? Ci dobbiamo solo adesso interessare del caso del primissimo giro nel quale y ancora sul nastro non ce ne stanno. Quindi in questo caso abbiamo leggo A e scrivo X, mi salto tutte le A. Non leggerò delle y al primo giro perché non ci stanno, quindi leggerò una B. Quello che faccio è aggiungere questo, c'è B, scrivo Y e vado avanti. Ok? riuscite a vedere? Sì, per tutti quello abbiamo fatto finora. Ok. Condizione di accettazione. Quand'è che la macchina si accorge che le A sono finite? Quando c'è un X, c'è un Y. Quando c'è un Y dopo una X. Quindi in Q0 legendo Y, scrivo Y e vado avanti. Q questo era 4 Q5, cioè Y. Scrivo Y e vado avanti. Ok? Quand'è che ci fermiamo? Quando blank Quando leggiamo blank? Quando leggiamo blank sappiamo che il numero di B che avevamo visto era esattamente il doppio delle A, quindi c'è il blank. Scrivo un e scrivo un e vado avanti Q6 e accettiamo. Chiaro per tutti? Vi ripeto, questo è un modo, ci sono tanti altri modi. Potevamo andare e cercare le B dalla fine. Quindi prendo una A, cancello una A, vado in fondo, prendo 2 B e le cancello e faccio questo lavoro qua. Ci sono tanti modi per fare questa cosa. Qualsiasi modo che funziona per me va bene, ok? E ci possiamo fermare un pochino. 10 minuti, un quarto d'ora. Facciamo un quarto d'ora. Ok, ripartiamo. [Musica] [Musica] [Musica] Chiaro per tutti quello che abbiamo fatto finora? Assumo di sì. Ok. Linguaggio L. Allora, W cancell V. W appartiene ad A for B. classico. Allora, cos'è questo linguaggio? Riscriviamola ad alto livello nel linguaggio delle stringhe su qua alfa beto AB. Ok? Quindi abbiamo singoli AB e le stringhe che appartengono in questo linguaggio che proprietà hanno Sì. Eh, ma cosa? Quindi c'è un calcio di letto in mezzo e poi Sì. Quindi sono quelle stringhe definite su A B cancelletto. Abbiamo un primo pezzo di stringa chiamato do B, dopo c'è un cancelletto, dopodiché c'è la stessa stringa ripetuta, però stavolta non reversa. Ok? Questa è la differenza rispetto all'esercizio prima. Quindi non abbiamo la stringa al contrario tale per cui andiamo inizio fine e andiamo a fare il matching. Ok? La cosa è che abbiamo la stringa si ripete a metà. Per semplificarci le cose mettiamo un bel cancelletto che ci separa le due metà. Ok? Sì, quel più là a Aab+ là sopra significa che W ha almeno un simbolo, ok? Quindi W vuoto non ci va bene. Quindi qua dentro ci stanno cose del tipo A B cancelletto A B A cancelletto A B A cancelletto BA e Zone. Ok. Dobbiamo quindi adesso inventarci una strategia A B A cancell A B A A A. Ok? Ho una strategia per questa macchina, ok? Cioè che cosa può fare una macchina per riconoscere questo genere di di stringhe? Ok? Come possiamo fa'? Un attimo, vediamo se ci muove. Un secondo, un secondo. Ok, prego. Leggiamo. Lo so che voi non sapete. Leggiamo la prima A e poi scorriamo finché non tiamo il canciletto e cerchiamo un A do con il cancelletto. Sì. Sì. Ok. Come facciamo a sapere? A che punto della stringa siamo arrivati? Marchiamo sempre, li marchiamo, ok? Possiamo marcare X, Y, whatever we want. Ok? Quello che vi suggerisco fra i 1000 modi e marchiamo con una X dove siamo arrivati. Ecco, questo, per esempio, è un esercizio dove eh cancellarsi i simboli, cioè che leggiamo la superiamo il cancelletto e cancelliamo quella. Mh. Ok. Si gestisce, eh, non è che non si gestisce, però iniziamo a introdurre buchi nella stringa sul nostro input che non ci semplifica il compito, ok? Non è che è sbagliato, ma aumentiamo il rischio di sbagliare, ok? Quindi quello che facciamo è leggiamo per esempio un simbolo, lo marchiamo, andiamo alla ricerca. Andiamo alla ricerca. Questo dopo il cancelletto becchiamo lo stesso simbolo, lo marchiamo, poi torniamo indietro, becchiamo la B, andiamo avanti, cerchiamo un'altra B e andiamo avanti e indietro. Facciamo questo lavoro qua. Ok. Alri. Adesso dobbiamo in questo caso siamo simbolo di marca tua, no? Sì, sì, sì, sì, sì. Qua non non stiamo contando, quindi non c'è bisogno di Dobbiamo solo tenere traccia di a che punto siamo arrivati e quindi basta un solo simbolo di marcatura. Ok? Eh, voi vedete ok? Q0. Ok, noi iniziamo quando la macchina si accende a fra testina sempre sul primo simbolo. Supponiamo di leggere un simbolo. Che simbolo leggiamo? Ipotizziamo. Un A. Supponiamo di leggere un A. Ok? Quindi leggiamo A, scriviamo X, andiamo avanti e andiamo in Q1. Ok? Quindi cosa abbiamo fatto? Abbiamo fatto questa prima operazione. Eravamo sull' ci abbiamo messo una X, dopodiché dobbiamo avanzare la testina. Ok? Come glielo diciamo alla macchina di fare questo lavoro qui? Quindi c'era una ci abbiamo messo una X, dopodiché che ci sta? Ci stanno sequenze di A e B non meglio specificate, poi ci sta un cancelletto, ok? E dopodiché ci sta il resto della stringa. Concentriamoci sul primo pezzo, quindi dobbiamo saltare tutto quello che c'è in mezzo. Come glielo come glielo diciamo? Quindi se c'è A lascio A e andiamo avanti. Se c'è B lascio B e vado avanti. Ok? Quindi avanziamo la testina, no? Su questo nastro fino a quando arriviamo a che cosa? al cancelletto. Quindi c'è cancelletto, lascio il cancelletto e vado avanti e andiamo in Q2. Ok. Cosa dobbiamo fare ora? La macchina deve andare alla ricerca di quale simbolo? della A perché stiamo proveniendo da una storia di computazione nel quale era stata letta una A, quindi ci dobbiamo cercare una A. Questa a dove appare? Subito dopo il cancelletto necessariamente? No, se siamo in mezzo al guado, c'avremo un po' di x, avremo queste x qua che quindi dobbiamo saltarcele, ok? Quindi in Q2 facciamo che se c'è una X la lasciamo lì dov'è e andiamo avanti fino a quando troviamo quale carattere? Fino a quando troviamo un A. Quindi c'è A, scriviamo X e torniamo indietro Ok? Tornando indietro, dove abbiamo spostato la testina? Cosa starà leggendo la testina una volta che siamo sulla A, ci abbiamo messo una X e stiamo tornando indietro? Siamo nella seconda parte, eh? Siamo siamo qui. Eh, ho una Y. Ok. ci sono eventualmente delle X che noi dobbiamo saltare perché magari provengono da precedenti marcature. Quindi c'è X sarebbero queste qui, eh, sono queste, quindi c'è X, scrivo X e vado indietro. Quand'è che sappiamo che ci dobbiamo fermare? Cioè, che cosa succede una volta che stiamo saltando con tutte le x? un a un certo punto arriva sto cancelletto. Ok, quindi cancelletto, lascio cancelletto e andiamo indietro, andiamo in Q4. Ok. Cosa c'è a questo punto? Abbiamo superato il cancelletto. Cosa abbiamo? Abbiamo una sequenza, c'è la parte di W che non abbiamo ancora processato e non è stata marcata, quindi c'è una sequenza non meglio specificata di A e B che dobbiamo riavvolgere perché stiamo tornando indietro e andiamo fino a che punto? Fino alla X. Fino alla x. Quando troviamo la X sappiamo di essere arrivati al bordo, cioè dove c'è la cosa successiva. Ok? Quindi c'è A, scrivo A e vado indietro. B, scrivo B e vado indietro. A un certo punto eh, ci sarà la X la mettiamo qua. C'è X, scrivo X e vado avanti e vado in Q5. Lo lasciamo così perché dobbiamo fare un po' di cose prima. Ok, questo pezzo di macchina è un po' mongo, lo dobbiamo un attimo assemblare per farci tornare i conti, eh, perché questo pezzo di macchina al momento, questa parte qua che cosa fa? Legge una, va alla ricerca di una A e poi riavvolgi il nastro. Ok? Se legge una B non sa che fare. Dobbiamo, cioè scrivere il resto della funzione di transizione che gestisca in questo caso. Ok? Se leggiamo una B dobbiamo andare alla ricerca in B e quindi noi progettiamo un ramo diverso di computazione. Ok? Quindi quando siamo in Q0, se c'è una B scrivo X e vado avanti. Dopodiché devo fare lo stesso lavoro di prima, Q6, eccetera. Allora, prima osservazione, [Musica] quindi siamo in Q0. Siamo in Q0, dai, siamo in Q0. Se leggiamo A, andiamo in Q1 e poi avanziamo. Chiaro per tutti? Siamo in Q0, leggiamo B, andiamo in questo stato e poi dovremmo fare la stessa cosa, avanzare. Perché io non mergio Q6 e Q1? Prego. Perché in Q6 sto cercando una B, cioè ho cercato una B. Esattamente. Sì. Se io li metto assieme ci perdiamo la storia, cioè ci perdiamo il fatto di aver letto A. Ok. La macchina di Touring memorizza cosa ha visto spostandosi in stati particolari. Ok? Cioè la macchina di Touring non è che ha la RAM, ok? Si ricorda di aver visto una A perché o di aver visto una B perché segue processi di computazione, cioè stati di computazione differenti. Poi o ce lo potremmo pure scrivere su un nastro da qualche parte, però questa è una cosa che vedremo nelle prossime lezioni, ok? Quindi c'è Q6, leggo A, scrivo A e vado avanti. Leggo B, scrivo B e vado avanti. Fino a quando c'è un cancelletto cioè X, scrivo X e vado avanti. Dopodiché, quindi, ho letto una B, mi salto tutto quello che c'è, arrivo al cancelletto, lo salto e mi salto tutte le X. A quel punto cosa mi aspetto di leggere? B. E che cosa facciamo? Leggiamo una B, scriviamo una X, torniamo indietro. E in quale stato andiamo? Q4. Eh, no, Q3 qua, ok? C'è B, scrivo X e vado dietro, ok? Perché da Q3 in poi è solo un riavvolgimento, non ho più necessità di sapere che cosa avevo detto prima. Ok? So, regà, cosa abbiamo fatto finora? Questo pezzo di macchina si occupa di letta una A andare alla ricerca di una A, letta una B andare alla ricerca di una B. Da qui in poi fa il riavvolgimento del nastro per fare questo wild, insomma, in maniera tale che torna dietro alla ricerca del primo carattere utile. Ok? Il primo carattere è utile. Quindi, abbiamo letto una B, ad esempio, ci ho messo una X, riavvolgiamo sulle X, supero il cancelletto, quindi stiamo spostando la testina indietro, riavvolgo le A e le B, qualsiasi cosa ci sia, a un certo punto arrivo alla X che è proprio all'inizio inizio che ci demarca l'inizio, no, di che cosa avevamo controllato fino a quel momento. Dopodiché spostiamo, come vediamo qua, la testina in avanti, cioè troviamo la X, andiamo avanti, spostiamo la testina in avanti, dove si troverà la testina? Dove si trova? Su una A o su una B? Se leggiamo A dovremmo andare alla ricerca di una A. Se leggiamo B dovremmo andare alla ricerca di una B. Questo pezzo di macchina è stato già codificato qua dentro e qua dentro. Quindi adesso si tratta di unire questo stato qua. A questo selgiamo A e a questo selgiamo B. Ok? Quindi siamo in Q5. Eh, come si fa? Si così? Leggete? [Musica] Questo c'è a scrivo x e vado avanti. Oppure qua c'è B, scrivo X e vado avanti. Ok, un attimo. Ma non si può usare T0 direttamente al posto di No, perché ci serve di leggere almeno un carattere. E no, però se noi colleghiamo Q4 a Q0, Q4, cioè se noi il collegamento da Q4 a Q0 lo facciamo da Q40. Ah ah dipende sempre come scrivi poi la macchina, cioè l'importante è che, ok, per come l'ho progettata io, mi serve partire da là, l'importante è che tu una la leggi sempre. Ok? Ok. Allora, questa macchina, questo pezzo, così mi vedete fino pezzo va a meccare A con A, poi va qua, riavvolge B con B, poi va qua, riavvolge. Qui abbiamo i passaggi quando una nuova A è stata letta, una nuova B è stata letta, qui questo è il punto nevralgico. Ok? Perché adesso stiamo che cosa stiamo facendo? Leggo una A, mi vado a cercare un A. Leggo una B, mi vado a cercare una B. Ok? Come facciamo a sapere che abbiamociato tutto? Cioè, quindi testina, leggo, vado avanti, torno indietro, leggo un carattere, vado avanti, torno indietro. Pa pa pa. A un certo punto arriverà che la testina che cosa succede? destro quando stiamo è l'ultimo giro che stiamo tornando indietro, saltiamo tutte le x che stanno qua, arriviamo al cancelletto. Guardatelo, eh, lo dovete vedere nella vostra, ci sono tutte le x quale, stiamo saltando, arriviamo a questo cancelletto. Lo saltiamo, arriviamo a questa x, andiamo avanti, che è questo passaggio qua, eh. Arriviamo al cancelletto, torniamo indietro, becchiamo la X, andiamo avanti. Dove ci troviamo? Sul cancelletto. Quello ci sta segnalando che nella parte di stringa precedente al cancelletto non c'è più niente che va toccato. Ok. Alright. Allora, quindi siamo qua. Dov'è Q5? Voi la vedete? Sì. Quindi c'è X, scrivo X e vado avanti, mi ritrovo nuovamente sul cancelletto. C'è il cancelletto, lascio cancelletto e vado avanti e vado in Q8. Q8. Ok, rimane un'ultima cosa per finire questo check. Ok, che va fatto? E quando controllato che siano solo X dopo il cancelletto. Ok. Sì, dobbiamo vedere che è stato marcato tutta la parte dopo il cancelletto. Quindi qua c'è X, lascio X e vado avanti. E quand'è che posso accettare? Quando trovo blank. C'è blank. Scrivo blank e vado avanti e accetto il Q. Chiaro come funziona? Di nuovo, questo è un modo di programmarlo. Altri modi vanno che funzionino, vanno bene lo stesso. Ok? Alri. Volevo far vedere questo perché ci serve per la prossima lezione. Facciamo un ultimo esercizio e poi chi vediamo. Ok. Ben, voglio riconoscere il linguaggio A n BN N C tale che N è maggiore di 0. Questo questo alright. Adro livello, che cosa significa questo linguaggio? Tipo A C a A B C. Sì. Sì. in cui il numero delle Abiamo una sequenza di A, seamo una sequenza di Beguite da una sequenza di C. Il numero delle A deve essere uguale al numero delle B che deve essere uguale al numero delle C. Ok? Quindi dobbiamo un po' andarcele a contare. Ok? Qui ci sono ovviamente anche in questo caso 1000 modi di riconoscerlo. Come possiamo fare? Mettiamo la successiva, poi sì e poi torniamo indietro. Sì. Ok. Di nuovo qui quello che vi suggerisco è marcatele e non cancellatele perché senò si buga l'input ed è un po' un problema. Quindi quello che possiamo fare, mettiamo una X sulle A, mettiamo una Y sulle B, mettiamo una Z sulle C e torniamo indietro. Ok. Ok. stato iniziale Q0. Ok? Quando siamo in Q0, quindi quando la macchina viene accesa, quale simbolo vediamo sul nastro? Cosa ci aspettiamo? A. Un A. Quindi c'è A. Scrivo X e vado avanti e vado in uno. Ok. Qui c'è di nuovo il problema che abbiamo visto prima. Ok? Quindi arrivati in uno, che cosa facciamo? Saltiamo tutte le A. Quindi c'è A, scrivo A, virgola, vado avanti. Ok? A un certo punto saremo in mezzo alla computazione. Supponiamo di essere già in questo caso. Ok? fammene scrivere un po' in quindi qua c'è una x, qua c'è una y c'è una z. Quindi abbiamo scritto una X. Ok? Ora stiamo andando avanti alla ricerca di una B. Stiamo superando le aree residue. Cosa incontriamo poi? Y. Quindi c'è Y, scrivo Y e vado avanti. Q2. Dobbiamo saltare tutte le Y. Sì, questo qui in questo caso siamo noi a mettere le Y le mettiamo solo dopo la porzione delle A. Questa parte non la possiamo fare nel ciclo delle A. Se non avremo mai il caso in cui è a Y o A perché le mettiamo noi il modo per cui non possa essere una. Eh sì. Mh, anche nel caso di prima avevamo una condizione del genere. Il problema che però va visto, va, cioè se lo se lo separiamo così siamo sicuri che funziona. Se noi ci iniziamo a marcare delle B con le Y e queste sono un po' a metà stringa, il mio timore però ci si dovrebbe ragionare un po' di più, è che nel momento in cui io gli do la possibilità di saltare delle y e quindi avevo a poi c'erano delle B che erano state marcate con una Y precedentemente, poi riappaiono delle A, lui le supera. In realtà dovremmo evitarglielo, però, cioè, può essere pure che un'analisi più di fino della cosa ci dica che la macchina in realtà si ingeppa in quel caso, però non ne sono certo. Ok, quindi c'è y y e vado avanti, mi salto tutte le y residu ok? Fino a trovare che cosa? Trovare una B. Una B. Ok. Quindi c'è B, scrivo Y e vado avanti e andiamo in Q3. Quindi a che punto siamo arrivati che ci siamo marcati questa terza B. Ok, a questo punto dobbiamo andare avanti. Che cosa incontriamo andando avanti? Le Attenzione, abbiamo marcato questa B, abbiamo delle B residue delle Z. Ok. Eh. Ok. Quindi saltiamo tutte le B. C'è B, scrivo B e vado avanti. A un certo punto arriverà una Z. C'è Z, scrivo Z e vado avanti. Q4, salto tutte le Z. C'è Z, scrivo Z e vado avanti. Fino a quando arriviamo a che cosa? Mh, alla C. troviamo una C, c'è C, scrivo Z e torno indietro. Ok, 5. Quindi abbiamo messo una Z qui e ci stiamo ora spostando indietro. Ok, dobbiamo quindi ripercorrere tutto alla ricerca di cosa? Della prima A lasciata libera. Ora, in questo caso, come abbiamo già visto prima, non è necessario controllare l'ordine di z by b perché perché c'è questo pezzo che già lo fa, quindi non c'è bisogno di farlo di nuovo. Qui possiamo semplicemente riavvolgere tutto. Ok? Quindi i primi pezzi che incontriamo andando indietro sono Z, quindi c'è Z, scrivo Z e torno indietro. Dopo poi ci stanno le B. B, scrivo B e torno indietro. Poi Y, c'è Y, scrivo Y e torno indietro. E poi eh c'è A. Scrivo A e torno indietro. Ok. Ci fermiamo a che punto, guys. X. Ok, giusto. Torniamo indietro. Bla bla bla bla bla. Quando troviamo la prima X sappiamo di essere arrivati al bordo. Ok? Quindi leggo X, scrivo X e vado avanti. Ok? Stesso problema di prima. Questo pezzo qua funziona, ok? Nel mezzo della computazione. Cioè questo questa parte qua dopo che leggiamo le a si aspetta la presenza delle y, ok? Però quando siamo all'inizio inizio e y sul nastro non ce ne stavano, ok? Allora, dobbiamo prevedere il caso che da Q1 ci possiamo muovere alla lettura della prima B. Ok? Giusto una cosa. Questa macchina può ricevere in input una stringa che contiene A B C in vario ordine, magari nell'ordine giusto A B C bla e poi in mezzo ci stanno dei simboli Y. X Z, cioè la macchina in input trova delle X o delle Y. Che succede? Come se fosse già marcate. È come se fossero già marcate. Ed è un problema per macchina. Cioè se partendo da z0 se non mettiamo un primo argolo in cui leggiamo x y o z non si vede. Ok. Ma se la string in input ha simboli X, Y, Z, attenzione, questa macchina potrebbe avere problemi e magari accettare roba che non dovrebbe. Sì, sì, sicuri? No. Sì. Ma seconda domanda, questa macchina l'input può avere una stringa in cui singoli x, Y e Z compaiono? No, no, perché non fanno parte dell'alfabeto. No, perché non fanno parte dell'alfabeto di input. Ok? Vi ricordate la definizione di macchina di Touring? La macchina di Turing ha due alfabeti, uno che abbiamo chiamato sigma e uno che abbiamo chiamato gamma. L'alfabeto sigma ha i simboli che noi ci aspettiamo sul nastro quando la macchina viene accesa. L'alfabeto gamma contiene, a parte i simboli di sigma, contiene altri simboli che la macchina può scrivere, leggere, eccetera. Ok? Quindi la macchina non può ricevere all'inizio stringhe strambe in cui compaiono i simboli di nastro, ma non i simboli di input. Ok? Può ricevere sì stringhe strambe nel senso definite sull'alfabeto di input, ma sono cose su cui la macchina si deve arrestare e dire di no. Ok? Quindi cose strambe, tipo in input shop, stringhe che contengono marcatori o cose del genere, quindi simboli che stanno solo in gamba e non in SI, ma quella cosa non è possibile all'avvio della macchina, ok? All'avvio la macchina sull'input ha solamente simboli che provengono da sigma. Quindi che succede quando questa macchina trova in input simboli di gamma? Non succede niente perché questa macchina non può avere all'inizio della computazione simboli di gamma sul nastro. È chiaro per tutti questo? Ecco perché abbiamo definito due alfabeti diversi sulla macchina di During. È chiaro? Alright. Quindi questa macchina, questo pezzo di macchina finora e abbiamo concluso questo pezzo di macchina finora che fa? Prende una A la marca, cerca una B la marca, cerca una C la marca, torna indietro e va avanti e indietro, avanti indietro. Ok? Quand'è che sappiamo quand'è che questa macchina riconosce che sta per arrivare alla fine e che quindi deve passare a uno stato di computazione successiva nel quale verifichi che abbia marcato tutto correttamente? Sì. Dove? In quale stato? Sì. Ok. Se arriviamo in Q0 e leggiamo una Y, allora sappiamo che Allora sappiamo che non c'era più nessuna A da marcare. Ok? Possiamo direttamente accettare, cioè Q6 è accettante, no? Che dobbiamo fare? Dobbiamo controllare che non ci siano più B. Non ci siano più B. Quindi eh dov'è? Cos'è? Quindi superiamo tutte le y andiamo avanti. Dopodiché che ci aspettiamo di vedere? Le Z. Quindi c'è Z, lascio Z e vado avanti e andiamo in Q7. Che dobbiamo fare in Q7? Supero tutto le Z. Mettiamo qua c'è Z. Scrivo Z e vado avanti. Quand'è che possiamo accettare? Se possiamo accettare se vediamo un Se vediamo un blank. Quindi se in Q6 c'è blank lasciamo blank e andiamo avanti. Andiamo in Q8 e accettiamo. Una domanda. In questo caso tutto con condensare questa passaggio. Passaggio tutto condensare tanto mi importa devo controllare. Sì, in principio. Sì, sì, sì, sì, sì, perché è stato tutto controllato prima che fossero nella giusta sequenza. Ok. Ok. Sì, ma anche in questo caso bisogna collegare bisognerebbe collegare i nodi dove magari non c'è un quindi il primo giro. Eh sì, sì, non l'abbiamo fatto. Esattamente. Questo manca un pezzo in questa macchina. Ok, mi ero dimenticato. Ovviamente questo pezzo di macchina funziona, no, nei giri successivi. Nel primissimo giro, quando non c'è una Y, ovviamente noi facciamo questo. Colleghiamo da Q1 a Q3, leggo B, scrivo Y e vado avanti. Ok? E da qui, da Q3 a Q5 c'è C, scrivo Z e vado avanti quando Z ancora sul nastro non erano state messe, cioè proprio al primissimo giro. Ok, chiaro per tutti? Yes. Però una volta scritto Z dec. Ah, sì, sì. Dietro. Yes. Questo va dietro. Ah! Ah! Chiaro? È stato difficile? No. Ok. E con questo per oggi chiudiamo. Grazie mille. Buon pranzo.